





Chapter 25. Automated Configuration Strategies



Automated configuration of networking equipment is becoming a niche market, with companies springing up to
  develop tools and applications to ensure that human error is mitigated in
  the quest to achieve high availability. Whether you use external vendor
  software or the built-in JUNOScript tools to automate configuration of your
  equipment, it is necessary to develop strategies for the automation. At each
  level of the design and within each functional area, the key components of
  high availability may be different and your network automated configuration
  strategies must reflect this. Although automated configurations normally
  focus on carefully planned changes that are applied with the deployment of
  new equipment or services, you must also have strategies to handle automated
  configuration changes for issues that arise unexpectedly.













Configuration Change Types



When creating strategies for automating the configuration of your systems, it is not
    possible to take a one-size-fits-all approach. By examining the impact of
    configuration changes on various parts of the network architecture, as
    well as on various functional areas, it is possible to develop strategies
    that give the configuration automation the most impact in terms of
    improving and maintaining high availability. Separate strategies must be
    used when the automated configuration changes are designed, not to prevent
    human error in the configuration of the equipment, but rather to address
    outside forces that can reduce your network's high availability.




Deployment



When deploying new equipment or services into your network, you must
      determine what changes the initial deployment of the configurations or
      the introduction of the service may have on your network high
      availability. Although it is sometimes impossible to deploy a new piece
      of equipment without network disruption, introduction of the equipment
      should not lead to network downtime for a wide range of customers or
      future network downtime because of incompatibility or misconfiguration.
      By planning how services and equipment are to be deployed and how the
      configurations to support the new services and equipment are to be
      automated, you can create a plan that results in the least impact for
      your customers, peering points, and infrastructure equipment.




Network equipment



One of the most common uses for automated configuration is for deploying
        new equipment, either in the core of the network or at its edges. The
        use of automated configuration and configuration templates ensures
        that the addition of new equipment does not result in human errors in
        the configuration that cause network downtime. Once the network
        equipment is deployed, the infrastructure configuration strategies
        take over, but during the deployment, the following configuration
        sections should be automated:



Management interface


Hopefully, your network is using a robust Out of Band (OoB)
              management system, which is especially easy with the separate
              interface on the routing engines (REs) of Juniper Networks
              routers. Quite often, the initial configuration of the
              management interface is done manually, only to ensure that the
              tools being used during configuration automation can access the
              devices. Once the management interface is reachable, the
              automated tools can be used to configure the actual information
              on the interface.


Access


Automated configuration of how, when, and who can access
              configuration tools on the network equipment is imperative. The
              goal of automation is to reduce human error during
              configuration. Therefore, it is necessary to quickly lock down
              access to the network equipment to only the devices and users
              allowed to make configuration changes. It is a best common
              practice to ensure that a network device is brought into the
              network's Authentication, Authorization, and Accounting (AAA)
              architecture immediately after it is attached to
              the network to ensure strong authentication and
              accounting.

Note
In all the networks in which I have worked, a common set
                of default usernames and passwords have existed that are used
                during the initial configuration of a device. By getting the
                device into the AAA environment as quickly as possible, it is
                easy to mitigate the threat caused by users in the network
                attempting to access new equipment using those normally widely
                known credentials.



Logging


As we discussed in Chapter 9, logging is a
              great way to maintain network uptime, but it is quite easy to
              make a typo that leads to logs being sent into the bit bucket.
              By ensuring that logging is enabled from the start, you can
              monitor configuration changes and user access during initial
              deployment of the equipment.


Security


Before automated infrastructure configuration changes are
              made, it is necessary to ensure that each device is configured
              with the security policies that are appropriate for its position
              in the network. By using the management interface and an OoB
              management network, it is possible to lock down the security of
              a device to only allow access through the management interface
              until the entire device is configured and is ready for
              operation.



Once the basic automated configurations have been made for
        access to the device and for logging of all future changes to the
        device, you can view the equipment as a piece of the infrastructure
        and can start using the automated configuration strategies required of
        that equipment's place in the network.





Services



Not all new items deployed to networks are hardware; in fact, a
        majority of new deployments consist of services that may or may not
        rely on new equipment. When deploying new services, it is often
        necessary to change the configuration of the underlying networking
        equipment to allow the service to perform as advertised. Often, your
        network technicians are on the hook for some aspects of ensuring high
        availability as a result of the creation and deployment of new services.

Note
A majority of the time it appears that the individuals
          deploying a new service do not consider the underlying network and
          the impact to high availability that it may cause. Consider a
          streaming video on an oversubscribed line. Although the large amount
          of streaming traffic may be causing network downtime, the network is
          normally blamed for any slowdown in other services. Thus, it is up
          to the network technicians to ensure that enough bandwidth is saved
          so that everyone has high availability, not just the service
          owners.

When deploying a new service, you can use the automated
        configuration to ensure that network traffic, or control
        traffic, is not visibly affected by the new service. For a
        new service, you should configure the following configuration sections
        using automated features:



Class of service (CoS) configurations


Depending on the service being introduced, you may need to modify
              the CoS settings across the network, including code point
              writing and rewriting, policer and buffer policies, and allowed
              bandwidth settings. Because CoS configurations are applied on a
              per-hop basis, they are extremely sensitive to differences in
              configuration across the network. Thus, it is necessary to
              ensure that they are consistent. Absolute consistency can be
              provided only through automated configuration techniques.


Protocol tweaks


Sometimes the new service will necessitate that currently
              unused knobs for the routing or management protocols are
              configured across the entire network. As with CoS
              configurations, the performance of these changes will be greatly
              affected if the changes are not made consistently across the
              entire network. The automated configuration functions ensure
              more consistent deployment.


Multiprotocol Label Switching (MPLS) traffic
            engineering


If the core over which the new service is to operate includes
              MPLS, you may need to adjust traffic engineering information
              across the entire core, or at least confirm that label-switched
              path (LSP) settings are consistently configured to signal the
              necessary settings for the path.


Control plane policies


To ensure that the new service does not affect the operation
              of the routing and other management systems, it is necessary to
              consistently apply policing of packets to the control plane
              (e.g., to the RE).



Once the new service is deployed and the configurations have
        been confirmed to be appropriate, the configuration changes can be
        transitioned to the infrastructure portion of the automated
        configurations and can become a baseline configuration of the network.






Infrastructure



At the core of any network attempting to provide high availability are big
      iron boxes designed to do the heavy lifting of keeping traffic flowing
      in the network. In looking at automating the configuration for
      infrastructure equipment for high availability, the focus should rest on
      the stability and proper functioning of the systems' data and control
      planes. Because of the nature of the core, the configurations on the
      devices evolve very slowly and do not require constant updates. However,
      when configuration changes are made, errors can lead to cascading issues
      and catastrophic downtime. To prevent human error from causing network
      downtime for the infrastructure, focus on the following areas when
      automating configurations:



Interface physical settings


Auto-negotiation and mismatched media can lead to all sorts of errors
            that not only are difficult to diagnose, but also are sometimes
            difficult to find. These types of errors can lead to
            unidirectional traffic on bidirectional links and other very
            strange behavior that may not really manifest itself until the
            interfaces start to reach saturation. Though auto-negotiation is a
            valid option on Juniper devices, it is a best common practice,
            especially in multivendor environments, to hardcode the link speed
            and media settings on core gear. The use of automated
            configuration of physical interface characteristics guarantees
            more consistent configuration.


Interface logical configurations


For certain protocols to operate properly, it is necessary
            to ensure that the address family is included on the interface
            logical configuration. Again, settings such as these, which are
            required across all interfaces across the core, are perfect
            candidates for automated configuration.


Interior Gateway Protocol (IGP) settings


Simple human typos in the IGPs, such as incorrect or
            mismatched subnet masks, authentication, and protocol interface
            settings, can lead to adjacency issues or routing errors. Other
            issues, including mismatched reference bandwidth settings, can
            lead to suboptimal routing and even links being overloaded.


Border Gateway Protocol (BGP) mesh


In networks where BGP is used for peering and transit traffic, or in networks
            running MPLS, the required full mesh of Internal BGP (IBGP)
            routers remains constant. Because of the
            requirement, as the size of the network increases, it becomes much
            easier to make an error that leads to less than a full mesh of
            IBGP peers. Using automated configuration to ensure the full mesh,
            it is possible to mitigate the threat of black-holing
            traffic.


BGP peering


Automated configuration ensures that BGP policies, attributes, and
            communities are used consistently across all IBGP and External BGP (EBGP) peering configurations, thus
            mitigating the threat that local network routing policies cause
            routing churn across the Internet in general.

Note
The North American Network Operators Group (NANOG)
              normally discusses the churn created in Internet routing tables
              introduced by BGP peers that are either established or torn down
              rapidly, or route
              information that is mistakenly or purposely injected or
              withdrawn in a short time period. Though it may not appear to be
              a high availability issue, after multiple complaints from the
              Internet routing community in general, it is possible to be
              sanctioned or to lose peering rights.



RE high availability


Simple errors, such as forgetting to have REs synchronize their
            configurations, can have a devastating effect on network uptime
            and can render RE redundancy useless.


CoS


One overlooked portion of high availability is the use of CoS
            across the network. Although using CoS may not prevent the
            downtime of particular pieces of network equipment, it does
            provide the appearance of continuous systems to customers, because
            their network responses or services do not suffer during a time of
            actual downtime in your network.



Using the commit scripts, it is possible to provide for an automated
      audit of these configurations each time the configuration is committed
      on the system. Event policies can also be written to alert the user
      anytime the configuration is committed, as well as copy all the results
      of the commit scripts to a remote workstation for auditing.





Ad Hoc Changes



It is truly unbelievable, but sometimes changes in network
      configuration are not the result of a carefully planned and reasoned
      meeting of the minds among technicians in the network, security, and
      services group. Instead, they are ad hoc changes that are necessary
      because of an incident, an event, or the revelation of a security hole
      somewhere in the network. These changes can also be made using
      configuration automation. Making them just requires a slightly different
      strategy.




Workarounds



Sometimes hardware or software issues arise that require network
        engineers to develop a workaround to achieve desired results. The
        issues can occur in the network gear or in the systems they support,
        but wherever they exist, the workaround must be applied so that high
        availability is maintained. Workaround configuration changes normally
        must be applied to multiple pieces of the network—the main equipment
        affected by the issue or support equipment affected by the issue.
        Thus, configuration automation provides the consistency and efficiency
        necessary.





One-off configurations



Although it may be officially discouraged, most networks have
        whole areas that are merely "one-offs"; that is, configurations
        developed solely to serve a corner case. With the uniqueness of these
        configurations, it is necessary to handle them very specially within a
        configuration automation scheme and to annotate them quite well,
        because they fall outside the normal scope of configurations.















Automation Strategies



The main purpose of automating configurations across the network is to ensure
    that neither human error nor lack of configuration consistency affects
    network uptime. Using the information we've provided in this chapter, it
    is possible to model configurations and templates to be used by JUNOScript, or other tools, to deploy the configurations.
    This section contains examples of using JUNOScript and other tools to
    confirm the automation of network device configuration.




Global Strategies



The best way to ensure consistent configurations across a network is to
      have a single source for your configuration scripts. The repository for
      the scripts should serve as a Concurrent Versions System (CVS) to ensure that all
      changes are noted, and as a clearinghouse from which the scripts are
      pulled by the machines. If you remember from previous chapters, the
      JUNOScope software provides a built-in CVS for configurations.
Luckily, with JUNOScript, you can point network devices to the
      location of the source script and then reload with the refresh command:

system {
    scripts {
        commit {
            allow-transients;
            file infrastructure.slax {
                source http://engineering.example.com/infrastructure.slax;
            }
        }
    }
}





Deployment



One of the times high availability is most threatened is when you
      deploy new equipment or services in the network. The engineers are
      responsible for ensuring that the new systems do not impact the existing
      network. To do this, automated configuration can be used to guarantee
      that the proper settings are applied during deployment and to ensure
      that a human error during deployment does not lead to downtime.




Hardware deployment



Having the ability to apply a single, baseline configuration to all
        equipment in the network to ensure that settings such as
        authentication, logging, and access are consistent is a great first
        step toward ensuring high availability. The best way to ensure that
        the equipment is configured consistently is to have a commit script to
        add all the necessary configurations to the device.
A commit script such as the one that follows consists of
        the basic JUNOScript boilerplate code, a macro and match statement to ensure
        that all the necessary information has been provided, and the commands
        to parse through the configuration and configure the baseline
        settings:

version 1.0;
ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";
import "../import/junos.xsl";
import "../import/junos.xsl";
var $macro-name = 'deploy.xsl';
match configuration {
  var $rid = routing-options/router-id;
  for-each (apply-macro[name = 'deploy']) {
    var $hostname = data[name = 'host-name']/value;
    var $fxp0-addr = data[name = 'mgmt-address']/value;
    var $backup-router = data[name = 'backup-router']/value;
    var $bkup-rtr = {
      if ($backup-router) {
      expr $backup-router;
      }
      else {
        var $fxp01 = substring-before($fxp0-addr, '.');
        var $fxp02 = substring-before(substring-after($fxp0-addr, '.'), '.');
        var $fxp03 = substring-before(substring-after(substring-after(
               $fxp0- addr, '.'), '.'), '.');
        var $plen = substring-after($fxp0-addr, '/');
        if ($plen = 22) {
          expr $fxp01 _ '.' _ $fxp02 _ '.' _ $fxp03 div 4 * 4 + 3 _ '.254';
        }
        else if ($plen = 24) {
          expr $fxp01 _ '.' _ $fxp02 _ '.' _ $fxp03 _ '.254';
        }
      }
    }
    if (not($rid) or not($hostname) or not($fxp0-addr)) {
       <xnm:error> {
         <message> "This script requires an ID, host-name, and mgmt-address.";
    }
  }
  else {
    <transient-change> {
      <system> {
        <domain-name> "example.com";
        <domain-search> "example.com";
        <backup-router> {
          <address> $bkup-rtr;
        }
        <time-zone> "America/Los_Angeles";
        <authentication-order> "radius";
        <authentication-order> "password";
        <root-authentication> {
          <encrypted-password>
                 "$dfdfsder4&fdsk*$.$fdj9)34556";
        }
        <name-server> {
        <name> "4.2.2.2";
        }
        <radius-server> {
          <name> "10.0.0.1";
          <secret> "$9$4xoDk5T3n/AHkmTQFCA0BIclKWL7sgaRh-bs4GU";
        }
        <login> {
          <class> {
            <permissions> "all";
          }
          <user> {
            <name> "engadmin";
            <uid> "969";
            <class> "superuser";
              <authentication> {
                <encrypted-password>"$1$dfdfsd.k4oivn-hjet9.";
              }
            }
          }
          <services> {
            <ssh>;
            <xnm-ssl>;
          }
          <syslog> {
            <user> {
              <name> "*";
                <contents> {
                  <name> "any";
                  <emergency>;
                }
              }
              <host> {
                <name> "10.0.0.3";
                <contents> {
                   <name> "any";
                   <notice>;
                }
                <contents> {
                  <name> "interactive-commands";
                    <any>;
                   }
                 }
               <archive> {
                 <world-readable>;
            }
          }
        }
          <ntp> {
            <boot-server> "example.com";
              <server> {
                <name> "example.com";
              }
            }
          }
          <snmp> {
            <location> "Engineering";
            <contact> "Orin Blomberg";
            <interface> "fxp0.0";
            <community> {
              <name> "anyone-read";
              <authorization> "read-only";
              <clients> {
                <name> "0.0.0.0/0";
                <restrict>;
              }
            }
          }
          <community> {
            <name> "shhh-quiet";
          <authorization> "read-write";
            <clients> {
              <name> "0.0.0.0/0";
              <restrict>;
            }
          }
        }
        <routing-options> {
          <static> {
             <junos:comment> "/* Engineering */";
             <route> {
               <name> "10.0.0.0/23";
               <next-hop> $bkup-rtr;
               <retain>;
               <no-readvertise>;
             }
           }
         }
      }
      <apply-groups> "re0";
      <apply-groups> "re1";
      <groups> {
         <name> "re0";
         <system> {
           <host-name> $hostname;
      }
      <interfaces> {
        <interface> {
          <name> "fxp0";
            <unit> {
              <name> "0";
                <family> {
                  <inet> {
                    <address> {
                        <name> $fxp0-addr;
                    }
                  }
                }
              }
            }
          }
        }
        <groups> {
          <name> "re1";
        }
        <interfaces> {
          <interface> {
            <name> "lo0";
              <unit> {
                <name> "0";
                  <family> {
                     <inet> {
                       <address> {
                          <name> $rid;
                   }
                 }
              }
           }
        }
      }
    }
  }
}
Using scripts such as this one, it is possible to guarantee that
        all network devices, or at least Juniper Networks devices, are
        configured consistently, thus making both deployment and
        troubleshooting progress more smoothly.




Interfaces



Although a baseline interface configuration works with JUNOS
          devices, not all networks are composed exclusively of Juniper
          Networks gear. When integrating devices into heterogeneous networks,
          it is necessary to ensure that default settings, such as
          encapsulation of interfaces, match, or that one of the systems is
          configured to use the other device's default. Using the following
          example script, it is possible to insert a Juniper Networks device
          into a network with Cisco devices and have the SONET/SDH interfaces default to the Cisco-HDLC, which
          is the default in Cisco devices:

<?xml version="1.0" standalone="yes"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:junos="http://xml.juniper.net/junos/*/junos"
xmlns:xnm="http://xml.juniper.net/xnm/1.1/xnm"
xmlns:jcs="http://xml.juniper.net/junos/commit-scripts/1.0">
<xsl:import href="../import/junos.xsl"/>
<xsl:template match="configuration">
<xsl:for-each select="interfaces/interface[starts-with(name, 'so-')
        and not(sonet-options/aggregate)]">
   <xsl:call-template name="jcs:emit-change">
     <xsl:with-param name="tag" select="'transient-change'"/>
       <xsl:with-param name="content">
          <encapsulation>cisco-hdlc</encapsulation>
       </xsl:with-param>
     </xsl:call-template>
   </xsl:for-each>
  </xsl:template>
</xsl:stylesheet>
Of course, to use the preceding script, it is necessary to
          understand the environment into which you are deploying the device
          and the environment's default settings—or the configuration changes
          made to devices to which the new device is connecting.





Routing engines



Having redundant REs in your network equipment provides a
          stable foundation for building high availability. However, the
          efficacy of the redundancy is lessened if the REs are not configured
          correctly or if any changes that are made are not applied to both
          REs. Here are two scripts for automating the process of ensuring
          that the REs are configured correctly.
This first script ensures that the IP addresses for the
          management interfaces are not configured directly on the interface
          itself, but instead are configured in the specialized re0 and re1 apply groups. If this is not the case,
          the commit script produces an error indicating the issue. By
          configuring the IP addresses in the apply groups, the REs can
          properly use the IP addresses.

<?xml version="1.0" standalone="yes"?>
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:junos="http://xml.juniper.net/junos/*/junos"
  xmlns:xnm="http://xml.juniper.net/xnm/1.1/xnm"
  xmlns:jcs="http://xml.juniper.net/junos/commit-scripts/1.0">
  <xsl:import href="../import/junos.xsl"/>
  <xsl:template match="configuration">
    <xsl:for-each select="system/host-name
          | interfaces/interface/unit/family/inet/address
          | interfaces/interface[name = 'fxp0']">
    <xsl:if test="not(@junos:group) or not(starts-with(@junos:group, 're'))">
       <xnm:warning>
         <xsl:call-template name="jcs:edit-path">
           <xsl:with-param name="dot" select=".."/>
         </xsl:call-template>
         <xsl:call-template name="jcs:statement"/>
         <message>
           <xsl:text>statement should not be in target</xsl:text>
           <xsl:text> configuration on dual RE system</xsl:text>
          </message>
        </xnm:warning>
      </xsl:if>
    </xsl:for-each>
  </xsl:template>
</xsl:stylesheet>
In the next example, the script checks to see whether a
          hostname has been configured, and if so, where. If no hostname is
          configured, an error is produced. If a hostname has been configured
          in the target group but not in the apply groups for the dual REs,
          the script moves the hostname to the proper location:

version 1.0;
ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";
import "../import/junos.xsl";
match configuration {
  for-each (system/host-name | interfaces/interface/unit/family/inet/address
                | interfaces/interface[name = 'fxp0']) {
    if (not(@junos:group) or not(starts-with(@junos:group, 're'))) {
      <xnm:warning> {
        call jcs:edit-path($dot = ..);
        call jcs:statement();
         <message> {
           expr "statement should not be in target";
           expr " configuration on dual RE system";
         }
       }
     }
   }
}
Using variations of the preceding scripts, you can deploy new
          devices in the network without disrupting other equipment and
          services. The key to all the scripts is the same: consistency across
          the configurations in the network. When deploying new services, the
          same focus on consistency applies.






Service deployment



One of the biggest threats to high availability when deploying a
        new service is a disruption to other services in the network. New
        services that require high bandwidth, low latency, and jitter may not
        perform well and may affect other services if you do not apply a
        comprehensive CoS architecture.
Lack of consistency in configuration affects CoS and its use in
        the network far more than any of the other protocols or technologies
        because CoS works on a per-hop basis, and failure to configure CoS in
        any device network negates the effects of the overall CoS
        configuration. Thus, CoS configuration is another prime candidate for
        automated configuration.
The following example code illustrates use of automated
        configuration to ensure that a new forwarding class for CoS is added
        to all the interfaces of the device. In the code, the script adds the
        newly created "ef-q1" forwarding
        class:

version 1.0;
ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";
import "../import/junos.xsl";
match configuration {
  var $cos-all = class-of-service;
  for-each (interfaces/interface[contains(name, '/')]/unit[family/inet]) {
    var $ifname = ../name;
    var $unit = name;
    var $cos = $cos-all/interfaces[name = $ifname];
    if (not($cos/unit[name = $unit])) {
      call jcs:emit-change($dot = $cos-all) {
        with $message = {
          expr "Adding CoS forwarding class for ";
          expr $ifname _ '.' _ $unit;
        }
        with $content = {
          <interfaces> {
            <name> $ifname;
              <unit> {
                <name> $unit;
                <forwarding-class> "ef-q1";
              }
            }
          }
        }
      }
   }
}
By adding the forwarding class to the interfaces as well as
        updating the entire configuration, it is possible to ensure that the
        new deployments do not affect existing services.






Infrastructure



Once equipment is deployed, it should fall into an
      infrastructure configuration automation strategy. The main goal of
      developing infrastructure scripts for configuration automation focuses
      on the foundation of the network. The infrastructure scripts ensure that
      the baseline interface and routing configurations are consistent and
      stable, preventing tiny errors from turning into big problems.




Interfaces



One area where issues can arise in your network is in the legacy
        Time-Division Multiplexing (TDM) circuits, which are normally used to
        connect remote offices. Though many network cores are moving to
        Ethernet or SONET/SDH, there are still many T1- and E1-type lines that
        require proper clocking configuration to ensure that they work
        effectively. In the following code example, the script notifies the
        user if the interface clocking settings on T1s are not set to internal
        clocking:

<?xml version="1.0" standalone="yes"?>
<xsl:stylesheet version="1.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:junos="http://xml.juniper.net/junos/*/junos"
 xmlns:xnm="http://xml.juniper.net/xnm/1.1/xnm"
 xmlns:jcs="http://xml.juniper.net/junos/commit-scripts/1.0">
  <xsl:import href="./import/junos.xsl"/>
   <xsl:template match="configuration">
    <xsl:for-each select="interfaces/interface[starts-with(name, 't1-')]">
      <xsl:variable name="clock-source">
       <xsl:value-of select="clocking"/>
     </xsl:variable>
    <xsl:if test="not($clock-source = 'internal')">
    <!-- or xsl:if test="$clock-source != 'internal'" -->
    <xnm:error>
      <xsl:call-template name="jcs:edit-path"/>
       <xsl:call-template name="jcs:statement">
         <xsl:with-param name="dot" select="clocking"/>
       </xsl:call-template>
       <message>This T1 interface should have internal
        clocking.</message>
     </xnm:error>
   </xsl:if>
  </xsl:for-each>
 </xsl:template>
</xsl:stylesheet>
Though this script does not fully automate the configuration of
        the clocking on the T1, it does alert the user to a misconfigured
        clocking setting, thus allowing us to correct the error before the
        circuit is officially turned up.





Routing



Another major pitfall in infrastructure device configuration is human
        error in configuring routing protocols. With all devices relying on
        routing protocols to properly deliver packets, it is again necessary
        to ensure that the configurations are both consistent and
        accurate.
In the following example, the router is part of an MPLS cloud and some of its interfaces connect to
        customer premises equipment. Using a combination of macros and
        JUNOScript, it is possible to ensure that the IGP settings are correct.
The first code example provides the macros that have been
        applied to various interfaces to identify the IGP, the interface's
        class in the hierarchy, and the area, if the interface uses Open Shortest Path First (OSPF):

system {
  scripts {
    commit {
      file protocol.xsl;
    }
  }
}
interfaces {
  ge-1/0/3 {
    unit 0 {
      apply-macro igpconf {
        area 0.0.0.0;
        protocol ospf;
        class core;
      }
    }
  }
  ge-2/0/1 {
    unit 0 {
      apply-macro igpconf {
        area 10.0.0.1;
        protocol ospf;
        class area1;
      }
    }
  }
  fe-0/0/0 {
    unit 0 {
      apply-macro igpconf {
        igp isis;
        role customer;
      }
   }
}
The following commit script is parsed by the management
        daemon (mgd). If the
        interface is labeled as a customer interface, its information is
        placed into the protocol configuration for the Intermediate System to
        Intermediate System (IS-IS) routing protocol. If the interface uses OSPF, the
        mgd places the configuration
        information into the proper configuration hierarchy and identifies the
        area:

version 1.0;
ns junos = "http://xml.juniper.net/junos/*/junos";
ns xnm = "http://xml.juniper.net/xnm/1.1/xnm";
ns jcs = "http://xml.juniper.net/junos/commit-scripts/1.0";
import "../import/junos.xsl";
match configuration {
  for-each (interfaces/interface/unit/apply-macro[name = 'igpconf']) {
    var $class = data[name='class']/value;
    var $protocol = data[name='protocol']/value;
