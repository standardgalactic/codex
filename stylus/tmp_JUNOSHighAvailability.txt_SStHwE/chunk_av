[edit]
lab@r3# show routing-options
static {
    route 0.0.0.0/0 next-hop 192.168.1.17;
}

[edit]
lab@r3# show policy-options policy-statement STATIC
term 1 {
    from {
        protocol static;
        route-filter 0.0.0.0/0 exact;
    }
    then accept;
}
The corresponding configuration on r4 advertises the static route so that the
      rest of the world can reach addresses in the small enterprise. In this
      case, the static address is redistributed to all Internal BGP (IBGP) peers:

[edit]
lab@r4# show routing-options
static {
    route 10.0.0.0/22 next-hop 192.168.18.1;
}

[edit]
lab@r4# show policy-options policy-statement STATIC
term 1 {
    from {
        protocol static;
        route-filter 10.0.0.0/22 exact;
    }
    then accept;
}

[edit]
lab@r4# show protocols bgp group IBGP export
STATIC;
This combination of configuration elements shows one simple way a
      small enterprise can communicate with the rest of the world and allow
      the world to initiate conversation back by adding a single default route
      to the local table and a static route on the provider's side. From the perspective of
      the small enterprise local table, the only interdomain content is the static default
      route.





Large Enterprises and Service Providers



If you have many internal hosts and connections to external networks, simple static defaults
      are less practical for large enterprise and service provider networks.
      Clearly, the local routing tables of these network types need more
      information to effectively direct traffic to its destination. And as
      more information is added to the table, more mechanisms are needed to
      control the table's size, content, and stability.
As everyone learns in Networking 101, large enterprises and
      service provider networks are separated into administrative domains
      defined as ASs. An AS is a collection of devices under the control of
      a common administration. Because BGP is a common way in which ASs
      communicate with each other, BGP is also the most sensible place to
      configure mechanisms to control the routes carried among ASs. Mechanisms
      to control what gets into the local routing table from BGP include AS
      numbering schemes, policies for route redistribution, and BGP protocol
      options.





AS Number



As we discussed in Chapter 12, the ability to
      provision multiple logical networks or service overlays over a single
      physical infrastructure means that architecture and design decisions are
      no longer a one-time event in the life of a network. Just as intelligent
      and scalable IP addressing schemes are needed for each logical overlay,
      you must also define the BGP specifics of the logical network.
Based on the AS's size and function in the greater Internet, the
      AS may be numbered. BGP is typically the deciding factor. Each router
      that participates in BGP routing must belong to an AS. The AS number
      identifies the logical location of the router, and subsequently the
      routes that the router advertises in the Internet. Each route that the
      router advertises using BGP carries with it an AS number.
AS numbers come in two flavors, public and
      private. Public AS numbers are just like public IP
      addresses. They are purchased from one of several allocation bodies,
      such as the Asia Pacific Network Information Center (APNIC),
      ARIN, and RIPE, and are recognized throughout the Internet. In use,
      private AS numbers are comparable to the RFC 1918-defined private IP addresses. According to APNIC, private AS
      numbers are used for BGP communications when "an AS is only required to
      communicate via BGP with a single provider. As the routing policy
      between the AS and the provider will not be visible in the Internet, a
      Private AS Number can be used for this purpose" (APNIC 2007). All AS
      numbers from 64,512 to 65,535 are in the private AS range.
In the case of small and medium-size enterprise networks, the
      decision to go with a private or public AS number may belong to the
      carrier rather than to the enterprise itself. This is because public AS
      numbers are expensive and may not be necessary. For example, an ISP may
      support virtual private network (VPN) connectivity among dozens of
      medium-size enterprise sites. These sites may use BGP to pass routing
      information to the ISP. Rather than pay for a public AS number for each
      site, the service provider could allocate numbers from the private range
      to support site-to-site communications and could use a single public AS
      number for communication outside the VPN.

Note
In response to growing demand for the finite number of possible
        AS numbers, in January 2007 APNIC began distributing 4-byte AS numbers
        along with the 2-byte numbers it had been distributing in the Pacific
        region. This expanded address space can support a little more than 4
        billion potential ASs.

In JUNOS, the AS number for the router is configured under the
      routing-options level of hierarchy:

[edit]
lab@r2# show routing-options
autonomous-system 22;














Border Gateway Protocol (BGP)



While a complete and thorough discussion of BGP theory is well beyond the
    scope of this chapter, a few functional details critical to high
    availability merit some discussion. Most importantly, when talking about
    routing, you have to talk about preventing routing loops, the archenemy of high
    availability. BGP uses two distinct loop prevention mechanisms: one
    prevents loops in External BGP (EBGP) connections, and the other in IBGP
    connections.

Note
For a more in-depth discussion of EBGP and IBGP connection types,
      take a look at Chapter 13
      in JUNOS
      Cookbook, by Aviva Garrett (O'Reilly).





EBGP Loop Prevention



EBGP loop prevention, as a concept, is very easy to understand.
      Figure 13-2 shows an EBGP-speaking
      router, r1, receiving a route update
      from an EBGP neighbor, r2. r1
      checks the AS path. If the update contains r1's AS number, in this case 1717, r1 drops the update. The presence of AS 1717
      in the advertisement indicates that the route either originated in AS
      1717, or has already been advertised through AS 1717 and is a
      loop.









Figure 13-2. EBGP loop prevention



Note
EBGP loop prevention is an inherent function of BGP and does not
        need to be enabled to prevent loops. It is "on" by default and does
        not require configuration in JUNOS or IOS.






IBGP Loop Prevention



IBGP loop prevention is a bit more complex and is based on three
      foundational rules:



A route received from an EBGP neighbor is forwarded to all
          IBGP and EBGP neighbors.


A route received from an IBGP neighbor is forwarded to all
          EBGP neighbors.


A route received from an IBGP neighbor is
          not forwarded to other IBGP neighbors.



These three foundational rules are necessary because the AS number
      does not change from hop to hop in IBGP advertisements. All IBGP hops
      are, by definition, within the same AS. Therefore, an additional
      mechanism is required to prevent loops; hence, the foundational
      rules.
Figure 13-3 shows IBGP route
      advertisement in all its resplendent glory. In this image, r3 receives a prefix advertisement of
      1.1.1.0/24 from r1. Router r3 follows the first foundational rule and
      forwards the route to all EBGP neighbors, in this case r2, as well as all IBGP neighbors, r4 and r5.
      Routers r4 and r5 each follow the second foundational rule
      and propagate the route to their external neighbors in AS 97 and AS 876. In keeping with the third foundational
      rule, r4 and r5 do not forward the route to each other,
      effectively preventing an AS-internal routing loop.









Figure 13-3. IBGP loop prevention



Note
You might be wondering why this is important for high
        availability. A solid understanding of EBGP and IBGP route
        advertisement rules is necessary when attempting to control the size,
        content, and stability of the local routing table. Without this
        understanding, you may waste time attempting to configure unnecessary
        route filters or, worse, troubleshooting a problem that does not
        exist.





IBGP full-mesh requirements



If you take a closer look at the IBGP route advertisement rules and at Figure 13-3, something may become apparent.
        IBGP's refusal to advertise IBGP-learned routes to IBGP neighbors
        mandates a full mesh of neighbor relationships
        among IBGP speakers. Any full mesh is subject to what is commonly
        known as the N-squared issue, a reference to
        the mathematical equation necessary to calculate the number of links
        required to connect all points in a given grouping to every other
        point in the grouping. The formal equation is:


N (N - 1)/2 =
          links


where N is the number of host systems in
        the group, and links is the number of connections
        required to establish a full mesh among the hosts. As a practical
        example, let's take a look at the number of links required for a
        network with 20 BGP speakers:


20 (20 - 1)/2 = 190


Clearly, as the BGP implementation grows, the effort required to
        support the implementation also grows at an alarming rate. If we were
        to add two BGP speakers to the 20-router topology, we would need to
        configure 41 additional BGP neighbor relationships to support the full
        mesh:


22 (22 - 1)/2 = 231







Implications of full mesh for high availability



As network complexity increases, the difficulty in supporting
        the network also increases. And while an IBGP neighbor relationship is
        simple to configure and fairly straightforward to support, configuring
        and supporting 231 (or even 190) relationships tends to place a burden
        on the finite resources of the support team. This much configuration
        spread out across the network not only increases the likelihood of
        human error, but also ensures that the risk touches many devices.
        Clearly, if high availability is desirable, an IBGP full mesh is
        not.





Alternatives to full mesh



Now that we have addressed the administrative complexity of IBGP in a
        full-mesh configuration, the sensible question to ask is, "Can BGP be
        implemented without configuring a full mesh of IBGP speakers?" Sure!
        There are two commonly used ways to get around the full mesh: route reflection and
        confederation.

Note
The next two sections in this chapter cover route reflection
          and confederation. By themselves, neither can reduce the number of
          routes in the local table. So, why discuss them? To support high
          availability, deterministic routing is critical. Therefore,
          controlling the way route advertisements get into the local table is
          just as important as controlling the contents of the route
          advertisements themselves. It's all about control.







Route Reflection



Route reflection is a mechanism that allows IBGP speakers to bend the third
      foundational rule of IBGP loop prevention. In effect, route reflection
      allows a route received from an IBGP speaker to be advertised to other
      IBGP speakers. An additional tag, CLUSTER_ID, is added to reflected routes to
      support loop prevention. Without digging too deeply into protocol theory
      concepts covered in other books, let's take a look at the components of
      a route reflector scheme that have an impact on high
      availability.




Route reflection basics



Route reflection makes use of a route reflector entity and
        a cluster entity. A route reflector is an IBGP
        router configured to act as a route server. A cluster is a collection
        of IBGP routers acting as clients to the route server. Routes learned
        by a cluster client are sent to the route reflector for the cluster,
        where they are then advertised to all other clients in the cluster, as
        well as to other route reflectors.





High availability design considerations for route
        reflection



There are some design issues to take into consideration when
        employing route reflection:



Because failure of a route reflector would result in the
            cluster being isolated from the rest of the BGP implementation,
            you should always configure clusters with redundant route
            reflectors.


Routers chosen to be reflectors should have consistently
            reliable power cooling and network connectivity and should be
            central to the network design.


Route reflectors within an AS should themselves be fully
            meshed. This permits each route reflector to receive all known BGP
            paths and ensures completeness of the local routing table.


The logical topology should follow the physical topology.
            Route reflection simplifies support of the network by reducing the
            number of required IBGP relationships. However, configuring a
            logical reflector topology that deviates from the physical
            topology adds so much complexity that it may be better not to
            deploy route reflection in the first place.








Turning it on



Figure 13-4
shows a small portion of a carrier network. Routers
        r1 and r2 serve as route reflectors for this
        network.
The IBGP configuration on r1
        has two BGP groups. Group IBGP
        maintains a full mesh among the route reflectors in AS 22—in this
        case, between r1 and r2:

[edit protocols bgp]
lab@r1# show
group IBGP {
    type internal;
    description "Full mesh for route reflectors";
    local-address 10.0.0.1;
    neighbor 10.0.0.2;
}









Figure 13-4. AS 22 with redundant route reflectors


A second BGP group, CLUSTER-1, on r1 configures a neighbor relationship with
        all other routers in the cluster—in this case, routers r3 through r6. These four routers are the neighbors for
        which r1 serves as a route
        reflector:

[edit protocols bgp]
lab@r1# show
group IBGP {
    type internal;
    description "Full mesh for route reflectors";
    local-address 10.0.0.1;
    neighbor 10.0.0.2;
}
group CLUSTER-1 {
    type internal;
    description "Cluster 1.1.1.1 clients";
    local-address 10.0.0.1;
    cluster 1.1.1.1;
    neighbor 10.0.0.3;
    neighbor 10.0.0.4;
    neighbor 10.0.0.5;
    neighbor 10.0.0.6;
}
The BGP group configuration for r2 is comparable in many ways to r1. Again, CLUSTER-1 defines the neighbors for
        which r2 serves as a route
        reflector:

[edit protocols bgp]
lab@r2# show
group IBGP {
    type internal;
    description "Full mesh of route reflectors";
    local-address 10.0.0.2;
    neighbor 10.0.0.1;
}
group CLUSTER-1 {
    type internal;
    description "Cluster 1.1.1.1 clients";
    local-address 10.0.0.2;
    cluster 1.1.1.1;
    neighbor 10.0.0.3;
    neighbor 10.0.0.4;
    neighbor 10.0.0.5;
    neighbor 10.0.0.6;
}
The BGP configuration for r3
        through r6 identifies r1 and r2
        as neighbors. The presence of the cluster
        1.1.1.1 configuration element on r1 and r2
        means these two routers include a cluster identifier in routes they
        advertise to r3 through r6; effectively telling these routers that
        they, r3 through r6, are clients in a route reflector scheme.
        Router r3 and r4 configurations are shown as examples in
        the following code. The configurations on r5 and r6
        would be comparable:

[edit protocols bgp]
lab@r3# show
group CLUSTER-1 {
    type internal;
    description "Cluster 1.1.1.1 route reflectors";
    local-address 10.0.0.3;
    neighbor 10.0.0.1;
    neighbor 10.0.0.2;
}

[edit protocols bgp]
lab@r4# show
group CLUSTER-1 {
    type internal;
    description "CLUSTER-1 route reflectors";
    local-address 10.0.0.4;
    neighbor 10.0.0.1;
    neighbor 10.0.0.2;
}

Note
In the previous configuration examples, we selected group
          names that will be helpful when attempting to troubleshoot
          BGP-related routing issues. We also included description elements to
          provide additional information about the purpose of both groups.
          This is a good habit to get into; it can save valuable time when
          troubleshooting.






Route reflectors and policy configuration



About seven years ago, we heard a class instructor describe
        policy configuration on a router participating in a redundant
        hierarchical route reflector scheme. The instructor looked out over
        the class and told us in a very somber voice, "One day you will
        configure a policy on a route reflector and it will damage the
        network. It may even bring it down."
Fortunately, to this day we have not "brought down" any
        networks, but we have seen our fair share of botched policy
        configurations. The most destructive mistakes that occur when
        configuring policy on a route reflector tend to be when you use the
        next-hop self
        option.




Route reflection and next-hop self: What not to do



You commonly use a next hop self policy
to overwrite the protocol next hop on IBGP
          advertisements with the local address of the advertising router.
          This policy effectively overcomes what is known as the BGP next hop reachability issue.
          Figure 13-5 adds a few details about
          the AS external peers to our small carrier topology to illustrate
          the point.
In Figure 13-5, r3 maintains an EBGP peering relationship
          to r5. Router r3 also has an IBGP relationship with
          r1 and r2, the route reflectors in this topology.
          When r3 receives a route from
          r5, r3 advertises the route to
          its IBGP neighbors with the BGP next hop to r5, 172.16.5.2. Because no IGP is running
          across the EBGP boundary, r3 uses
          a next hop self policy named NHS
          to advertise itself as the next hop to reach routes learned from
          r5. The policy is configured in
          the export direction to IBGP peers for r3.








Figure 13-5. A small carrier topology


[edit]
lab@r3# show policy-options
policy-statement NHS {
    term 1 {
        from protocol bgp;
        then {
            next-hop self;
        }
    }
}

[edit]
lab@r3# show protocols bgp group CLUSTER-1
type internal;
description "Cluster 1.1.1.1 route reflectors";
local-address 10.0.0.3;
export NHS;
neighbor 10.0.0.1;
neighbor 10.0.0.2;
So far, so good; after committing this configuration change,
          routes from r5 are now reachable
          from r4.
Notice that r1 and r2 also maintain an EBGP relationship.
          They are both peers with r6 in AS
          1. They too would need to overcome the next hop reachability issue
          and may configure a next hop self policy to do so. Here is the
          configuration from r1; r2
          would be similar:

[edit]
lab@r1# show policy-options
policy-statement NHS {
    term 1 {
        from protocol bgp;
        then {
            next-hop self;
        }
    }
}

[edit]
lab@r1# show protocols bgp group CLUSTER-1
type internal;
description "Cluster 1.1.1.1 neighbors";
local-address 10.0.0.1;
cluster 1.1.1.1;
neighbor 10.0.0.3;
neighbor 10.0.0.4;
neighbor 10.0.0.5;
neighbor 10.0.0.6;

[edit]
lab@r1# show protocols bgp group IBGP
type internal;
description "Full mesh for route reflectors";
local-address 10.0.0.1;
neighbor 10.0.0.2;
After this change is committed, there is still no immediate
          problem, but the protocol next hop for all routes received from
          r5 is now being overridden by
          r3, then again by r1, and r2 (as a backup). In this simple topology,
          the repeated protocol next hop override does not pose a problem that
          affects traffic. Only when the network size increases is high
          availability threatened.
In Figure 13-6, two
          additional routers, r8 and
          r9, are added to support
          connectivity to an internal data center. Routers r8 and r9 are both configured as route reflector
          clients to r1 and
          r2.
Soon after the configuration of r8 is complete, traffic coming from
          r4 is no longer able to reach
          destinations inside AS 302. Now we have a problem.






What is wrong with this picture?



The problem in Figure 13-6 is that BGP next hops are out of sync with the physical topology of
        the network. In other words, the contents of the routing table do not
        correctly describe destination reachability. Here are the
        details:



Routes from AS 302 are advertised by r3 to r1 (the route reflector) using IBGP.
            Router r3 overrides the
            protocol next hop and sets it to the r3 loopback address before sending it to r1.


Router r1 receives the AS
            302 routes and installs them in the local table. Router r1 then exports the routes to all
            clients, including r8, with the
            r1 loopback address as the
            protocol next hop.


When r4 has traffic
            destined for AS 302, it is forwarded to r1.


In the r1 local table,
            the protocol next hop is r3's
            loopback address, so r1 does a
            recursive lookup and sees that r8 is the next hop to get to r3, and then forwards the traffic
            accordingly.


Router r8 receives the
            traffic destined for AS 302, but in r8's local table, r1 is the protocol next hop for AS 302.
            Router r8 then forwards the
            traffic back to r1, and a loop
            is formed.


Service-level agreements (SLAs) are violated. Availability
            suffers. Pain ensues.







Be terrific; be specific



When configuring policy on a route reflector, always designate the neighbor to
          which the policy should be applied. Simply defining the EBGP
          neighbor for the next hop self policy permits routes from clients to
          maintain the protocol next hop.









Figure 13-6. Routers r8 and r9 added to AS 22


For the scenario depicted in Figure 13-6, you can resolve the
          issue by adding neighbor 7.6.5.3 to the NHS policy on r1 and r2:

[edit]
lab@r1# show policy-options policy-statement NHS
term 1 {
    from {
        protocol bgp;
        neighbor 7.6.5.3;
    }
    then {
        next-hop self;
    }
}
Clearly, making the content of the routing table as accurate
          as possible is critical to the functioning of the network.

Note
While designating the BGP neighbor to which the policy
            should apply is critical to the functioning of a route reflector,
            it is in fact a great habit to get into for all BGP policy
            configurations because this specificity can limit the impact of
            configuration errors to a single BGP connection, the one neighbor
            explicitly described in the policy.








Confederation



Confederation is a "divide and conquer" approach to the management of
      interdomain routing. A confederation is an AS that has been
      divided into a collection of smaller ASs. This method dramatically
      decreases the number of IBGP connections required, but can increase the number of
      EBGP-like connections. In a confederation scheme, the public AS is
      retained and used for external peering, but the domain is divided into
      two or more private AS numbers, as shown in Figure 13-7. In this example, AS 22 is confederated, split into AS 64512 and 64513.
      Because of configuration elements on all routers in the AS, the
      confederation is invisible to the outside world.




Confederation syntax



In this confederation example, r5 maintains
        a classic IBGP relationship with r6, as shown in the group
        IBGP portion of the configuration. Router r5 also maintains a classic EBGP-type relationship with
        r3 and r4 in the group CBGP
        portion. The confederation 22 statement
        under routing-options
        creates the confederated BGP scheme. In effect, this configuration
        element tells the router three things:



Use AS 64512 when forming an EBGP relationship with a router
            in 64513.


Use AS 64513 when forming an EBGP relationship with a router
            in 64512.


Use AS 22 for all other EBGP relationships.












Figure 13-7. AS 22 with confederation



lab@r5# show routing-options
autonomous-system 64513;
confederation 22 members [ 64512 64513 ];

lab@r5# show protocols bgp
group IBGP {
    type internal;
    description "IBGP neighbor r6";
    local-address 10.0.0.5;
    neighbor 10.0.0.6;
}
group CBGP {
    type external;
    description "CBGP neighbors r3 and r4";
    peer-as 64512;
    neighbor 10.0.1.10;
    neighbor 10.0.1.14;
}
Comparable elements are on r3:

[edit]
lab@r3# show routing-options
autonomous-system 64512;
confederation 22 members [ 64512 64513 ];

[edit]
lab@r3# show protocols bgp
group IBGP {
    type internal;
    description "IBGP neighbors r1, r2, r4";
    local-address 10.0.0.3;
    neighbor 10.0.0.1;
    neighbor 10.0.0.2;
    neighbor 10.0.0.4;
}
group CBGP {
    type external;
    description "CBGP neighbor r5";
    peer-as 64513;
    neighbor 10.0.1.9;
}
For redundancy, you also configure comparable elements
        on r4:

[edit]
lab@r4# show routing-options
autonomous-system 64512;
confederation 22 members [ 64512 64513 ];

[edit]
lab@r4# show protocols bgp
group IBGP {
    type internal;
    description "IBGP neighbors r1, r2, r3";
    local-address 10.0.0.4;
    neighbor 10.0.0.1;
    neighbor 10.0.0.2;
    neighbor 10.0.0.3;
}
group CBGP {
    type external;
    description "CBGP neighbor r5";
    peer-as 64513;
    neighbor 10.0.1.13;
}





Implications of confederation for high availability



While confederation can be beneficial in reducing the number of IBGP peering
        relationships necessary for an AS to function, as well as for
        controlling routing advertisements within the AS, confederation is
        less common than route reflectors on modern networks. There are
        several reasons for this:



Policies configured at the edge of an AS are typically more
            complex than those configured within the AS, and confederation
            increases the number of "edge devices" (EBGP speakers), which
            usually increase the amount of policy configuration necessary for
            the AS to function.


BGP interaction with the designated IGP (OSPF or
            Intermediate System to Intermediate System [IS-IS]) is more
            complicated with confederation because AS boundaries no longer follow IGP
            boundaries.


Configuration for redundancy requires additional
            confederated EBGP relationships and modifications to default BGP
            behavior, which can work against the primary reasons for deploying
            confederations, reducing support demands and increasing availability.








Configuration for redundancy



As a warning, based on what the authors have experienced in many years of
        supporting production networks, redundant confederation
        implementations can be extremely complex to troubleshoot and thus
        might not be the best choice of scaling mechanisms for a network with
        high availability requirements. Confederation is mentioned in this
        chapter primarily because it can have an impact on the stability of
        the local routing table.
Engineers who deploy confederations often change the default
        Time to Live (TTL) expiration on EBGP advertisements
        (the default is one hop). This change allows the confederation
        neighbors to find each other using alternate routes through the
        network.
You override the default hop limit under the individual neighbor
        configuration statements; to be effective you should make the change
        on both neighbors in a peering relationship. In this configuration
        example, r5 and r3 agree to use loopback addresses for their
        peering relationship and to change the TTL limit to allow up to three router
        hops to get to each other:

[edit]
lab@r5# show protocols bgp group CBGP
type external;
description "CBGP neighbors r3 and r4 with peering to loopbacks";
local-address 10.0.0.5;
peer-as 64512;
neighbor 10.0.0.3 {
    multihop {
        ttl 3;
    }
}
neighbor 10.0.0.4 {
    multihop {
        ttl 3;
    }
}
Router r3 has complementary
        configuration elements:

lab@r3# show protocols bgp group CBGP
type external;
description "CBGP neighbor r5 with peering to loopback";
local-address 10.0.0.3;
peer-as 64513;
neighbor 10.0.0.5 {
    multihop {
        ttl 3;
    }
}
There are also similar elements on r4:

[edit]
lab@r4# show protocols bgp group CBGP
type external;
description "CBGP neighbor r5 with peering to loopback";
local-address 10.0.0.4;
peer-as 64513;
neighbor 10.0.0.5 {
    multihop {
        ttl 3;
    }
}
The astute reader should notice that in the last set of
