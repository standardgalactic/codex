[edit event-options]
+   policy test {
+       events ui_commit;
+       then {
+           execute-commands {
+               commands {
+                   "set system scripts commit refresh";
+               }
+           }
+       }
+   }
The preceding example compares the previously saved baseline
        configuration to the current configuration on the network device. In
        the output, additions to the current configuration are marked with a
        plus sign and any deletions are marked with a minus sign.






Automating Configuration Audits



Although it is useful to manually audit configurations on the system, automated configuration
      auditing is recommended to provide the best posture for high
      availability. While many software companies have grown up around the
      process of configuration auditing, JUNOS itself provides many ways to
      audit configurations, and other Juniper Networks software, such as
      JUNOScope, makes automated auditing simple.




Event policies



One of the simplest ways to automate configuration auditing is to use event
        policies to create a file of all the configuration changes every time
        the configuration is committed. You can do this either with an event
        script or with a simple event policy. The following code archives the
        changes between the current configuration and the original baseline
        configuration, then uses FTP to send the changes to the engineers for
        more auditing or for archiving:

event-options {
    generate-event {
        DAILY time-of-day "01:00:00 âˆ’0800";
    }
    policy DAILY {
        events DAILY;
        then {
            execute-commands {
                commands {
                    "show configuration | compare baseline";
                }
                output-filename DAILY;
                destination engineering;
                output-format text;
            }
        }
    }
    destinations {
        engineering {
            archive-sites {
                "ftp://user@engineering.example.com/"
                  password "$9$w3saUq.5F6AfT"; ## SECRET-DATA
            }
        }
    }
}
You could write another event policy to fire off the same types
        of commands every time the configuration is committed. If your network
        engineers are familiar with Perl or other scripting languages, they
        could easily develop a set of scripts, templates, and configurations
        that examine the output of event policy and event scripts and then
        conduct almost all of the basic auditing of the configurations on the
        network equipment itself.





JUNOScope



For larger enterprises or ISPs, JUNOScope provides a single location for network
        engineers to collect, archive, and audit configurations. The JUNOScope
        software not only audits configurations against rollback or baseline
        configurations, but also allows you to compare configurations on
        multiple devices, ensuring that the configurations in place for
        network high availability are consistent across the network. Figure 21-3 illustrates the Audit
        Configurations web page of JUNOScope. Use this page to select the
        devices on which to compare configurations.









Figure 21-3. JUNOScope audit configuration


Like J-Web and the CLI, JUNOScope offers a feature to visually
        compare changes within the current configuration and other saved
        configurations. JUNOScope displays both the highlighting colors of
        J-Web and the plus and minus symbols of the CLI.
Unlike other methods of audit configuration that deal with
        single network devices, JUNOScope provides scalability to the configuration audit process. Its CVS
        provides an even greater ability to ensure that network device
        configurations are consistent. The CVS's check-out, modify, check-in,
        and deploy processes greatly reduce the introduction of errors into
        the configuration, thus allowing for a more continuous system.
The JUNOScope software goes even further in simplifying the
        auditing of configurations by allowing you to audit individual
        portions of the configuration and audit equipment licensing with its Inventory Management System.





Advanced Insight Solution



The Advanced Insight Solutions (AIS) and Advanced Insight Manager (AIM) add another level of
        defense against misconfiguration. AIM connects to the Juniper support
        infrastructure, allowing network engineers to use audits of network
        device configurations to diagnose possible issues that have occurred
        in the network, as well as gain intelligence into network operations
        to determine where the configurations and their baselines can be
        changed.















Performing and Updating Audits



A single configuration audit run when a service is deployed is good,
    but does not necessarily add to your network high availability. As changes
    are made to the network, you must go back and ensure that those changes
    have not had unexpected consequences. Also, as technology advances, you
    need to update configurations and, in turn, update the configuration
    templates and audits that are used to build the network. Just as with the
    initial planning for configuration templates and audits, it is better to
    divide the tasks into functional areas. You must also determine how often
    each functional area needs to be updated and the processes by which ad hoc
    changes are to be made.




Auditing Intervals



Setting up auditing intervals makes the difference between being
      overloaded by an avalanche of information and not having the information
      necessary to make all the proper decisions. In planning the interval for
      configuration audits, take into account internal organization
      requirements as well as laws and regulations under which the company may
      fall, such as Sarbanes-Oxley. For functional areas with glacial or
      static changes, such as interface physical attributes, an audit every
      six months may suffice, but for areas where technology and threats
      change rapidly, it may be necessary to conduct an audit every week, or
      even more often. Table 21-3 is an
      example of an audit schedule for configurations.


Table 21-3. Auditing intervals










Configuration
              module


Audit
              interval


Comments






Chassis


Quarterly

 



Firewall filter


Biweekly


Pay special attention to
              newly allocated IP address ranges




Interfaces


Quarterly

 



Routing policies


Biweekly


Pay special attention to
              newly allocated IP address ranges




Protocols


Biweekly


Pay special attention to
              external BGP peering




Security


Biweekly

 



Systems


Quarterly

 










Analyzing Updates



The first step in determining how to implement configuration templates and
      their corresponding configuration auditing changes in the system is to
      analyze how the changes will affect the network. Some changes to the
      configuration template, such as the rollout of a new service, must be
      vetted by all groups to ensure that the new service functions properly
      and does not degrade existing services or network security. Other
      changes, such as a modification to routing policy for newly allocated IP
      addresses, generally require only a quick review from those in charge of
      the peering routers. Table 21-4 is an
      example planning form for configuration template and audit
      changes.


Table 21-4. Ad hoc change analysis










Update


Impacted
              areas


Update
              reason






Routing policy update for
              new IP address


Peering
              connections


Change in networking
              environment



 

Routing

 


 

Bogon
              filtering

 



Introduction of VoIP into
              customer node


CoS
              mapping


Rollout of new
              service



 

Peering connection at
              customer

 



Worm attacking
              servers


Firewall
              filters


Issue in network
              environment






Once you have determined which areas of the configuration template
      need to be changed, you can develop the changes and decide on the time
      frame in which to implement them.





Auditing Changes



After the changes to configurations or configuration templates are approved,
      the resulting changes in the network should immediately be audited to
      ensure that both the configurations and the new auditing templates are
      working correctly.














Chapter 22. Securing Your Network Equipment Against Security Breaches



Much of this book revolves around concepts of high availability from a
  networking perspective. But it's equally important to remember that
  maintaining uptime includes considerations for the device itself. As this
  chapter discusses, securing the device to prevent it from being attacked or
  hacked is as important as any other effort put toward constant uptime.
  Without a strong security implementation on the device itself, all of your
  other efforts may go to waste.













Authentication Methods



One of the most fundamental ways to secure your device is to require
    users to log in with a username and password. Each user who accesses the
    device should have his own user account, and there are three ways you can
    authenticate that user on a device running JUNOS Software: local password
    on the device, Remote Authentication Dial-in User Service (RADIUS), and
    Terminal Access Control Access-Control System Plus (TACACS+).




Local Password Authentication



Local password authentication is very straightforward, involving the
      creation of a username and password on the device itself. You can create
      multiple user accounts for different users, and employ user classes to
      define a variety of access permissions for users accessing the
      device.
A typical local user account looks something like this:

[edit]
lab@r1# show system login user testuser
class super-user;
authentication {
    encrypted-password "$1$/Nbl7qhu$2dNqBVVauFN..ynv4xa3L0"; ## SECRET-DATA
}

Note
It is always a good practice to use a strong password. We cover
        password strength in the next section of this chapter.






RADIUS and TACACS+ Authentication



Devices running JUNOS Software can be RADIUS and/or TACACS+ clients. RADIUS and
      TACACS+ servers support a full range of authentication and authorization
      capabilities, and these capabilities can be fully leveraged by JUNOS
      devices. When using a RADIUS or TACACS+ server for authentication, a
      JUNOS device immediately sends the user's credentials
      (username/password) to the authentication server to authenticate the
      user. If successful, the user receives an authorization (permissions)
      from the server as well.
The following are examples of a device configured to use RADIUS or
      TACACS+ servers:

[edit]
lab@r1# show system
<removed for brevity>
radius-server {
    10.10.10.10 secret "$9$RZ1EyKMWx-dsKvoJDjq."; ## SECRET-DATA
    10.10.10.11 secret "$9$7zNb24oGji.2gTz6/tp"; ## SECRET-DATA
}

[edit]
lab@r1# show system
<removed for brevity>
tacplus-server {
    20.20.20.20 secret "$9$KauvLNdVY4oGN-Hqf5F3"; ## SECRET-DATA
    20.20.20.21 secret "$9$aIJDk.mTF39kquOREyr"; ## SECRET-DATA
}





Authentication Order



You can define which methods will be used for login attempts to the device, as
      well as the order of the authentication methods that will be
      performed:

[edit]
lab@r1# set system authentication-order ?
Possible completions:
  [                    Open a set of values
  password             Traditional password authentication
  radius               Remote Authentication Dial-In User Service
  tacplus              TACACS+ authentication services
Simply enter the parameters in the order you wish to have the
      login attempts performed.
When a user attempts to log in, the device directs the login
      request to the first server specified in the authentication order list.
      If the login attempt fails due to an incorrect password or because the
      server is inaccessible, the device sends the login request to the next
      server in the authentication order (if there is one listed). If no
      remote servers are available, the device itself will check the password
      against its own local user account database.

Note
Devices running JUNOS Software always check the local user
        account database when external authentication servers fail to
        respondâ€”even when password is not
        explicitly specified in the authentication order.















Hardening the Device



A critical element of ensuring high availability for your JUNOS device involves
    protecting and hardening it from outside attacks. The following are issues
    to consider.




Use a Strong Password, and Encrypt It



It is amazing how many networking devices in production networks have weak
      passwords or, worse yet, still have default passwords in place! Ensuring
      that your devices use strong passwords is one of the simplest steps you
      can take to harden the device. Every company has its own standard for
      what constitutes a "strong" password, but a good guideline is to use at
      least eight characters, and a mix of upper- and lowercase letters,
      numbers, and symbols.

Note
JUNOS devices require that passwords be at least six characters
        long and contain at least one change of case or character class (i.e.,
        numbers or symbols).

There are a variety of ways to enter passwords for user accounts
      on JUNOS devices. The following example shows the password options for
      an account called testuser:

[edit system login]
lab@r1# set user testuser authentication ?
Possible completions:
+ apply-groups         Groups from which to inherit configuration data
+ apply-groups-except  Don't inherit configuration data from these groups
  encrypted-password   Encrypted password string
  load-key-file        File (URL) containing one or more ssh keys
  plain-text-password  Prompt for plain text password (autoencrypted)
> ssh-dsa              Secure shell (ssh) DSA public key string
> ssh-rsa              Secure shell (ssh) RSA public key string
As you can see, there are several methods to input a password for
      a user account, including importing encrypted passwords and SSH strings.
      But the typical method of entering the password is to simply type it in
      at the command-line interface (CLI). This is done using the plain-text-password
      option:

[edit system login]
lab@r1# set user testuser authentication plain-text-password
New password:
Retype new password:

[edit system login]
lab@r1#
When using this option, the password you enter never actually
      appears on the screen. You simply enter it twice and the system stores
      the password. But that's not all it does. As an added layer of security,
      devices running JUNOS Software never show the password as clear
      textâ€”ever. Notice in the following example that the "plain-text"
      password is now encrypted:

[edit system login]
lab@r1# show user testuser
class super-user;
authentication {
    encrypted-password "$1$O2qv4WXN$lvlz1Ei.rcxEabTwEcVjd."; ## SECRET-DATA
}
The device encrypts the password and displays it in the
      configuration as a hashed value.

Note
Because the configuration always shows the password as
        encrypted, it is easy to confuse the plain-text and encrypted password
        options when configuring a device running JUNOS Software. Use the
        plain-text-password option when you
        want to manually enter the password into the CLI; use the encrypted-password option when you want to
        use an existing hashed password and paste it into the CLI.






Disable Unused Access Methods



You can access a JUNOS device using a variety of methods, including SSH,
      Telnet, and HTTP. Each access method has its place, but it is a good
      practice to disable unused access methods. Consider the following
      configuration:

[edit system services]
lab@r1# show
ftp;
ssh;
telnet;
web-management {
    http;
}
This device can be accessed in several ways, not all of which are
      secure. If, for example, your company mandates using SSH rather than
      Telnet, you should remove Telnet as a service on the
      device.

Note
It is a best practice to use only SSH and HTTPS to manage your
        devices wherever possible. These protocols encrypt their packets and
        ensure that your username and password are not sent as clear text
        across the network.

In practice, you can deactivate a service (similar to disabling
      it) or simply delete it from the device's configuration. Both achieve
      the same results.





Control Physical Access to the Device



Much effort is spent on securing networking devices from network attacks, but it
      is equally important to physically secure the device. All of your
      efforts to control access from the network can be wasted if someone can
      walk up to the device and connect her laptop directly to the console
      port! Ensure that the device is in a secure location, such as in a
      locked closet or a secure server room.
In cases where you are unable to secure a device running JUNOS
      Software, and the device has a craft interface in the form of a front
      panel with buttons, you can disable these controls, as shown
      here:

[edit]
lab@r1# set chassis ?
Possible completions:
> alarm                Global alarm settings
+ apply-groups         Groups from which to inherit configuration data
+ apply-groups-except  Don't inherit configuration data from these groups
> config-button        Config button behavior settings
  craft-lockout        Disable craft interface input
  disable-power-management  Disable Power Management in this chassis
> fpc                  Flexible PIC Concentrator parameters
  no-source-route      Don't enable IP source-route processing
> routing-engine       Routing Engine settings
  source-route         Enable IP source-route processing





Control Network Access to the Device



You can harden JUNOS devices by controlling how they are accessed over the
      network. For example, you can control SSH access to the device on a per-host basis:

[edit]
lab@r1# set security ssh-known-hosts ?
Possible completions:
+ apply-groups         Groups from which to inherit configuration data
+ apply-groups-except  Don't inherit configuration data from these groups
  fetch-from-server    Fetch the SSH public key interactively from this server
> host                 SSH known host entry
  load-key-file        File containing known hosts in OpenSSH native format
You can also limit the number of SSH connections to the device,
      and allow or deny SSH access using the root account:

[edit system services]
lab@r1# set ssh ?
Possible completions:
  <[Enter]>            Execute this command
+ apply-groups         Groups from which to inherit configuration data
+ apply-groups-except  Don't inherit configuration data from these groups
  connection-limit     Maximum number of allowed connections (1..250)
+ protocol-version     Specify ssh protocol versions supported
  rate-limit           Maximum number of connections per minute (1..250)
  root-login           Configure root access via ssh
If you are managing a JUNOS device using a web browser, you can
      define whether the connection can use HTTP or whether it must use
      HTTPS:

[edit]
lab@r1# set web-management http?
Possible completions:
> http                 Unencrypted HTTP connection settings
> https                Encrypted HTTPS connections
You can also control which interfaces will accept management
      connection requests, as well as which TCP port is to be used for web-based management of the
      device:

[edit]
lab@r1# set web-management http ?
Possible completions:
  <[Enter]>            Execute this command
+ apply-groups         Groups from which to inherit configuration data
+ apply-groups-except  Don't inherit configuration data from these groups
+ interface            Interfaces that accept HTTP access
  port                 TCP port for incoming HTTP connections (1..65535)
These last items are less critical elements of hardening your
      device, but every little bit helps.





Control and Authenticate Protocol Traffic



In any environment where your networking devices are in contact with devices
      belonging to other parties, or where you share a segment with other
      companies (such as at an IXP), be very careful that you run only
      relevant protocols, and that you run them only on appropriate
      interfaces. If you accidentally enable an internal routing protocol on
      an external-facing interface, the router may start to learn information
      from a neighboring deviceâ€”not a desirable situation! Be sure to control
      your routing protocols by using them only in desired places in your
      network.
Another common example where routing protocols can cause problems
      is when a "rogue" device is added
      to the network. Consider the following scenario: you configure Open
      Shortest Path First (OSPF) on your router, but instead of enabling the
      protocol on specific interfaces, you enable it globally, across all
      interfaces. One of the router interfaces connects to a local area
      network (LAN) segment that is used for testing and experimentation with
      new devices. If a user happens to configure a device and accidentally
      enables OSPF on that device, information will be passed between
      that device and the router connecting the LAN segment to the rest of the
      network. Furthermore, this new routing information will likely be passed
      from router to router through the entire networkâ€”not good. Fortunately,
      there is an easy solution to this situation: authentication. By simply
      adding authentication to your device's routing protocols, you eliminate
      the possibility of this scenario occurring. Should a new device
      accidentally send out protocol messages, the messages will be dropped
      because they do not pass the authentication check.
It is quite easy to implement protocol authentication, as shown in
      this example using OSPF:

[edit]
lab@r1# show protocols ospf
area 0.0.0.0 {
   interface ge-0/0/2.0 {
      authentication {
         simple-password "$9$/aZp9pBIRSleWB17-ws4o"; ## SECRET-DATA
      }
   }
}





Define Access Policies



A key element of hardening your networking devices and your network in
      general is determining what traffic to allow and deny. This can be a
      very involved process, as you must be certain to allow relevant traffic
      while protecting the network against attacks. A good example of how this
      can get very tricky is ICMP traffic. It would be easy to deny ping traffic in the
      name of security; however, the ability to ping a remote host is a key
      troubleshooting tool. Blocking ICMP traffic can, in some cases, cause
      more harm than good.
ICMP traffic illustrates the point that defining access policies
      isn't necessarily a one-size-fits-all solution. Security policies aren't
      just about what you allow and deny. An equally important factor is
      where you apply them. You may determine that the
      ability to ping remote hosts is valuable within your own network;
      however, you may not want to allow inbound ICMP traffic from outside
      your network. The former is an element of network management, while the
      latter may well be an attack.
Other situations where access policies can be "location-specific"
      include RFC 1918 IP addressing, as well as your own public IP address
      space. Traffic within your network can be allowed to use this
      addressing. However, inbound traffic should not
      have a source address of your public address spaceâ€”this is clearly
      spoofed traffic. In this situation, the access policy must be
      implemented at the edge of your network, to stop spoofed traffic before
      it ever gets in.
There are countless examples to illustrate the importance of
      defining access policies. Ultimately, this is an exercise you must
      perform within your company, determining guidelines, policies, and best
      practices based on your own environment.
We cover implementing access policies in the following sections of
      this chapter.














Firewall Filters



A firewall is a fundamental component in securing any network.
    Devices running JUNOS Software can
    filter packets at line rate based on their contents, and perform an action
    on packets that match the filter.




Firewall Filter Syntax



JUNOS devices filter traffic based on straightforward if-then logic.
      That is, if an incoming packet
      matches a given filter parameter, then the device takes some action on
      that packet.
Here is a basic example of the syntax and structure of firewall
      filter configuration:

[edit]
lab@r1# show firewall
family inet {
    filter samplefilter {
        term A {
            from {
                source-address {
                    192.168.1.0/24;
                }
            }
            then accept;
        }
    }
}

Note
A firewall filter doesn't actually filter traffic until it is
        applied to an interface. We
        cover this later in this chapter.

Firewall filters are defined at the firewall family hierarchy
      level. You can define filters for IPv4, IPv6, or Multiprotocol Label Switching (MPLS), or they can be
      protocol-independent. Each filter must have its own name, and each
      filter has one or more terms. A filter
      can also refer to another filter. In the previous example, a
      filter called samplefilter has one term, called
      A.
The following sections explain the remaining components of
      firewall filters.




Match conditions



The from statement in a
        firewall filter specifies the conditions the packet must
        match for the related action to be taken. Match conditions can include
        any combination of source and destination addresses, protocol numbers,
        and ports, as well as specific bits in certain packet fields (such as
        TCP flags). In the previous example, the match condition is a source
        address of 192.168.1.0/24.





Actions



When a packet matches one of the conditions in a filter, a
        corresponding action is takenâ€”typically, accepting or denying
        the packet. Denying the packet can be done in two ways:
        discard and reject. When the
        router discards a packet, it simply drops the packet and takes no
        other action. When the router rejects a packet, it drops the packet
        and sends a message back to the source indicating that the traffic has
        been prohibited.
In addition to the standard accept and deny actions, you can use
        action modifiers to gather additional information about the traffic
        that matches a given filter. Action modifiers include logging,
        counting, and sampling. As an example of where this can be useful,
        imagine that you have a firewall filter in place to block incoming
        traffic from a given source address. It would likely be useful to not
        only drop the traffic, but also know how many packets are coming in
        from that host. In this case, an action of discard with an action modifier of
        count would be appropriate.
Firewall filters can also function as a way to "catch" traffic
        that is interesting to you and do something specific with it. For
        example, you can add actions that port mirror traffic, assign Quality
        of Service (QoS) parameters to packets, or redirect traffic to a given
        logical or virtual router.





Evaluating filters



A filter can contain one or more terms. To match a term, the packet must match all
        conditions of that term. For instance, using the earlier example,
        traffic from a host with a source address of 192.168.1.1 matches the
        condition. The following example is more complex:

[edit]
lab@r1# show firewall
family inet {
    filter samplefilter {
        term A {
            from {
