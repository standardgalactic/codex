
Chapter 3. Software High Availability



In many networks, there seems to be a very clear divide in
  administration levels between those who consider themselves server experts
  and those who consider themselves networking experts. The problem is that
  the actual pieces of our networking equipment are merely computers designed
  specifically to pass traffic as quickly as possible. Though a network
  engineer does not require the knowledge to recompile kernels in order to
  maintain high availability in his network, he should have at least a basic
  understanding of how the operating system software that is running on his
  network equipment is designed.
By understanding how JUNOS software is designed and operates on your
  equipment, you are able to more accurately plan and prepare for critical
  situations, such as network-wide
  software upgrades, when high availability needs to be maintained. These are
  the times when the software is placed under the greatest strain.
This chapter provides an overview of the software design decisions and
  the software architecture of JUNOS devices, for it is the JUNOS software
  that provides the stable software foundation for the control of resilient
  and redundant hardware.













Software Architecture



Just as with the Juniper hardware, as discussed in Chapter 2, the software operating on Juniper
    Networks routing equipment has been specifically designed for stability
    and resiliency. Starting from a known stable base, JUNOS software has been
    designed and coded to provide maximum stability. It also incorporates
    features to mitigate errors that might lead to reduced uptime.




Stable Foundations



Just as the routing engine (RE) of the Juniper Networks routers is
      built upon proven and standard technologies, it was consistent for
      Juniper Networks to build its JUNOS operating system on a stable and
      proven software product. Instead of reinventing code and building a
      proprietary operating system from scratch, Juniper adopted the Berkeley
      Software Distribution, better known as BSD, as its foundation. The choice of
      BSD as the operating systems of the Juniper network equipment was
      logical because of its long history of stability. It is a Unix version
      from the University of California, Berkeley, and based on the
      sixth-edition Unix code released by AT&T in 1975. The BSD world has
      also prided itself on the early adoption and stabilization of networking
      protocols for IP. Its stability in networking has allowed it to become
      ubiquitous in hosting and service providers, as well as in academic and
      research settings. The licensing and documentation of the BSD software
      also lends itself to companies wishing to build software on a strong,
      stable base.





Modular Design



Like most modern operating systems, BSD segregates virtual memory into kernel space and user
      space. The BSD kernel space is a monolithic structure that is
      strictly reserved for running the kernel, kernel extensions, and device
      drivers. The memory of the kernel space is never swapped to disk.
BSD user space is a memory segment in which the daemons running
      the user software reside. In the case of JUNOS software, processes such
      as routing protocols, system management, and the command-line interface (CLI) reside in user space. The
      memory within the user space is not monolithic, but is further divided
      into virtual segments occupied by individual daemons.




Daemons



In the Unix and BSD world, the background services providing
        functionality for the operating system are called daemons. Daemons are
        responsible for providing a conduit process in user space to interact with the kernel.
In JUNOS, each daemon has been designed to be as focused and
        self-sufficient as possible to eliminate interprocess communication
        (IPC) between the daemons. To provide additional protection
        for high availability in network equipment, each daemon in JUNOS software runs in its own portion
        of protected memory. Any interactions between the daemons within JUNOS
        are routed through system calls to the kernel.
The kernel, in turn, communicates directly to the microkernel on the system's Packet Forwarding Engine (PFE), which is running its own
        autonomous daemons. By preventing the user space daemons from directly
        interacting with the daemons in the microkernel, JUNOS software
        prevents errors and failures in an individual daemon from affecting
        other daemons or the packet flow through the system. Mitigating the
        effect of daemon failures on either packet flow or other daemons
        ensures that high availability is maintained, even in times of high
        resource usage by the individual daemons. Figure 3-1 illustrates the interaction between
        the daemons in JUNOS and the kernel.









Figure 3-1. JUNOS architecture


As you can see in Figure 3-1, the
        kernel interacts with the PFE microkernel and keeps communication
        between the daemons in the RE and the PFE to a minimum. Within the operating system
        itself, the daemons are also designed to prevent software issues from
        affecting other daemons, thus lessening the high availability of the
        system. To provide for the most efficient high availability in a
        network, it is also important to know how the daemons coordinate
        transactions and handle resources such that they do not affect the
        proper operation of the system. In modern programming, daemon
        interaction can be divided into one of two main states:



Loosely coupled daemons


The daemons coordinate transactions and system calls but do
              not share system resources, such as memory. If a single daemon
              is killed or restarted in this situation, it will not affect the
              resources of other daemons in the system.


Tightly coupled daemons


The daemons not only coordinate transactions and system calls,
              but also share resources in the system. Because of the shared
              resources, a failure in a single daemon could lead to failures
              in other daemons. These daemon failures could also result in a
              cascading error, in which the entire operating system is
              compromised.



The JUNOS software is built to use loosely coupled daemons for
        all the processes necessary to keep the networking equipment
        functioning normally. By having the daemons run independently and in
        protected memory, the system can maintain its high availability even
        when one or more daemons are in a period of high resource usage or
        failure.

Note
Although some network engineers never worry about how their
          daemons are coupled or how their operating system works, we have all
          had software installed that seems to steal resources from other
          software running on the machineâ€”locking up the computer and forcing
          a reboot. You don't want to see a mistake in a Simple Network
          Management Protocol (SNMP) process stealing resources from Border
          Gateway Protocol (BGP) and possibly crashing the router.
















One OS to Rule Them



Even with the most stable of software, it is sometimes necessary to upgrade to
    provide for new features or to fix a minor bug. In your network, this type
    of upgrade should be simple and should not impact your high availability,
    but it seems that in most networks, software upgrades are a Sisyphean task
    that diverts the attention of one or more network engineers from normal
    operations to the task of developing upgrade implementation and testing
    plans. When upgrading the operating system of your networking equipment,
    it is necessary to do the following:



Feature set


Determine which set of networking features is required in the
          deployed device, such as IPv6, Multiprotocol Label Switching
          (MPLS), or certain routing protocols.


Software versioning


Determine which version of networking software is required to provide
          the fixes and features necessary. Versioning information can
          include:



Chassis type


Major release number


Minor release number


Maintenance release number


Software train, including general deployment, early
              deployment, special release, or deferred release (none of which
              apply to JUNOS releases)





Hardware requirements


Determine whether the hardware onto which the software is to be
          loaded has the proper amount of memory and processing power, and the
          correct firmware and hardware versions.


Interoperability


Determine whether the software release supports all the
          hardware versions in the device onto which the software is to be
          loaded, and whether it is interoperable with the devices attached to
          the device being upgraded.


CLI retraining


Determine whether the new code is based on the same code as
          previous versions. With the number of mergers and acquisitions we
          are seeing in the networking world, it is possible to run across
          CLIs that work very differently even though they are from the same
          company.


Bug scrubs


Finally, after you decide on the upgraded software, review the list of known bugs in
          the software to determine whether any of the bugs directly affect
          features that you require. If the bugs for the desired features are
          considered "showstoppers," you must begin the process
          of choosing software again.



The complex nature of attempting to manually cross-reference known
    bugs, features, and hardware requirements for each separate code train for
    a piece of network equipment creates an inherent risk that the upgrade
    will not efficiently perform every function that is required in the
    network. With each upgrade, the high availability of the network is on the
    line as the upgrades may work differently on different pieces of equipment
    and major changes to the CLI may be introduced. In Juniper Networks
    equipment, the solution to this complexity is the use of a single
    operating system across multiple lines of hardware.




Single OS



One of the key features that enable JUNOS software to ensure high
      availability is the fact that all the major equipment rests on a single
      source code. This use of a single code across product lines and systems
      allows Juniper to mitigate many of the risks inherent in software
      upgrades and allows it to be able to deliver upgrade functionality on a
      stable release schedule.




Forks and trains



Those in the software development culture are quite familiar
        with the concept of forks and
        trains (or branches). In
        normal software development, a fork is useful for taking a piece of
        source code and mutating it into something entirely new. The issue in
        an operating system is that each branch that is forked from the
        mainline code must have its own set of developers to develop, test,
        and validate the code. With each branch forming a separate train and
        moving in its own direction, separate integration and regression
        testing must be done to ensure that all the branches of code are still
        backward compatible, communicate properly, and are free of bugs. Each
        code train makes the development of stable and interoperable software
        exponentially more difficult.
To avoid any effects caused by the forking of code and multiple
        code trains, JUNOS software has been consistently developed in a
        single software train with a single source code. This single train of
        software is run through batteries of regression and quality testing to
        ensure that new features do not break previous features and that no
        new errors are introduced into the code. With all development
        engineers focusing on the single code base, the testing of the code is
        much more effective and you are guaranteed a stable network operating
        system to support your networking equipment.
Because the single code train is used in almost all Juniper hardwareâ€”on the J, M, MX, EX, T, and SRX Seriesâ€”it is possible to
        upgrade large portions of your network without worrying about some of
        the equipment being required to remain on older code that may not have
        the necessary features.





No reeducation through labor



Working in a typical network with a multitude of different
        switches, routers, and firewalls, engineers must be able to quickly
        manipulate the nuances of configuration syntax for each piece of
        equipment, even if they are from the same company. With JUNOS software
        providing the same operating system across switching, routing, and
        security equipment, it is possible for an engineer to learn a single,
        standard syntax for configuring all network components.

Note
Though Juniper does have product lines with different CLIs
          because of acquisitions, the company is actively working to bring
          those systems into the JUNOS fold, as you can see with the SRX
          Series of security devices, which includes firewall and intrusion
          detection and prevention, all of which now run JUNOS
          software.

Within most networks having separate departments for security
        and overall routing, the use of the same CLI allows closer interaction between the two groups to
        ensure that network high availability is not optimized at the expense
        of security, or vice versa.






One Release Architecture



The modular nature of the JUNOS architecture not only provides
      stability to ensure high availability, but also allows the same OS to be
      used across all of the products in the M, T, EX, MX, J, and SRX Series equipment, with all core
      features supported in all series. As we mentioned before, when selecting
      software for upgrade with other vendors, it is necessary to ensure that
      all features, such as MPLS and Intermediate System to Intermediate System
      (IS-IS), are available in the specific release to be downloaded.
      With JUNOS software, though, the core functionality and CLI exist in the operating systems for all lines of
      equipment, including the J, EX, and SRX Series, which have their own
      code downloads. The ability to deploy functionality in a similar manner
      across all systems in the network allows the system architect to shift
      focus from interoperability to carefully designed high availability.














Automation of Operations



One of the major causes of network downtime is the introduction of simple mistakes in a
    configuration through typos or lack of configuration experience. Though
    there is no way to prevent all human error in your network, JUNOS software
    has features that attempt to mitigate the effects of these types of
    errors.




Configuration Management



A key strength of the software is the fact that configuration changes
      must be explicitly committed to the system and that they do not take
      effect without some form of basic validation, either through the
      automated configuration checks built into the commit function of the CLI or through network-specific
      commit scripts developed using the JUNOS application programming interfaces (APIs). The JUNOS
      operating system also stores previously used configurations, and either
      changes can be manually rolled back or the JUNOS software can be set to
      automatically roll back the changes if connectivity is lost.





Application Programming Interfaces



Although you have probably used SNMP in a network, it may not have provided
      the flexibility and information that were critical in protecting the
      high availability of your network. To provide high availability
      reporting and information, JUNOS supports standards such as SNMP, but it
      also provides APIs that allow client/server applications to be designed
      and built to read and write configuration and operating information from
      the Juniper Networks device using the Juniper Extensible Markup Language (XML) API.
The JUNOScript API is a Juniper-designed application that can
      be used to connect a client to a device running JUNOS to retrieve or
      change configuration information using XML. The JUNOScript API server
      runs natively in JUNOS software and clients can be written in either
      Perl or the C programming language to connect to it. The
      API is also used to connect Juniper written software, such as JUNOScope, to the network equipment and read and write
      information.
NETCONF Configuration Protocol is a client/server application that also runs natively
      within JUNOS. NETCONF, which was defined in the Internet Engineering
      Task Force (IETF) RFC 4741, can also be used to develop custom monitoring and
      management systems for Juniper equipment.
The ability to develop specifically tailored clients using the
      JUNOScript or NETCONF API allows network engineers to create meaningful
      data about their network and monitor situations and nodes that could
      affect the network's high availability.





Scripting



If you have worked in networks for any length of time, you have
      definitely seen a case where a minor user error crashed an individual
      node or even created cascading errors that brought down portions of the
      network. Though it is impossible to totally prevent humans from making
      mistakes when configuring equipment, it is possible to mitigate the
      effect of errors on the network through careful scripting and monitoring
      of network changes. To aid network managers in guaranteeing that their
      uptime is not affected by simple error, JUNOS contains a single
      Extensible Stylesheet Language Transformation (XSLT) processor to parse the XML files that contain the
      configuration and logging files. The use of the processor enables the
      creation of scripts for double-checking configurations and providing
      event notification. XSLT is the primary language used to parse the
      files. However, two languages exist for scripting:



Stylesheet Language Alternative Syntax (SLAX)


A scripting language developed by Juniper engineers to use with
            XML for developing scripts for network devices running JUNOS. The
            SLAX language is similar to Perl in its syntax and constructs;
            thus, those familiar with Perl can pick up SLAX rather quickly.
            When processing scripts written in SLAX, the scripts are first
            automatically converted to native XSLT for the processor.


XSLT


The standard scripting language used to parse the XML files.
            Unfortunately, many people find it more difficult to read and
            write.



Through the use of either SLAX or XSLT in the networking
      equipment, three types of scripts can be written and applied to the
      system. In Chapters 10 and 25, we cover in more detail the use of
      these scripts in high availability architectures.




Commit scripts



The most basic of all scripting in JUNOS software is the commit
        script, which parses configuration changes before they are
        committed to ensure that potential errors are caught before being
        applied. When errors are found in a configuration, the script can
        either alert the user of the error and fail the commit, or correct the
        configuration automatically. Going beyond configuration checking,
        commit scripts can be used to develop macros that use simple
        configuration variables to create a complete and more complex
        application.
Through the use of commit scripts, senior-level network
        engineers can develop macros and checks for a network to ensure that
        junior-level engineers do not introduce errors during maintenance
        windows and to prevent these possible errors from affecting the
        network's high availability.





Operation scripts



Operation scripts provide a way for your network engineers to create
        scripts that monitor the router during operations. The script can be
        developed to take very specific actions ranging from simple
        notification to automated diagnosis and correction of issues that have
        appeared, or it can be developed into a series of step-by-step
        diagnostic procedures that can aid junior technicians in
        troubleshooting, diagnosing, and fixing network issues.

Note
It may appear that we are picking on junior network engineers,
          but we have all been in situations where our experience and
          expertise don't really match the task that needs to get done. The
          use of commit and operation scripts extends the knowledge of
          upper-tier engineers to everyone struggling to get the job done, and
          prevents lack of experience from creating network downtime. It also
          protects senior engineers from tripping on their own typos.






Event policy scripts



Event policy scripts define policies for a specific action to be taken when a
        particular event notification is received from one of the JUNOS
        software modules. These scripts can be used in conjunction with
        operation scripts to act as an early warning system that not only
        detects emerging problems but also takes immediate steps to avoid
        network downtime. Using the event policy and operation scripts,
        remediation and troubleshooting tools can be developed in your network
        to pare the amount of time it takes to discover, diagnose, and fix a
        network outage.















Chapter 4. Control Plane High Availability



The explosion of technology and the world's dependence on it means
  that the reliability of a network is incredibly important. As the bits and
  bytes carried across networks become more valuable, the high availability of
  these networks is more relevant than ever. The revenue stream of a major
  financial customer who purchases managed virtual private network (VPN)
  services from a global ISP depends on the network's availability. When the
  chairman of the Federal Reserve finally delivers good news after weeks of
  market turmoil, news that sparks a buying frenzy, older peering routers at
  the provider's Point of Presence (POP) could get overloaded. This strain on
  the older devices could, in turn, ramp up the CPU, causing the routing
  protocols to fail, which in turn would delay market orders, causing the loss
  of millions of dollars.
At the same time, in another part of town, another customer of the ISP
  is experiencing issues. A hospital's ER department needs to access a
  patient's medical records to prescribe appropriate medication. Because of
  the nature of the medication, access to the patient's medical history is
  imperative. Time is ticking and, all of a sudden, the ER loses access to the
  central database. The local IT department reports that the core network
  router has crashed, and meanwhile the patient is suffering.
These two failure scenarios emphasize the importance of high
  availability features in next-generation networks and services to minimize
  the effect of such network failures. This chapter addresses
  system-based availability; specifically, high
  availability and redundancy of the routing engine (RE) and the routing
  protocols that run on the router or switch.













Under the Hood of the Routing Engine



To utilize the robust high availability toolkit provided in JUNOS,
    one must fully understand the software components of the RE and how they
    work together to build a highly available operating system. As we discussed in Chapter 3, JUNOS provides a clear separation
    between the forwarding and control planes. This separation creates an
    environment in which the router can still forward the traffic when its
    control plane is down. As long as the traffic is actually flowing through
    the router, users do not experience any network-related issues.
The RE is the brain that stores the building blocks of system
    availability, providing all the necessary tools for routing protocols and
    route calculations. The main function of the RE is to perform route management, using a vastly modified Unix Routing
    Protocol Daemon (RPD). Because route management is a complex function, the RPD
    divides its work into many tasks and runs its own scheduler to prioritize
    them, ensuring that each protocol and route calculation receives the
    appropriate resources to perform its job.
The primary goal of the RPD is to create and maintain the Routing Information Base
    (RIB), which is a database of routing entries. Each routing entry
    consists of a destination address and some form of next hop information.
    RPD maintains the routing table and properly distributes routes from the
    routing table into the kernel and the hardware complexes used for traffic
    forwarding.
While almost all network equipment vendors use the concept of a RIB
    for Border Gateway Protocol (BGP), JUNOS uses a RIB-based structure for all of its
    routing tables. To understand routing for high availability in your
    network, it is important to know the table names and to understand the
    role of each table. Table 4-1
    describes the JUNOS routing tables.


Table 4-1. Routing tables implemented in JUNOS









Routing table
            name


Description







bgp.isovpn.0



BGP reachability information for International
            Organization for Standardization (ISO) VPNs.





bgp.l2vpn.0



BGP Layer 2 VPN routes.





bgp.l3vpn.0



BGP Layer 3 VPN routes.





bgp.rtarget.0



BGP route target information.





inet.0



IP version 4 (IPv4)
            unicast routes.





inet.1



IP multicast routes. Contains an entry for each (S,G)
            pair in the network.





inet.2



IPv4 unicast routes. Used by IP multicast-enabled routing
            protocols to perform Reverse Path Forwarding (RPF).





inet.3



Accessed by BGP to use Multiprotocol Label Switching (MPLS) paths for
            forwarding traffic.





inet.4



Routes learned by Multicast Source Discovery Protocol
            (MSDP).





inet6.0



IP version 6 (IPv6) unicast routes.





inet6.3



Populated when the resolve-vpn statement is enabled to
            allow a router whose VPN control plane is undergoing a restart to continue to
            forward traffic while recovering its state from neighboring
            routers.





inetflow.0



BGP flow destination (firewall match criteria)
            information.





invpnflow.0



BGP flow destination (firewall match criteria) information
            within an RFC 2547 Layer 3 VPN.





iso.0



Intermediate System to Intermediate System (IS-IS) and End System
            to Intermediate System (ES-IS) routes.





l2circuit.0



Layer 2 circuit routes.





mpls.0



MPLS label-switched paths (LSPs). Contains a list of the next label-switched router
            in each LSP. Used by transit routers to forward packets to the
            next router along an LSP.






<instance-name>

.inet.0



Table that JUNOS software
            creates each time you configure an IPv4 unicast routing
            instance.






<instance-name>

.inet.3



Table that JUNOS software
            creates for each BGP instance that is configured to use MPLS paths
            for forwarding traffic.






<instance-name>

.inet6.0



Table that JUNOS software
            creates each time you configure an IPv6 unicast routing
            instance.






<instance-name>

.inetflow.0



Table that JUNOS software
            creates each time you configure a routing instance. This table
            stores dynamic filtering information for BGP.






<instance-name>

.iso.0



Table that JUNOS software
            creates each time you configure an IS-IS or ES-IS
            instance.






<instance-name>

.mpls.0



Table that JUNOS software
            creates each time you configure MPLS LSPs.






The RPD stores routes in these tables and moves routes among the
    tables as needed. For example, when the router receives routing
    information from a routing protocol in the form of newly advertised
    routes, such as a BGP update message, the routing update is stored in the
    table called RIB-IN. The RPD runs BGP
    import policies and the BGP best route selection algorithm on the received
    routes to create an ordered set of usable routes. The final results of the
    route selection process are stored in the routing main JUNOS
    RIB, inet.0. As BGP prepares
    to advertise BGP routes to its peers, the export policy is run against the
    routes and the results are moved into the outgoing table, RIB-OUT.
The RPD stores routes for BGP-based Layer 3 VPNs in the
    table bgp.l3vpn.0, which is
    populated by Multiprotocol BGP (MP-BGP). As JUNOS software runs the
    configured policies against the information in the table, all acceptable
    routes are sent to one or more routing-instance tables while any routing
    information that is unacceptable to the policies is marked as hidden.
    After the RPD route selection process is finalized, the RPD daemon copies
    the selected routes into the kernel's copy of the routing table using IPC
    messages. JUNOS does not rely on BSD's default routing socket for
    IPC; instead, it uses a specialized socket that allows any daemon within
    the box to communicate with the kernel. For example, the RPD uses routing
    sockets to signal the addition, deletion, or change of routes to the
    kernel. Similarly, the dcd daemon, responsible
    for interface management, also communicates with the kernel using the same
    routing socket type when it signals an interface addition, deletion, or
    change of its status. And again, the chassisd daemon updates
    the kernel with any new or changed hardware status using the same routing
    socket type.
The protocol used for this IPC is Trivial Network Protocol (TNP). TNP is a Layer 3 protocol (like an IP) and uses
    Ethernet II encapsulation. Like any Layer 3 protocol, it
    uses source and destination addresses, and it forms and maintains neighbor
    relationships using Hello messages. The TNP Hello message contains Hello timers and dead intervals,
    which are used to discover the failure of other hardware components (REs, Packet Forwarding Engines or PFEs, and Flexible PIC Concentrators
    or FPCs). While you cannot configure most of the TNP Hello
    timers, you can configure the Hello and dead time intervals between two
    REs through the command-line interface (CLI) keepalive command.

Note
Although the netstat commands
      do work in JUNOS, because JUNOS uses a raw socket type, the IPC is not
      visible with the plain Unix netstat-a
      command. Communication is formed using rtsock messages and can be viewed using the
      rtsockmon command.

Continuing our look at the RE's processes, the next step is that the
    kernel copies the RPD's forwarding table to the PFE. The table structure
    is modified so that it can be stored in the PFE's application-specific
    integrated circuits (ASICs), which make forwarding decisions. These
    decisions are based on proprietary Radix tree route lookups (called J-Tree
    route lookups) that are performed on each ASIC. As inet.0 and
    subsequent forwarding table routes are modified, the RE kernel
