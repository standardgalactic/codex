











Programming
for Beginners
6 books in 1







© Copyright 2017 by _____K.M. KASSI_______  All rights reserved.
The follow eBook is reproduced below with the goal of providing information that is as accurate and reliable as possible. Regardless, purchasing this eBook can be seen as consent to the fact that both the publisher and the author of this book are in no way experts on the topics discussed within and that any recommendations or suggestions that are made herein are for entertainment purposes only. Professionals should be consulted as needed prior to undertaking any of the action endorsed herein.
This declaration is deemed fair and valid by both the American Bar Association and the Committee of Publishers Association and is legally binding throughout the United States.
Furthermore, the transmission, duplication or reproduction of any of the following work including specific information will be considered an illegal act irrespective of if it is done electronically or in print. This extends to creating a secondary or tertiary copy of the work or a recorded copy and is only allowed with express written consent from the Publisher. All additional right reserved.
The information in the following pages is broadly considered to be a truthful and accurate account of facts and as such any inattention, use or misuse of the information in question by the reader will render any resulting actions solely under their purview. There are no scenarios in which the publisher or the original author of this work can be in any fashion deemed liable for any hardship or damages that may befall them after undertaking information described herein.
Additionally, the information in the following pages is intended only for informational purposes and should thus be thought of as universal. As befitting its nature, it is presented without assurance regarding its prolonged validity or interim quality. Trademarks that are mentioned are done without written consent and can in no way be considered an endorsement from the trademark holder. 







TABLE OF CONTENTS
PYTHON 
Python For Beginners
The Foolproof Guide to Learning Programming in Python
Introduction
Chapter 1 : Python - Why, and How?
Chapter 2 : Python Math, Values, and Variables
Values
Variables
Operators
Chapter 3 : Expressions and Conditionals
If statements
User Input
Chapter 4 : Data Sets
Lists
Dictionaries
Chapter 5 : Loops
While loops
For loops
Chapter 6 : Methods
Conclusion
Python Tips and Tricks
Learn the Best Tips and Tricks to Get The Most out of Python NOW!
Introduction
Chapter 1 : Fun with Lists
List comprehensions
Zip
Chapter 2 : Fun with Strings
String Fundamentals
String splicing
String Methods
Chapter 3 : Join a Community
Chapter 4 : Work on Open-Source Software
Chapter 5 : Program Out of Your Comfort Zone
Chapter 6 : Test Yourself with Daily Challenges
Conclusion
Python Strategies
Bold Strategies to Go From  a Newbie to a Pro
Introduction
Chapter 1 : Become a Hacker
Variables
Expressions
If statements
Conditional operators
Lists
Loops
Methods
Chapter 2 : Figure Out What You Like
Chapter 3 : Join Up with Communities
Chapter 4 : Learn Another Language  (Seriously!)
Conclusion
SQL 
SQL Beginner's Guide
The Ultimate Beginner's Guide to learn SQL Programming effectively
Introduction
Chapter One : SQL- What is it and  Why You Should Learn it
Chapter Two : The Basics That You  Need to Know of SQL
Chapter Three : Your First Table!
Chapter Four : The Commands That Make Up the Foundation for Your SQL Learning
Chapter Five : Math That You Can Do in SQL
Chapter Six : SQL Transactions
Chapter Seven : Sub Queries That  Are Done Inside of SQL
Chapter Eight : Four Tips That  Make Using SQL Easier!
Conclusion
SQL Tips and Tricks
Tips and Tricks to Learn SQL Programming Quickly and Efficiently
Introduction.
Chapter One : Comma-Delimited Output
Chapter Two : Figuring Out the Missing Values That are Used for Identity
Chapter Three : Random Numbers Being Generated
Chapter Four : Generating Random Records
Chapter Five : Sorting Through IP Addresses
Chapter Six : Name Splitting
Chapter Seven : Searching Excel Spreadsheets with SQL
Chapter Eight : Executing SQL Scripts in Batches
Chapter Nine : Date Formats with the Server in SQL
Chapter Ten : Set vs Select and How They Work When Assigning Variables
Chapter Eleven : The Len String Function in SQL
Chapter Twelve : Keyboard Shortcuts for SQL
Chapter Thirteen : Moving Files in the SQL Data Base
Chapter Fourteen : Generate data with the Recursive in SQL
Chapter Fifteen : Commands You Need to Remember when Using SQL
Conclusion
SQL Beginner's Guide
Simple and Effective Strategies to Learn SQL Programming
Introduction
Chapter One : Versioned Data
Data and the data base
Chapter Two : Archiving Your Data onto  the SQL Server
Chapter Three : Security on the SQL Server
Chapter Four : Azure SQL Data Bases
Chapter Five : Compressing Data Inside of SQL
Chapter Six : Population Stability Index (PSI) Inside of the SQL Data Base
Chapter Seven : Hyper Threading-  How it Works and When You Should Use it
Chapter Eight : T-SQL Analytic Functions
Chapter Nine : Do Not Copy, Clone It!
Chapter Ten : Sequencing with SQL
Auto_increment
Chapter Eleven : Your Data Base- How to Tune it
Chapter Twelve : Duplications Happen but,  How to Fix Them
Chapter Thirteen : Constraints are Everywhere!
Conclusion







PYTHON
DANIEL JONES








Python For Beginners

The Foolproof Guide to Learning Programming in Python








Introduction
The following chapters will discuss everything you need to get up and go with Python. There are quite a few reasons you may have chosen to learn Python, but whatever it may be, I have one goal and one goal alone in writing this book: helping you to understand everything that you need to understand in the context of Python so that I can get you up to speed with Python programming.
We'll be learning everything from the most simple concepts and launching the most basic of programs to more difficult concepts that make up the world of programming such as control flow and the idea of methods which can be very intimidating at first. But don't worry for a second, it can be very hard and difficult to tackle, but you're not doing it on your own, and I can assure you that there's nothing stopping you from doing it in the first place. What's more is that I'll be here walking you through all of it to be sure that you get what you need to get.
However, that's not to say that I'm going to hold your hand. Your time is important to you, and because it's important to you, it's important to me. That's why I'm not going to linger a long time on any topic and I'm not going to run you simple processes. I'm going to assume you're smart, because it takes a smart person to pick up a book about programming and try to learn it on their own in the first place. So I'll teach you something once, and you'll be expected to know it, and that's the way this book is going to go. But I'm going to be helping you to implement all of the processes we learn as we go. Why? Because that's the best way to learn.
Learning to program is not easy. It's never easy. But my goal is to make it easier, and to give you an easy way to digest the absolute oceans of information that there is to know.
There are plenty of books on this subject on the market, thanks again for choosing this one! Every effort was made to ensure it is full of as much useful information as possible, please enjoy!







Chapter 1
Python - Why, and How?
There are a lot of reasons you may want to Python. Or, you may just be looking for a place to start with the wide, wide world of programming. Regardless of your specific purpose and goal, I can guarantee you that the Python programming language will provide you with all of the tools that you need to do exactly what it is that you want to do.
If you're browsing the introductory pages of this book on a preview or something of the like, on the fence as to whether or not you want to learn Python, well, I can tell you that you probably should.
Why?
Well, Python is basically an incredibly useful and powerful language. It's present essentially everywhere. Everything from the scripting side of video games (or the video games themselves) to intensive server-side web applications to the plethora of deep and responsive desktop applications that have been built with it.
When should you use Python? The answer depends upon exactly what you're going to do. But since you're a beginner, I say you should learn anyway.
As you continue to grow as a programmer after this book, you're going to learn when you should and shouldn't use Python just as a matter of intuition. Python is an absolutely fantastic language, but the place where it fails is when you have to get extremely close to a computer's hardware or write incredibly efficient programs. In these areas, Python doesn't excel.
However, that's not to say it doesn't have its perks. In fact, I'd say that's one of the few places that Python falls flat. And what it lacks there, it makes up for in other areas. For example, development time in Python is generally extremely low in comparison to other languages. This is super easy to illustrate. Compare the following excerpts of code, the first from C++, the second from Java, and the last from Python.
​Here's the C++ example:
​#include <iostream> 
​using namespace std; 
​int main() { 
​print "Hello world" <<endl; 
​} 
​Here's the Java example:
​public class javaExample { 
​public static void main(String args[]) { 
​System.out.println("Hello world\n"); 
​} 
​} 
And here's the Python example, for comparison:
​print "Hello world\n" 
See how much easier it is? And this is just with rudimentary programming concepts. When you get into heavier programming concepts like variables, functions, and other things of that nature, Python actually goes out of the way to make them really simple and functional to handle. We'll get more into this in the other chapters, of course.
On top of this, Python, as I've already said, is a language which has endless opportunity for usage and growth. There are very few explicitly bad situations for Python. This makes it a great language to learn initially for the simple fact that you'll be able to get a ton of mileage out of it. There will be very few times where, as a beginning programmer, you'll come up with a concept you'd like to carry out that you won't be able to conquer perfectly well with Python.
So enough of all that, how do we get started with Python? Well, you're going to need a few things first. Of course, you're going to need a computer, preferably with an active internet connection, but there are going to be more things that you need.
Let's start our programming adventure right here. I'm going to teach you everything that you need to get going with Python, so just follow along.
The first thing that you're going to need to grab is Python itself. You can get it by going to the Python website at http://python.org. You'll be able to download and install it for your respective operating system. Note that this isn't entirely relevant if you're working on Linux or macOS. Most versions of these operating systems will generally have a version of Python on it. You may, though, need to downgrade. If so, you're going to need to search for instructions which are relevant to your specific operating system because the instructions can vary depending upon which operating system you're using.
If you don't know whether Python is pre-installed or not, you can figure it out by going to either the Terminal (in macOS or Linux systems) or elevated Powershell (in Windows) and running the command "python". If your instance of Terminal or Powershell says something along the lines of "Command not recognized", then congratulations, you need to install Python. If it recognizes the command and says "Python 3.x.x" in the program initiation text, you need to downgrade.
Anyhow, on the Python site, you need to be certain that you're getting Python version 2.7.12, and not Python version 3. This is for one simple reason: Python 2 and 3 are a bit different in the way that they handle certain core functions. Not glaringly so, but one of the reasons that someone learns to program is so that they can speak directly to the computer. Learning Python 2 will give you many more opportunities to do this. This is for the simple reason that it's been around longer. There's much more code written for Python 2 than Python 3. You'll be able to work with a lot more code if you learn to work with Python 3 first. Now, granted, Python 3 is of course bleeding edge. But when you're learning to program, bleeding edge is not always best. It's preferable here that you learn how to read and write and deal with more code than you would otherwise. Basically, you're trying to cover as much ground with as little as possible when you're starting out, and Python 2 accommodates you for that goal perfectly. The few things you'll have to learn or relearn for Python 3 once you're more experienced with Python or programming in general will be non-factors compared to trying to understand deprecated code samples from Python 2 which aren't relevant to the code that you're trying to write.
With that out of the way, once you have Python 2.7.13 (or the latest version of Python 2 available) installed, you're going to need to get a text editor. It doesn't matter exactly what text editor you use, there are several good different candidates. The one I specifically recommend to use is called Atom, and you can get it at http://atom.io. There are a few reasons that I recommend this one. Firstly, it's free. What's better than high quality free software? Secondly, it's super simple to use and jam packed with features right out of the box, yet without being a sort of bloated and ugly software. Thirdly, it's incredibly extensible: there's nigh endless support for it through various different extensions and things of the sort online. There's so much that you can do with Atom. The endless possibilities of it and Python complement each other perfectly. And last but not least, you can get it for every major operating system.
Once you have Atom and Python installed, let's get right down to business on your first program. I'd recommend firstly that you create a new folder on your computer in an easily accessible place like the desktop or high up on your C drive. Name it something along the lines of Python. I don't recommend adding spaces in the name because it will slow down the process of navigating to it by just a little bit. Anyway, after you do that, you're going to open Atom. Once it's open, you're going to right click on the sidebar and click "Add Project Folder". Then you navigate to the project folder on your computer and select it. Then, you double click the folder in the sidebar in order to make it the active folder, and you right click on the sidebar and select "New File". Then after that, you're going to type hello.py.
In the file, you're going to type the following:
​print "hello world!\n" 
Then go ahead and save. Open up your Terminal or Powershell in order to run this. Navigate to the file you just made. If you don't know how to navigate in the command line, it's a worthwhile skill for any programmer in the making. If you don't know how to get around in the command line, then you need to. You can find a lot of useful and simple guides on Google that can teach you the basics in no time. I'm sorry to keep delegating things to Google searches, but it's really just that these topics go far beyond the scope of this book and, in the interest of staying focused and on topic, I think it's pertinent that I stay relevant to the topics at hand.
Anyway, you're going to navigate to the file and run it with the following command:
​python hello.py 
If everything goes according to plan, then you should get an output just like this:
​hello world! 
If that's the case, then congratulations! You just wrote your very first Python program. You've taken the first crucial steps to being a fully able programmer. It's all uphill from here.
In the next chapter, we're going to be discussing things such as Python math, values, and variables. These may sound boring, but trust me: they're foundational to everything else you'll be doing in this language. 







Chapter 2
Python Math, Values, and Variables
I wasn't lying in the last chapter. We're actually going to spend an absurd amount of time covering these concepts because they're foundational to almost every single thing we're going to be doing in the world of programming. Knowing these key concepts can get you nearly anywhere you want to go.
We're going to start with the very building block of this concept: values.
Values 
This section is actually going to be rather short. It doesn't take terribly long to explain. What is a "value", in the context of computer science? Well, in order to explain it, it's important to think about how a computer works. A computer is basically a big machine that processes ones and zeros constantly. These are what's called "bits". The computer is made up of a ton of these and the entire idea of a "computer" is that it computes calculations according to bits. Every single thing that happens on a computer is the result of a calculation of bits.
You build a little bit more upon the concept and suddenly you have the notion of using these "bits" in order to represent something. This builds up to the concept of memory and value storage.
Basically, a "value" is something which represents a set of numbers in the computer. They may manifest in various different ways but ultimately, when it comes down to it. every different "abstract" concept represents a number in one way or another. So for example, "Cat", 49, and 3.15 are all different values that correspond to numbers in the computer which actually represent their value.
Variables 
Variables are essentially just a way of storing a value. Basically what you're doing when you're declaring a variable is giving a name to the value. So for example a variable called "number of pineapples" could correspond to the number 5. If we were to eat one of the pineapples, "number of pineapples" would go down by a count of 1, rendering the variable "number of pineapples" to now mean 4. Variables are essentially containers for variables.
In a lot of other languages like Java and C++, the programmer is made to explicitly declare the "type" of the variable. This means the type of value which the variable holds.
For example, if we were to create a variable for what sport we're playing currently in Java, we'd do it like so:
​String sport = "baseball" 
But luckily (and unluckily) Python doesn't make us bother with this. It gives us a pretty gigantic shortcut, actually. In Python, we can just say:
​sport = "baseball" 
Because Python can figure out from the value of the variable what the type is. This does get a little confusing once you get to working with more exact types. Well, actually, I'd say it depends on how abstractly your mind actually works. If you have a very abstract sort of mind, then Python's manner of implicit types may work very well for you. If you don't, you may find yourself preferring explicit types, like those in Java. I will say, however, that this is one of many features in Python which massively streamlines development.
Since Python automatically sets types for you, it's actually all the more important to know about types in the first place. This is for the simple reason that if you were to have the following variables:
​number1 = 45 
​number2 = "45" 
And did a check to see if they were equal, then they wouldn't end up being equal. This is because number1 is an integer while number2 is a string. Despite having the same implicit value of 45, the explicit value of number2 actually works out to be the ASCII value of the raw characters of 4 and 5. Since it's a string and whatnot.
So knowing that types are important, we can actually cover the basic types of variables in Python.
​Name​Description​Declaring 
​Integer​Represents whole number​kindsOfBread = 6 
​Float​Represents decimal​weightOfBread = 0.49 
​Boolean​Represents true/false​hasBread = True 
​String​Represents text​nameOfBread = "sourdough" 
The distinction between this is immensely important. Fortunately, Python makes it pretty easy to use every last one of these variables. In this chapter we're going to be mainly dealing with integers, floats, and strings. Booleans will be talked about more in the next chapter concerning conditionals.
Let's start with an example for this chapter. What you're going to do is head to Atom and create a new file, just like we did last time. This example should be called something along the lines of chTwo.py. What we're going to do here is create a variable called favoriteFruit, and a variable called amountOfFruit. favoriteFruit should be a string which is set to the value of your favorite fruit in the world. amountOfFruit should be set to the amount of that fruit that you could really go for right now.
This is actually what my example ended up looking like:
​favoriteFruit = "mango" 
​amountOfFruit = 6 
​Now follow my example and type this in below the last two variables in order to get these values to do something. Observe:
​print "I love the %s, and I wish I had %d of them." % (favoriteFruit, amountOfFruit) 
​Save this and run it, and observe how it prints out to the console. Awesome! You just created your second Python program. 
We're going to be building on this in the next section talking about operators.
Operators 
Now what we're going to do is create a néw variable called months. We're going to set this variable to be equal to 3. This is going to be, mind you, right below the rest of the program that we just wrote. What we're also going to do is change the value contained by favoriteFruit to your second favorite fruit in the world. Here's how mine ended up looking.
​favoriteFruit = "mango" 
​amountOfFruit = 6 
​print "I love the %s, and I wish I had %d of them." % (favoriteFruit, amountOfFruit) 
​months = 3 
​favoriteFruit = "banana" 
Let's go ahead and add one more print statement.
​print "Quick update: I ate that for %d months straight and got tired of it. My favorite fruit is now the %s." % (months, favoriteFruit) 
Now what we're going to do is save and execute this code once more. You don't have to be terribly observant to see that the favoriteFruit variable actually changed the second time it was printed out. This is because what we just used was an operator.
Operators are essentially symbols in Python which represent certain functions. Operators also exist in other languages, often relatively similar to Python depending upon what language you're using. If you're using another C derived language then the operators will likely be largely the same.
Anyhow, the operator we specifically used was an assignment operator. Assignment operators are used in order to assign a new value to a given variable.
The simplest assignment operator to use is =. All that this means is that the specified variable now takes the value of whatever side of the equation. This is where things like types start to be really important; if you start a variable as one type, and then use the = assignment operator in order to set it equal to a different type, then you're actually very likely to get an error.
Anyhow, here are all of the major assignment operators:
​Operator​Meaning​Example 
​=​​a is b​​a = b 
​+=​​a is a + b​​a += b 
​-=​​a is a - b​​a -= b 
​*=​​a is a * b​​a *= b 
​/=​​a is a / b​​a /= b 
​%= ​​a is a % b​​a %= b 
​**=​​a is a ** b​​a **= b 
​//=​​a is a // b​​a //= b 
Some of these symbols are self explanatory. Others, still, very much aren't. That's okay.  What you need to understand is that these can be used to increment. Consider the code which follows:
​j = 2 
​# j is equal to 2, but we want to add 3 to it 
​j += 3 
​# The arithmetic which guides this is j = j + 3 
​# Let's substitute where appropriate: j is 2, so j = 2 + 3 
​# Thus, j is now 5. 
​All of these are built upon what's known as arithmetic operators. These are actually relatively easy to understand. Observe:
Operator​​Function 
​+​Adds the values to each other. 
​-​Subtracts one value from another one. 
​* ​Multiplies given values. 
​/​Divides given values. 
​%​Modulo; gives the remainder (10 % 3 = 1) 
​**​Denotes exponentiation (3**2 = 9) 
​//​Floor division. 
There's one more set of operators, and we're actually going to work with them in the next chapter. For now, play in our file with creating and altering variables given the operators we've covered so far. You should have a pretty basic gist of what they are and how to use them. Remember, while you do this, that every variable just stands for a value, so if you have two variables:
​variable1 = 2 
​variable2 = 6 
If you were to add together variable1 and variable2, it'd be the result of both. variable1 + variable2 = (variable1 + variable2). Thus, since variable1 is 2 and variable2 is 6, variable1+variable2 = 2 + 6 = 8.







Chapter 3
Expressions and Conditionals
This is going to be one of the biggest and most important concepts that we cover throughout the book and, indeed, one of the biggest and most important that you'll cover in the entirety of your programming career. Every single thing in a program involves making choices in one way or another. From its very start, the program is running various sorts of logic, even if you don't see it - internal questions of "what operating system am I running on?", "what time did I start?", "how much RAM do I need?", and so on are answered for the program without you ever seeing it. But that logic runs, and with the answer specific decisions are made.
And indeed, that's a very important part of any sort of logic and flow: being able to come to different conclusions based off of the veracity of a given event or statement.
This is actually relatively easy. It can be accomplished by way of what's called "conditionals". What are conditionals? Conditionals are a way of seeing if something is true or not. This is done by way of conditional operators to form expressions. How does this work?
The way that expressions work are by what's formally known as testing a condition. What this means is checking something to see whether or not it's true, plain and simple. There's nothing more or less to it. Testing a condition is just taking an expression (2 is less than 4) or a singular statement (is hasBerries true?) and then working from it.
Let's start by examining the type of expressions we can form.
​Operator​Description 
​a == b​​a is equal to b 
​a != b​​a is not equal to b 
​a <= b​​a is either less than or equal to b 
​a < b​​a is less than b absolutely 
​a >= b​​a is either greater than or equal to b 
​a > b​​a is greater than b absolutely 
Remember how in the chapter earlier, we talked about "boolean" variables that hold whether a variable is true or false? That's where this starts to be useful. You can actually assign multiple things to a boolean variable, like a function which returns a boolean value (we'll talk about this later), the result of an expression like the ones I just described, or a raw "True" or "False" value. The exact underlying arithmetic of this is unimportant, but you can understand simply put that "True" means truth and "False" means untruth, surely.
There's actually a really simple way to make use of this idea. We're going to work with this a little bit. Go ahead and open Atom and start a new file called chThree.py. This is the file we're going to be working in for the rest of this chapter.
​First, what we're going to do is create a few variables.
​pineapple = 45 
​noPineapple = 60 
​pineapplesWin = pineapple > noPineapple 
​Now let's test this out.
print "Do more people like pineapple on pizza than not? %r" % pineapplesWin 
​Upon saving and urnning this, it should print out:
​Do more people like pineapple on pizza than not? False 
Perfect, right? Well, I guess that actually depends on whether you like pineapple on pizza or not. But the statistics I made up don't lie. Anyway, what happened is that pineapplesWin tested whether the variable pineapple was greater than noPineapple. It then stored the result of that.
If nothing else, this demonstrates how expressions directly correlate to a truth evaluation.
I know what you're thinking: "that's cool and all, but what actually can we do with it?"
Well, that's where the next part of this chapter comes in.
If statements 
Being able to evaluate a statement and make a decision based on its veracity is essential to all logical processes, not just programming. But you'll find it endlessly useful in programming nonetheless.
So what exactly is an if statement? An if statement is something which takes a given boolean statement, whether it be a function which returns a boolean value, an expression, or a variable which stands in for an expression. I'll just show you, to illustrate. Go ahead and remove the print statement from the file that we wrote.
Now,  let's say that we wanted to print out one thing if pineapples were greater than noPineapples, and another thing otherwise. How would we go about writing this?
Well, the basic outline for an if statement in Python is as such:
​if statement: 
​# code here 
(Pay attention to the indentation! Indentation is super important to program flow and control in Python. Having the wrong indentation can make your code function bizarrely or, worse, not compile altogether. Be super careful with your indentation and pay close attention to it. It's used to specify program hierarchy.)
So let's go ahead and insert our boolean variable:
​if pineapplesWin: 
​# do something 
Now how do we specify that if pineapples DON'T win, we do something else? In other words, how do we specify what we do if the condition is not true? This is done by use of an else statement, like so:
​if pineapplesWin: 
​# do something 
​else: 
​# do something 
See what I'm getting at, here? Now let's go ahead and replace the comments with actual print statements. Here's how mine like.
​if pineapplesWin: 
​print "More people like pineapples on their pizza than don't." 
​else: 
​print "More people don't like pineapples on their pizza than do." 
Do you see what I'm doing here and how this is playing out? It's pretty self-explanatory.
It's also worth noting that you can actually take the else statement off of this. This is what I like to call a potential conditional. This means that no code is guaranteed to run unless the expression works out to be true. If the expression isn't true, no code pertaining to it runs.
The else statement turns it into an absolute conditional. This means that because of the else statement, no matter what, some code pertaining to the evaluation is going to run. It doesn't matter if the if statement is true or not, something is going to happen.
So what if we wanted to add something else to it? What if we wanted to, I dunno, print something out based on the numbers rather than the comparison of the two variables?
Testing for multiple conditions is absolutely possible. It happens as a result of the use of if else statements. Erase the last if statement, and now let's try it this way:
​if pineapples <= 20: 
​print "20 or less people like pineapples on their pizza." 
​elif pineapples > 20 and pineapples < 60: 
​print "More than 20 but less than 60 people like pineapples on their pizza." 
​else: 
​print "60 or more people like pineapples on their pizza." 
Do you see how we used elif in order to evaluate if the second statement was true? What the program would do is check whether the first statement was true. If it wasn't, then it would iterate to the second statement and check whether it was true. If that statement also wasn't, then it would iterate to the else statement.
You'll also notice that we used the word and. This brings us to the last part of this lesson: logical operators. These exist in three keywords in Python: and, or, and not.
And checks whether both premises are true and only evaluates True if both of them are, like so:
​if 4<6 and 6<8: 
​# returns true 
​if 4>6 and 6<8: 
​# returns false 
The second returns false because even though 6 is less than 8, 4 is not greater than 6.
Or functions similarly, but is only checking to see if one of the given conditions are true.
​if 4<6 or 6<8: 
​# returns true 
​if 4>6 or 6<8: 
​# returns true 
Note the difference: even though one of the equations on the second if statement is false, one of them is true, and that's all you need for an or statement to be true.
Last is the not keyword. All that this does is inverts a statement, essentially. It              checks to see if something is false rather than true:
​if 3 < 5: 
​# true 
​if not 3 < 5: 
​# false 
The second returns false because it checks to see if the statement is not true. Since 3<5 is true, then "if not 3<5" must evaluate as false. So the first if statement would run, but the second one would not because the statement is true and not false.
Let's look at a more common application of this sort of thing than fruit, though. We're also going to learn about user input here.
User Input 
Before I get into this, I should give you the disclaimer that raw text passwords are never a good idea in practice and should always be hashed and have the hashes compared. Raw text passwords are asking for a world of trouble.
Anyway, let's create a new file called chThree2.py. In it, create a string called password and give it whatever value you like; I'm going to give mine the value cheesecake.
It should look like this:
​password = "cheesecake" 
Now we're going to get user input. The way that you do this in Python 2 is through the raw input method. This method also has a handy feature: you can insert a string as an argument and have it printed out to the console, which saves you the time and space of an extra print statement. Observe:
​password = "cheesecake" 
​raw_input("Enter the password.") 
See what I mean? But hey, we're going to backtrack. Since raw_input returns a string value (the user's input), we're going to save this to a variable so we can compare it. Like so:
​userInput = raw_input("Enter the password.") 
Now compare them against one another using an if statement.
​if userInput == password: 
​print "Welcome in!" 
​else: 
​print "That password is incorrect." 
Save the file and test it out. If you get an error, check to be sure that you used the equality operator (==) and not the assignment operator (=). (==) checks to see if two values are equal, (=) assigns the value on the right to the variable on the left.
Hopefully, by now, you can see the various applications for if and else statements. If not, it'll just be one of those things that you start to understand more with ample practice.







Chapter 4
Data Sets
There's a lot to cover in this book in what is frankly not a lot of time. But I do want to get to loops quickly because they and conditional statements make up the bulk of what you'll be doing in a lot of your programming.
To understand loops, methods, and strings fully, though, you first have to understand data sets.
Data sets are a way of grouping data together by a name. Let's say that you had a restaurant, and you wanted to store the appetizer names. Would the best thing to do really be to create a bunch of variables, like this?
​appetizer1 = "Jalapeno poppers" 
​appetizer2 = "Mozzarella sticks" 
​appetizer3 = "Onion blossom" 
​# and so on... 
No, of course not. That's absurd. Besides, it's really easy to lose track of which is which. No, the better way to do this would be to create a list.
Lists 
Lists are really very simple. They're just a bunch of data lumped together into one easy to find place. They're the spiritual successor to arrays in C/C++ and follow a similar role to vectors and lists in both C++ and Java. They are, however, much simpler to implement and keep track of. Another advantage is that Python lists innately have support for multiple types.
Let's say we wanted to create a list called appetizers after all. We're going to go ahead and populate it with the three items that we listed before.
​appetizer = ["Jalapeno poppers", "Mozzarella sticks", "Onion blossom"] 
(You can also declare an empty list by simply stating appetizer = [].)
Computers start counting from 0, so let's say that we wanted to get element 1 from the list (the second item in the list). We'd do this:
​print appetizer[1] 
And it would print out "mozzarella sticks".
Adding to a list is also super easy and super competent in the world of Python. All you do is use the append() method.
Let's say that we started ordering things for guacamole and starting offering nachos with guacamole. We could list that as an appetizer like so:
​appetizer.append("Nachos with guacamole") 
Now we have a fourth item in the list. We can grab this by doing this following:
​print appetizer[3] # pulls the fourth element in the list 
This would print "Nachos with guacamole", pretty much as expected. Not too terribly difficult to work with at all.
Now let's say that you stopped carrying mozzarella sticks. There are two different ways you can remove a value from a list: the pop method and the del keyword. The pop method removes the element from the list and moves everything else back to fill its place, as does the del keyword. The problem with the pop method is that it returns the value, which often isn't what you want. So for now, we're just going to work with the del keyword.
To remove mozzarella sticks, first we need to figure out where it is in the list:
print appetizers
​# ["Jalapeno poppers", "Mozzarella sticks", "Onion blossom", "Nachos with guacamole"] 
​It's the second item in the list, so we know it's element 1. We'd get rid of it by typing the following:
​del appetizers[1] 
​If we tried to print appetizers again, we'd get this:
​["Jalapeno poppers", "Onion blossom", "Nachos with guacamole"] 
Instead of being at position [3], "Nachos with guacamole" is now at position [2] because the list automatically shifted all of the elements after "Mozzarella sticks" back a space. Follow?
Dictionaries 
Where lists are unordered, unorganized sets of data, dictionaries are quite the opposite. Dictionaries operate similarly to, well, a real dictionary: on key-mapped values. Think about it. If you want to look up the definition of the word astute, you look for the word astute in the dictionary. The word astute is your key; the word astute is mapped to its definition, which is the value. This simple interaction between key and value defines dictionaries perfectly and succinctly.
So how would you form a dictionary? We'll do so by using actual examples from a dictionary! First, we declare it and set the keys to the values. This is done with the following template:
​dictionary = { key1 : value, key2 : value, key3 : value, [...] } 
So if we wanted to do it like an actual dictionary, here's how we'd do it:
​dict = { "astute" : "of keen penetration or discernment", "asyllabic" : "not syllabic", "asylum" : "any secure retreat" } 
Now we can actually search this, like so:
​userInput = raw_input("Welcome to dictionary search! Enter the word you'd like to define.") 
Now, with our user's input, we can actually use an if/else statement to see if the dictionary contains the word they entered. We do this using the in keyword, which let's us see if the list or dictionary contains a given value or key in lists or dictionaries respectively. Observe the following code:
​if userInput in dict: 
​print dict(userInput) 
​else: 
​print "That's not even a word (that we know of.)" 
Do you see how cool and simple that is? It's even better, too, because in other languages, you'd have to iterate through the dictionary with a loop and match up the value. Python just allows you to straight up see if it's in there with no buggery and no looping. Maybe it does loop under the hood, but you certainly don't have to waste your time coding it.
So when exactly would you use this? Well, it really depends. Inevitably, there will be a lot of instances where you could use a key map system. Famously, store inventories or libraries.
In store inventories, items are usually identified by a SKU number or a UPC code. This can be used in order to identify the object by way of a barcode scanner or a quick little search. This SKU/UPC is so precise that it will pull up the exact model of the item that you're holding, right down to its color (if it comes in multiple). Stores will use dictionary type systems in order to catalogue their items and keep track of their inventories without having to have an unnecessarily difficult-to-use system wherein they have a bunch of items with no clear designated name or some bizarre "keyword" search system where you could spend an inordinate amount of time looking for the exact model of an item.
Libraries, too, will usually sort their books by their ISBN. Every book has a unique ISBN, so this is a quick and easy way to identify a book based solely off of an ISBN, where otherwise titles and things similar may be sketchy or difficult to find exactly. This also really simplifies the process of scanning it. A sequence of numbers in a finitely printed label is super easy for a scanner to discern, whereas the front cover, of which there can be multiple variants and of which there can be multiple different fonts and layouts and extra graphics to confuse the computer, could never be used by a scanner reliably in order to find a book unless it had a massive graphical database of every possible book cover.
Anyhow, that's the gist of the two primary different sort of data sets in Python, dictionaries and lists. Now, we have to talk about the myriad ways in which we can better utilize and iterate through them using loops.







Chapter 5
Loops
Loops are an incredibly simple but infinitely important part both of programming and of control flow within your program. In fact, I'd argue that they're the most important part altogether. Most programs that you can think of will demand explicitly that you utilize a loop in one fashion or another. The exact manner in which you may need to utilize them, will of course, change, but that's nothing if not a credit to their versatility. I can think of hardly any programs that one would actually use where a loop is not required. It's only with the most simple and banal of programs that some sort of looping process isn't demanded.
That's not to say that loops are absolutely necessary in every program, don't put them where you don't need them. But they offer a massive amount of utility and flow to a program and it's imperative that you learn when you can use them advantageously.
In Python, there are two main different kinds of loops. These are known as the while and for loops respectively. For loops are the most pertinent and important loop to understand so I'm going to spend the vast majority of my time talking about them. But it's important that we get the easier one out of the way and talk about while loops right now.
While loops 
I hope sincerely that I didn't make while loops out to be useless. They're not at all, and in fact, they may be one of the more useful loops that you're going to end up using in the world of Python. The basic function of the while loop is that you give it a condition. On every iteration of the loop, it will check the condition. If the condition turns out to not be true, then the loop will quit running.
Take the following loop execution code for example:
​i = 1 
​while i <= 5: 
​print i 
​i += 1 
This loop would run for as long as i was less than or equal to the number 5. As soon as i is 6, the loop quits running. This would print out the following:
​1 
​2 
​3 
​4 
​5 
See what's happening here?
The real utility of this loop comes through what's called the game loop. What a game loop basically is is a loop which is comprised of two different parts. First, there's a boolean. This boolean basically says whether or not the program is running or whether or not the user has quit yet. The while loop is the second part, and the while loop basically runs a subset of code for as long as the boolean remains true. This boolean is usually titled something like "run". Upon either issuing a quit command or meeting a certain condition (something like "playerHp == 0"), run becomes false, which indicates that the loop isn't to run anymore.
To demonstrate this, we're going to create a new file called chFive.py.
Within this file, we're going to create a variable called running and set it to True. After that, we're going to create a new variable called totalNumber which is set to 0.
Now, we need to create the loop. Technically, we're checking to see if run is true, but since run can't be anything but true or false, and conditional checking innately checks to see if something is a boolean true or false, we don't have to type whole comparison of "running == true"; simply typing "running" has the same connotation. Likewise, "if not running" or "while not running" have the same connotation as "if running == false" or "while running == false".
​Moving forward: let's make our loop. 
​while running: 
Perfect. Now what we're going to do is ask the user to enter a number. We'll check to see if the string that they entered is a number, and if so, we're going to cast it - or convert it to a different type - to an integer and add it to our total. If it's not a number, we set run to false, which will exit the program. Sounds like a plan. Let's start going through this step by step.
First what we're going to do is print the current user total and tell them to enter a number.
​userInput = raw_input("The current total comes out to: %d. \nEnter a number, or enter anything else in order to terminate." % totalNumber) 
Now that we have their input, we're going to check what they entered. The way that we do this is by something called a method. Methods are things which perform various functions. You can make your own, and a lot are also provided for you. For example, raw_input() is a method. Here, we're using the innate string method of "isdigit()" in order to see if it's a digit or not. Observe:
​if userInput.isdigit(): #checks to see if userinput.isdigit() returns true 
If it's true, then we need to add it to our total after an integer typecast to the original variable. Look!
totalNumber += int(userInput) 
Now we need to define what happens if it isn't true. If it isn't true and userInput isn't a number, then we're going to set running to false so that we leave the loop. After a kind goodbye message, of course.
else: 
print "Thank you for using the program! Goodbye." 
running = false 
This indicates to the program that we're done with the while loop since run is no longer true. The end of the code should look like this:
running = True 
totalNumber = 0 
while running: 
​userInput = raw_input("The current total comes out to:%d \nEnter a number, or enter anything else to terminate." % totalNumber) 
if userInput.isdigit(): 
​totalNumber += int(userInput) 
else: 
​print "Thank you for using the program! Goodbye." 
​running = false 
See how simple and efficient this program is? It's a piece of cake!
For loops 
The other loop that we really need to talk about is the for loop. The exact usage of this loop will vary depending upon which language you're using. It's particularly different in Python than it is in Java or C++ or C. However, regardless of the implementation, it excels at one thing precisely: iteration. In Python, it's geared specifically towards this purpose. If you need to iterate, you're going to find that the for loop is pretty much the exact loop that you're going to need to use.
There are a few different ways to set up for loops, but they all have the same principle behind them: iteration through a certain set or range of values. The particular method by which the value is given can vary, but the idea of a "range" of values stays pretty similar through all of it.
First, let's take the 1 to 5 example that we had in the section on while loops. How would we implement this? Well, for loops are made up of two essential parts: the iterator, and the iteration sequence.
The iterator is normally called either i or something relevant to the specific iteration like "file" or "character". The iteration sequence can vary. It can be a list (or an object masquerading as a list, like the File object which is really a sequence of strings).  It can also be a range. The range method in Python works really simply. All that you do is put the starting number and the ending number plus one. So if you wanted a range of 1 to 5, your method's declaration would be: range(1,6)
If you don't put a beginning number, it will automatically start from 0.
So if we wanted to print out 1 through 5, the code would look a bit like this:
​for i in range(1,6): 
​print i 
In fact, write this code and run it. You'll see what I mean. The iterator object i is iterated through the list and made to match the value of every given object in the list as we make our way through. Your output will be just like it was in the while loop section:
​1 
​2 
​3 
​4 
​5 
Now what you're going to recreate the list of appetizers that we had in the previous chapter:
​appetizers = ["Jalapeno poppers", "Mozzarella sticks", "Onion blossom", "Nachos with guacamole"] 
Now let's say we wanted to iterate through this. There are two ways we could: first, we could just iterate the pure text form of it, with no extra flair.
​for appetizer in appetizers: 
​print appetizer 
​Which would print something like:
​Jalapeno poppers 
​Mozzarella sticks 
​Onion blossom 
​Nachos with guacamole 
Or, we could iterate through it and put a number before each one. Here's how we'd do that:
First, we have to set up the first half of the for loop, like so:
​for iterator in 
Now, before we get the second half, we have to think about this. We want to count, not iterate. We can use the range function for this. But how do we get the length of a function? Perfectly simple. What you do is use the len() method. So our for loop initializer should look like this:
​for iterator in range(len(appetizers)): 
What this is saying is that we're going to iterate "iterator" through each number in the range of 0 to the length of the appetizers list. The length of appetizers is 4, so this is basically saying range(4), which would involve the numbers 0, 1, 2, and 3.
​Now here's how we set up the rest:
​for iterator in range(len(appetizers)): 
​print "%d: %s" % ((i + 1), appetizers[i]) 
Save this code and run it. Do you see what happens? It's a really clever way of iterating through lists and numbering off the contents.
Anyway, there are multiple ways your for loops may manifest. This is just one of many. However, as you work more in Python, the key thing to remember is that for loops will always be used for iteration through a list or range, no matter what.







Chapter 6
Methods
I've talked a lot about methods in this book. But just what exactly are they? I fear that this is the last major lesson we're going to get into in this book, because after this, things become really specific and abstract. But it would be criminal of me to send you off without knowing properly how to construct and utilize methods in order to make your code beautifully redundant and modular.
Before I go on, I've probably interjected the word "function", too, throughout this book. This is because I'm an old geezer at heart. "Function" and "method" mean the same exact thing. I learned programming with C++, and so "function" was the term that I learned. Scripting languages and languages built around object-oriented programming normally refer to them as methods. For all functional purposes (heh), they're essentially the same thing, though. There is no real functional difference between the two.
So what is a method? A method is a subset of code which defines a process which can be performed over and over ad nauseum, if you really want to. You can give it arguments and you can give it certain different ways to execute. You can even overload it so that you can give it different sets of arguments beyond the initial set that you give it. But the key thing to take home is that methods are a way to reuse a chunk of code again and again.
Let's say that we wanted a method that would calculate the area of a triangle. Here's how we'd do it in pseudocode:
​function triangleArea(base, height) { 
​return (base * height) / 2 
​} 
And Python, luckily, makes methods super duper easy to declare. This actually isn't that difficult to convert directly. Here's how you would set up this function:
​def getTriangleArea(base, height) { 
​return (base * height) / 2 
​} 
This is where the utility of methods comes in. Notice first how we return a value. Now notice what's within the parentheses.
What a function allows you to do is essentially send some data to it, have it do something with it, and then give a value right back to you. (If you'd like - returning a value is optional, you can have functions which return nothing)
Let's implement this in actual code. Create a new file called chapterSix.py. Within this file, define the method that we just created. Then, below that, we're going to create some variables.
Let's create a variable called b with the value of 12.00, and a variable called h with a value of 7.00. After you've made those, create a variable called area which takes the value of getTriangleArea given the variables b and h.
​Confusing? Let me show you:
​b = 12.00 
​h = 7.00 
​area = getTriangleArea(b, h) 
​Now we're going to print the result of getTriangleArea:
​print "%2f" % area 
# using %2f because we are printing out a float number to the second decimal point. 
Now save this code and run it like usual. Do you see what happened? The method took the values of 12.00 and 7.00 and "replaced" the base and height arguments within itself with those numbers. It's a very simple and straightforward way of explaining arguments, no doubt.
Now, let's kind of start to synthesize a lot of the concepts we've been working with: what we're going to do is create a new file called chapterSix2.py. In this, we're going to create a program that, for as long as it's running, lets the user enter numbers and then it parses a square's area from it, using the formula length * height.
First what we do is create our primary function which computes the area of a square:
​getSquarea(l, w): #squarea - square area. my puns are my own 
​return l * w 
Super simple. Now we just have to define essential variables:
​running = true 
​Next we create the essential while loop: 
​while running: 
​After this what we do is accept user input.
​print "Enter numbers, or anything else in order to exit."
​userInput1 = raw_input("\nEnter the rectangle's length.\n")
​userInput2 = raw_input("\nEnter the rectangle's width.\n")
Now we just check to see that both userInput1 and userInput2 are digits. If they are, we send their integer values to the method. If not, we exit.
​if userInput1.isdigit() and userInput2.isdigit(): 
​​area = getSquarea(int(userInput1), int(userInput2)) 
​​print "The area is %d. Let's do it again!\n\n" 
​else: 
​​print "Thank you for using! Goodbye." 
​​running = false 
All of the code together should look like this.
getSquarea(l, w): #squarea - square area. my puns are my own 
return l * w 
​running = true 
​while running: 
​print "Enter numbers, or anything else in order to exit." 
​userInput1 = raw_input("\nEnter the rectangle's length.\n") 
​userInput2 = raw_input("\nEnter the rectangle's width.\n") 
​if userInput1.isdigit() and userInput2.isdigit(): 
​​area = getSquarea(int(userInput1), int(userInput2)) 
​​print "The area is %d. Let's do it again!\n\n" 
​else: 
​​print "Thank you for using! Goodbye." 
​​running = false 
And there we. Simple? Yes. But logically complex, and synthesizes a lot of what we've been working on in this book so far, aside from lists and dictionaries. 







Conclusion
Thank for making it through to the end of Python for Beginners, let's hope it was informative and able to provide you with all of the tools you need to achieve your goals whatever it may be.
The next step is to go on to more complicated topics. You've started the long and often arduous journey of programming in this book. And the best thing about it? There's no finite end point. There's never going to be a point in programming where you say enough is enough, or where you reach some kind of "peak"in your knowledge. Well, technically speaking, maybe, but only if you quit trying will you have hit a peak.
Programming is one of the most liberating tasks known to man, because it's the ultimate art form. It's the most interactive art form too. When you program, what you're doing is literally talking to the computer, and thereby making the computer talk to the user. Every single program you make is an extension of the effort that you put into it and the time and the code that you've dedicated to it.
Programming, too, is not easy. In fact, it's rather difficult. And there are topics that are sadly too esoteric to cover in this book. For example, we didn't get to the bulk of file operations, nor did we get to things like object-oriented programming. But I hope what I've given you is a very solid foundational understanding of Python so that you can better service yourself to learn about these things.
I told you I wasn't going to hold your hand, and I didn't. And now I won't, either. But what I can say is that you have worked hard to be a programmer and you have worked hard through the course of this book, likewise. Not all of the concepts within this book are easy to understand, even with more in-depth explanations.
My goal here wasn't explicitly to teach you Python or object-oriented programming or any of that: my goal was to teach you the computer. The way it thinks, and the way programs are written. Anybody can learn Python keywords. But to learn to program, and to write solid effective code regardless of which programming language that you're using, that's another skill entirely.
I hope sincerely that this book has helped you to getting on the road to accomplishing everything that you want to accomplish in the world of programming. Remember going forward that without a doubt, it will not always be easy. It won't be even remotely easy. Programming is made difficult by its very nature. Humans, we just don't think like computers. But hopefully I've helped you to understand programming at least.








Python Tips and Tricks

Learn the Best Tips and Tricks to Get The Most out of Python NOW! 
DANIEL JONES







Introduction
Let's face it: it's really easy to hit a wall with Python. It's really, really easy. In fact, it's really easy to hit a wall with a great number of languages. I can't tell you the exact things to do to get past your wall, but I can tell you a bunch of really neat tips and tricks that will build your programming skills and help you to be on your way to being the master programmer that you innately feel that you can be.
You and I both know why you're here: you want to be a better programmer. And I get that. Actually, I more than get that. I empathize with it. I've been there numerous times.
The following chapters will discuss how to get through your funk if you're having one, or otherwise just tips and tricks which will really help you in your Python programming. Some of these are going to seem terribly obvious, sure. But the fact is that it's extremely easy to miss things when you're learning. And on top of that, there are 100% topics that you just, frankly, never bothered to learn about that very well could enhance your workflow or productivity or even just the simple quality of your code. After all, who doesn't like a quality set of code?
There are plenty of books on this subject on the market, thanks again for choosing this one! Every effort was made to ensure it is full of as much useful information as possible, please enjoy!







Chapter 1
Fun with Lists
We're going to start all of this off by talking about ways that you can streamline working with lists. Now, already, Python makes working with lists a breeze, especially compared to other languages which tend to needlessly complicate it. However, there is somewhat of a missing element there: some things, during the learning process, can really go over your head! I can't guarantee you that I'll teach you everything, but what I can guarantee you is that you're going to have a lot less questions about the dos and don'ts of lists after you're through with this guide. What I can guarantee you even more is that you're going to have a lot more uses for lists that you honestly may not have thought about.
List comprehensions 
List comprehensions are an extremely interesting concept. They're a very unique Python feature which allows you to both build and modify lists in a terribly simple way.
Let's start with a really simple example: let's say that you have a populated list called "numbers", with the numbers 1, 4, 6, 9, and 13 in it. We'd, of course, set it up like so:
​numbers = [1, 4, 6, 9, 13] 
What would we do if we wanted to double every single item on the list?
Your first instinct very well may be to do something along these lines:
​for x in range(len(numbers)): 
​numbers[x] = numbers[x]*2 
However, this is unwieldy. And the knowledge that it's unwieldy and that there's a better solution thus makes it untenable. In other words, don't use this every again.
What list comprehensions allow you to do is populate a list using a given equation and an iterative for loop - even using the same list. This may seem a little obtuse, but you'll understand. We could simplify the aforementioned code like so:
​numbers = [x * 2 for x in numbers] 
The most important thing to do here is to analyze the right side of this code. What exactly is happening here? Well, what we're doing is creating a list, denoted by the brackets. The brackets always denote a list. It's the same reason we can create an empty list by saying list = []. What's between the brackets is the list, full stop. Anyway, we're creating a list. List comprehensions allow us to populate the list by iterating through a for loop. Every iteration through the for loop will append a whole new item to the list.
Let's look at a couple other examples of this phenomenon to be sure that we fully grasp it. Let's say that we wanted to create a list of perfect squares up to the number 10. Can you guess how we'd do this?
What we'd do is have the for portion iterate through a range from 1 to 11. We could do 0, but squaring 0 is boring.
So to make this a proper list comprehension, here's essentially how we'd have to write it:
​perfectSquares = [i**2 for i in range(1,11)] 
This would automatically populate the list with perfect squares by taking i as the current iteration of range(1,11) and then squaring it. How would we have to do something like this without list comprehensions? It'd be terribly unwieldy. it would have to be something like this:
​perfectSquares = [] 
​for i in range(1,11) 
​perfectSquares.append(i**2) 
The list comprehension feature is pretty much a godsend. It allows you to add to your lists in a very clean iterative way and edit them without any problem at all. This is one of the most useful features that you may not have known about. But there are far more tips and tricks involving lists that I can give you. Here's one now!
Zip 
Zipping is a way of creating tuples in Python. What happens is that you create two different lists and then you can zip them together. Zipping them will create a new list containing a set of tuples resulting from the two lists that you provided. Allow me to show you:
​l1 = ["house", "apartment", "condo"] 
​l2 = ["car", "subway", "bike"] 
​zippedlist = zip(l1, l2) 
If you were to print out the zippedlist, it'd print like so:
zippedlist
​[("house", "car"), ("apartment", "subway"), ("condo", "bike")] 
Notice how they correspond to the nth item on each list, respectively. This is a perfect example of zipping. You can also unzip the lists like so:
​unzip1, unzip2 = zip(*zippedlist) #notice the use of the asterisk 
​list(unzip1) 
​["house", "apartment", "condo"] 
​list(unzip2) 
​["car", "subway", "bike"] 
Zipping and tuples in general are an underrated aspect of Python that people seem to forget about constantly. But no, they're actually very useful, and you'd do well to make some time to study all of the various uses of lists and tuples. There are a lot of cool functions that you can really easily miss out on and end up making a very roundabout function for a functionality which is already there.







Chapter 2
Fun with Strings
Strings are one of the most powerful tools built into Python, full stop, no questions asked. There are a lot of things which can be done with strings. They have a ton of built-in functions that make them a breeze to use and do whatever that you need to do with them.
Every novice programmer knows what a string is at the most basic level. It's a line of text, basically. But not every programmer knows exactly how strings are structured and their manifold uses in the world of Python. In order to ameliorate this problem, I'm going to start by introducing the most essential fundamentals of strings and the way that they're set up to you. Afterwards, I'm going to start introducing a lot of the great many functions that you can perform with the built-in string object methods and other essential functionalities of this absolute powerhouse.
String Fundamentals 
You may or may not be familiar with the history of Python. Python is descended from a long lineage of other languages that ultimately derive from a language called C, which is one of the most important programming languages in the history of computing. C, then, derives also from languages such as BCPL and ALGOL, but that's unimportant for exactly what we're addressing here.
Long before the simplicity of Python lists, there was a concept known as the array. Arrays represented essentially the same core idea as Python lists do: the compacting of a bunch of variables representing different instances of the same thing into a little compressed space. There was one major difference, however: arrays were not dynamically allocated. This is to say that though arrays may have existed, albeit in a different form, they had a fixed size. Lists, as you know, do not. C++ and Java would come along to introduce and develop concepts such as vectors and lists and sets which would, in turn, fill the need for a dynamically allocated array that would adjust to be the size that you need. The implementation of Python lists, indeed, was inspired somewhat by these similar implementations all around.
Arrays allocated in a specific way serve a very specific purpose historically: when you would allocate an array, you would actually allocate that many spaces in the computer's memory for the array to take up. This was super important, especially in the time of computing when computers had a very minimal amount of memory to begin with. When you allocated an array, you were making sure that those spots in memory were available no matter what.
Arrays, too, can actually be implemented in Python, though they're actually a bit difficult to implement - go figure for a language which places so much emphasis on being approachable and easy to use.
Lists, in Python's development, took priority because computing power was growing. So, despite representing the same fundamental concept as an array, the list took major precedence over it. This is for one very simple reason: the philosophy of Python and the philosophy of array usage are intrinsically different. Python, in terms of raw computing power and computer usage, is a particularly wasteful language. What it lacks in raw performance, it makes up for in other aspects, such as deployment time, the actual amount of time spent coding in Python being dramatically lower, the security of the language due to the fact that it's a largely interpreted language being run within a virtual machine, among other things. It simply doesn't make sense to have a core feature of the language be fixed memory allocation, because such a concept altogether is a just a tired and deprecated concept for the vast majority of programs that will be written; a lost remnant of an age of computing gone by.
However, it is necessary that you at the very least understand the nature of arrays, because understanding the nature of arrays allows you to do a lot more with strings, too. How so? Well, let's think about this for a second.
The first implementation of strings in general occurred in C. And even before the official implementation, there was a more or less standardized way of implementing strings that just didn't have a formal backing or library behind it.
Within C, there were various different data types, all serving different purposes. Some which spring to mind, for example, are the integer (written as int), the character (written as char), and the float (written the same). The character, or char, is the essential point of interest here.
The char data type represented one ASCII character. It could have been alphanumeric, a symbol, or even a blank space. The most important part was that it was just a character in general.
The early implementations of strings, prior to the standardization of a string library or any sort of go-to library as such, was to actually use an array of characters.
Since we know arrays are structurally similar to lists, we know that what this really means is that every string, so to speak, was actually a list (or, technically speaking, an array, but in actual usage and implementation they're the same, so "list" is a fine term to use) of different instances of the character data type.
What exactly does this mean? It means that strings are just glorified lists of characters. Which means that in C strings, you could break them down like that. Let's say that we had the string "hello world!". Since this was really an array of characters, a C programmer would have declared it like so:
​char message[12] = "hello world!"; 
And it would have actually laid out something like this in terms of the programming and the structure itself:
​message[12] 
​0​1​2​3​4​5​6              7              8              [...] 
​h​e​l​l​o​' '​w              o              r              [...] 
This is, again, because the implementation of the strings actually involved what was essentially just an array of characters.
In other words, a lot of the stuff that you may or may not already know about lists in terms of the way that they're structured or utilized can actually be carried over, more or less, to strings. This presents a lot of useful applications, as I'll get into momentarily.
String splicing 
Well, given what we just covered about strings, we can of course extrapolate that they're just glorified lists of characters. This makes certain things a lot easier. For example, when you start working with Python, it's really easy to miss the concept of "string splicing".  What is this? This is working with strings with the knowledge that they're just data sets. So taking this, what we can do is work with individual parts of the string.
Take the following example. Let's say we had a string called helloWorld which said "hello world!" and we wanted to print the second character from it. How would we do this?
​helloWorld = "hello world!" 
print helloWorld[1] # we want the second character, so we go to the second index position: 1
If we ran this, it would print "e".
So beyond that, we can actually construct more things. Let's say we had a string called b which contained the word blackjack. Using string splicing, we could construct new substrings, each with their own dedicated subset of the original word. Observe:
​b = "blackjack" 
​spl1 = b[1:5] 
What would this do? Well, since a string is just a list of characters, it would create a new string called spl1 with the relevant characters from the list index positions of 1 through 5 in the string b.
​So if string b looks like this:
​b​l​a​c​k​j​a              c              k 
​0​1​2​3​4​5​6              7              8 
We'd be getting the 1 through 5 index positions:
​b​l​a​c​k​j​a              c              k 
​0​1​2​3​4​5​6              7              8 
So our string spl1 would thus be "lackj".  There are numerous other ways to do this sort of string splicing too.
For example, look at the following:
​spl1 = b[-4:] 
Can you guess what this string declaration would do?
When you use a "-4" in the first position of a list declaration, it heads back to the third from last space. The blank on either side of the colon indicates to go either from the beginning (on the left) or to the end (on the right). So this would start at the fourth from last index and work its way to the end. So b[-4:] would look a lot like this:
​b​l​a​c​k​j​a              c              k 
​0​1​2​3​4​5​6              7              8 
So the resultant string of spl1 = b[-4:] would thus be "jack" - the last four letters of the string.
You can also do somewhat of the inverse.
​spl1 = b[4:]
This would start at the fifth index position and go to the end. You can tell this because the variable on the left side of the colon denotes the starting position and the variable on the right side indicates the ending position. Since there's no variable at all on the right side, we can thus extrapolate that we're supposed to go all the way to the end. So starting four characters in and going to the end, this string splicing would look like this:
​b​l​a​c​k​j​a              c              k 
​0​1​2​3​4​5​6              7              8 
String Methods 
Another huge part of working with strings is recognizing the all important string methods. However, it's really easy to miss these super important methods, or - even worse - it's possible to be taught them very poorly to where you don't understand at all how to use them. This isn't acceptable. What I'm going to do is walk you through a bunch a string methods that will help you to parse your strings much more efficiently and do things that you haven't even thought about.
The first and foremost method that we're going to talk about is the split method. What this split method does is serves you up a list of every word in the array. So if you had the sentence "I can't let you do that." then here's how it would splice:
​sent = "I can't let you do that." 
​spl = sent.split(' ') 
As a result, spl would turn out being a list of the words:
​0​​I 
​1​​can't 
​2​​let 
​3​​you 
​4​​do 
​5​​that. 
And calling up spl[1] would print out "can't".
Do you see what's happened here? The list has turned out to be a spliced version of the prior sentence where it's split at every word. This can be really useful when you're parsing input, especially through files. You can easily construct lists of objects by splitting a file containing parameters, for example. if you had a file like so:
​John,​555-012-3456, Carpenter 
​Sarah,​555-012-3457, Engineer 
​Brad,​555-012-3458, Architect 
And you had a Person class constructed by name, phone number, and occupation, then you could split this file into substrings which are then split by the ", " - the first segment of each list is the name, the second is the phone number, and the third is the career. As you parse this, you could use this data in order to construct a new instance of the Person object for each person's information that was imported through the file.
Another very important method to understand and remember is the replace method. What this method does is replace one string with another string. This can be super useful in various situations.
For example, if you were to create a new string variable called sentence with the value of "I'm doing well today.", you could then change it around by using the replace method.
​sentence = sentence.replace("well, poorly") 
The sentence then would change to "I'm doing poorly today". It's a super simple example, sure, but this could be very useful. For example, if you were reading through a file and you wanted to replace every instance of a typo that you realized you made quite often, you could run it through a Python script which changes every instance of that specific typo (let's say "Micihgan") to the fixed version. ("Michigan")
To take it even further, there are quite a bit of modifier methods that you'll find particularly useful, too. These are methods which transform the string of text in a given way. There are various different forms. Among these are upper() which will turn the whole string uppercase and lower() which will turn it all lowercase.
When might this be useful? Think of string validation. String comparisons are innately case sensitive in almost any programming language due to the way that strings are set up. Take, for example, the strings "Cats" and "cats". If you were to look at these in a mathematical sense, they wouldn't be similar at all. This is because the capital C and the lower case C respond to different ASCII characters, which means that their mathematical value for reference and comparison is technically lower.
The way to fix this is by making the strings match case. This can be done with the upper() and lower() methods very easily.
There are also a lot of boolean methods for strings that you might find yourself wanting to use. Take for example the startswith() method. You give this method a character, and it will then check the string to see if it begins with that character or not. There's also isalpha() which will check to see whether or not the string is entirely alphabetical, as well as isalnum() which will check to see if the string is alphanumeric and contains any special non alphanumeric characters.
There's one last gigantic method that we have to cover before we consider this chapter done: the strip() methods. These methods - strip(), lstrip(), and rstrip() - will take either a character which the programmer denotes (or whitespace, should the programmer not specify a given character for the method to strip) from one or both ends.
Why is this important? Well, being able to strip data is really important for the entire notion of stripping user input. For example, you don't want little "\n"s in your databases thanks to whitespace. But it's also super important and foundational to the idea of "input cleansing" which is a higher-end web development concept which is a little bit beyond the scope of this book, of course.







Chapter 3
Join a Community
The best tip I can ever give to a novice programmer is to get truly involved with it. This can manifest in a lot of ways. However, the foremost way to do such is to simply join a community that is as engrossed in programming as you are.
Do I mean real life communities or internet communities? Well, both. Or either. It doesn't really matter, it's up to you, your interests, and what opportunities are available to you at any given time. However, what I can tell you for certain is that this is absolutely necessary if you want to be a great programmer.
Why is this the case? Simply put, there's nothing more important to a programmer than the feedback process. No one programmer knows it all, and there will always - I repeat, always - be something that you don't know in the realm of programming, or a better way to do this or that thing that you don't know about. For most complicated code you'll ever write, there's somebody out there that can almost certainly trim it down by taking advantage of a function or method that you may not have even thought about.
So yes, you should join communities, both real life and online. However, I'm unable to really tell you how to join them in real life, because that's something that you've really got to feel out for yourself.
It's worth noting that a lot of even smaller communities will have various Python meetups, though. For example, if you go to http://meetups.com, you should see some events which may spark your interest. It, in a somewhat Orwellian way, automatically knows your location from your IP address and suggests some, and depending upon the size of your locale, you may or may not be able to find something.
Going to real life meetups for Python will help you in at least two ways.
The first way is that it will allow you to branch out. There will inevitably be topics covered on PowerPoint presentations and project screens that you've never really thought of. Depending on how "up" your group is in terms of technology, they may or may not cover recently created APIs or otherwise important developments in the language such as major programs that are written in the given language or either brand new or incremental versions of the given language.
The second way is that it will actually allow you to network. This is massively important in programming for the reasons mentioned before, but also because you'll inevitably meet like minded people within these groups. And something really brilliant happens when you meet like minded people: you start to think of ways that you can work together. The people you meet at Python meetings very well may be the people that you decide to work with on some project you (or they!) thought up.
There are inevitably more ways that it will help you, too. I'm not a psychologist, of course, I'm a programmer. But there has to be some sort of mental connection to productivity and passion with active validation of said passions. Getting to be around other programmers and talking about programming for an extended period of time will be one of the best things that you do for yourself, I guarantee it.
But anyhow, I said that I wasn't going to harp forever on meeting with programmers in real life, because it's beyond my grasp in writing this book. I don't know you or where you live, and so I can't really give you specific recommendations besides "find it yourself".
What I can give you recommendations on, however, are online communities that you can join in order to broaden your horizons with Python.
Just like real life organization, joining an online community can benefit you in multiple ways in terms of what you can actually do with Python.
The first way that it can help you is, as I've already said, the feedback loop which it provides. You'll be able to have people who are more experienced than you and well-versed in different areas than you are to look at your code and identify potential problems. And when you're learning, this can make a huge difference.
A second way that it could help you is that you'll inevitably see other people's problems, which will really open you up. The way that this works is that it will open you up to seeing the mistakes that others make which will, in theory, help to prevent you from making them yourself.
Indeed, seeing the mistakes which others make can be as big of a part of programming as anything else. It can give you ideas about how to better organize yourself and your code in terms of programming to make it more readable, for instance, after having a particularly bad experience with the terribly messy code of another person altogether.
But more than seeing other's mistakes, you'll also see other's accomplishments.  There are absolute savants with programming out there. There are people that can simplify extremely complex programs into just succinct little 5 line solutions using clever methods like regular expressions or things of that nature.
One of the best things that you can do for yourself is enable yourself by joining an online community. You're going to learn a lot both through the questions you ask, the questions that you don't ask, the questions you don't have to ask, the questions that others ask, the code snippets that others write, both good and bad, to be critiqued by other people within the community.
So where can you actually go in order to join a community? Well, there are, fortunately, quite a few!
First and foremost, I don't think it's really possible to understate the value of Stack Overflow. Stack Overflow, located at http://stackoverflow.com, is best defined as a question and answer site. It was originally written to deal with programming questions and answers - hence the name Stack Overflow, referring to the common computing ailment wherein a program tries to use more space than is available on the stack buffer - and fills its purpose very well. You're going to find this site a tremendous asset, I guarantee you that much. Having a specific place dedicated entirely to the purpose of asking questions when you're stuck or just confused in general will very much come in handy.
Signing up for Stack Overflow is actually extremely painless and easy, and I think that you'll find it to be so. The relative lack of time that it takes to create a count will absolutely be offset by the massive utility you'll find in it.
Then, there's the quintessential: IRC. IRC, or internet relay chat, is is a specific protocol used by computers in order to facilitate communication via the exchange of text. IRC has been around for some 30 years now, and in that time, it's grown a tremendous amount and has turned into one of the most classic and secure forms of communication on the internet.
However, recently, it's had a bit of a downturn in turn of general use. This is because a lot of other communities that were once relegated to IRC chats for constant communication and things of that nature were able to find alternatives that were more user friendly and easy to understand. However, this isn't to say that IRC chat is deprecated. Just simply that there are some purposes which it didn't serve very well that alternatives were formed for.
With that said, there are a huge number of programming groups that never completely detached from the IRC thing because they'd either grown to such a large size or become so established that it was rather pointless to try to move elsewhere.
This is true, no less, for the Python group. Available in channel "python" on irc.freenode.net. This community is often used just for general chat among Python programmers, as well as for things which specifically concern the language. People of all experience levels are invited into the chat to join and contribute and ask any questions that they may have. This is another place that you'll find yourself enabled to a great and consistent feedback loop.
Not sure how to join an IRC chat? Well, that's okay. The first thing you need to do is grab mIRC, if you're on Windows, or a similar client for your respective operating system if you're not. I'm only writing for Windows here in order to save time and space. All IRC clients offer the same functionality at their core. Anyhow, once you're done that, you need to connect to Freenode with the following command.
/server chat.freenode.net 
What we're going to do now is register our nickname so that we're not automatically put into the Python unregistered group. So what you do is type in your user name (or nickname). (Don't worry about this too much, you can always use the /nick command to change it later)
Next, you need to actually register it. Type the following command:
/msg nickserv register userPasswordHere userEmailAddressHere 
where userPassword and userEmailAddress are the respective password and email address that you wish to register the nickname to.
After you do that, you're going to need to verify the account. This is pretty straightforward. What you'll have to do is just go to your email account and look in your inbox for a verification code. Freenode will ask you to type into the server, so do so. After everything is said and done, you'll be pretty much good. Now, every time that you log in, you need to identify. What this does is tells the server that you're a registered user with the Freenode services and that you can be trusted. To do so, you just type the following command:
​/msg nickserv identity userNickname userPassword 
where "nickname" is the nickname that you registered with.
Don't like your nickname? That's okay! You can actually group another nickname to yours. Just switch to it using the command /nick nicknameHere and then type this:
​/msg nickserv group 
By the end of that, you have access to one of the most vibrant and thriving IRC channels, filled to the brim with astute Python programmers eager to help you develop.
The last community that we're going to talk about is the one over on reddit. It's impossible to overstate the sheer size of this community. As of the time of writing alone, the Python subreddit (the term for a secondary community on reddit - essentially a subforum) has 152,796 subscribers, or people that have joined up with it so that they will see its posts on the front page of their reddit account.
This community can be found at http://reddit.com/r/python. They have quite a strong user base with a ton of topics being written on things constantly. Joining reddit is a cinch. Near the top right, you should see something that says "log in or register". You're going to take the second option, of course. There also exist other communities. You may be interested as well in http://reddit.com/r/learnpython, called "Learn Python", if you're looking to actually learn and not just improve. There, you'll find a lot of useful tips and hints to learning Python, as well as a lot of direct help that you will certainly find very handy.







Chapter 4
Work on Open-Source Software
One of the best opportunities to budding programmers lies in the open source software movement. There are many different factors which make this such a great opportunity.
First, though, we're going to conquer the bigger topic at hand: what exactly is open source software? Open source software is the notion of writing software that is not only free but where the source is completely and freely available to any programmers that are aspiring to read it, contribute to it, or branch off of it.
What does this mean for you? Well, quite a bit actually. The first and foremost thing that it means for you is that you can find a wealth of already developed Python programs that are available for you to look at. Often, due to their public nature, they'll be well documented and well commented too. What this means for you is that as you work your way through the code trying to understand what does what, you'll often have comments to the side explaining what code does. This can be great for understanding core functions of a heavily used API, for example, or even just understanding the logic which other programmers work with and use on a daily basis.
Additionally, it means that you can aspire to build onto a given program if you'd like. A great number of these projects will often need somebody to add on to them and fix bugs. In fact, that whole idea that people will do such is a major reason that people opt to create open source programs in the first place.
Another really cool thing that you can do with open source programs is actually create "spin-off" programs, or programs for either your personal use or for the programming community at large that are based on the code of an open source software. Note that by the nature of open source software this should generally be allowed, but some people may specifically disallow the creation of spin off programs of their software as part of a licensing agreement to accessing the open source software. Also, if you're going to publicly claim that the software is anything but somebody else's, then you should have created very specific and concrete changes to the software to justify doing such. What's more, as a general unspoken rule of open source etiquette, you generally should generally credit the original programmers and developers in any branching projects that you may have a hand in.
There are a great number of open source Python projects that you can get started with cracking open and trying to understand right now. Among these are the likes of an open source Minecraft clone (a great starting point because it lets you see the results of your actions immediately), a script for downloading YouTube videos called youtube-dl, and the super popular web framework Django. I'll give a brief summary of all of these.
It's worth noting that you can browse quite a few open source Python projects yourself over at GitHub by heading to https://github.com/trending/python. Here you'll be able to find a laundry list of trending open source Python projects that you can dive on. Some of them are super neat, too - there are things like EEG (brain wave) controlled versions of Mario Kart!
Anyhow, I mentioned three specifically, each for their own reasons, and I'll be getting into why you should read and build onto these projects now.
The first one is an open source Minecraft clone, that can be found at https://github.com/fogleman/Minecraft. The reason that I recommend picking up this one is because you can work through it and read it and understand it incredibly easily. You'll pick up, firstly, a lot of important concepts about games programming in general, as well as programming at large. However, there's one more major reason you should start with this: instant gratification.
Instant gratification is fantastic, let's not lie to ourselves. When you work with the Minecraft clone started by developed fogleman, you'll be able to instantly see what happens because of the actions that you take. If you edit the texture.png, you'll see the new textures spring up in the game. You can easily develop new blocks and special block physics. There's just honestly a whole wealth of things that you're enabled to do by working with this project. You can build onto a really popular game and maybe even make it your own if you're so inclined. You've been given a blank canvas of a voxel engine that you can really easily build upon to do whatever you'd like to do, and I'd behoove you to do so.
Next is the script for downloading YouTube videos to your computer, created by developed rg3 over on GitHub at https://github.com/rg3/youtube-dl. This too is a monumentally useful program to learn how to use and develop on. This is for one simple reason: learning exactly what's going on under the hood in this program will make you into an absolute web scraping machine.
Over the course of your exploring the youtube-dl code, you'll discover a lot of conventions and really great ways to do things such as scrape web content and parse HTML files. This is incredibly useful to anybody within the context of a web-based world where everything is taking place on the internet. This script as an introductory course to web parsing and "grabbing" things on the internet will serve you well over the course of your working with it, because you're going to find a great many times where you'll have an idea that you'd like to carry out but that you frankly can't because you've got no idea really how to do things such as web scraping.
The last one that we're going to cover in the context of all of this is the massively useful open source web framework Django, started by the Django's project development team and available over on GitHub at https://github.com/django/django. Reading through this source code is immensely useful in a huge manner of ways. The first and foremost is that reading through this source code will, of course, acquaint you with Django and all that it can do in general. As you read, you'll discover a hugely useful framework for fast web development. This very well may come in handy with other projects that you need to carry out, and you may find yourself using it at another point in time.
On top of that, you are likely to find yourself picking up some good habits. This is a huge and super well maintained codebase. There's not a chance that you're going to make it all the way through this and then find yourself confused about where to go. There will be a lot of things that you'll learn from this very code base that you had no idea about. You may be inspired to work on a website or to add to this or to learn to develop in general. Regardless of what happens, you'll be left with a lot more knowledge than you had before, and likely a lot of inspiration to boot.
Basically, the point I'm trying to get across is that there is a ton of reference material in terms to open source projects, as well as a lot of started projects that you can very easily build upon. Not to mention that you get definite karma points for helping a fledgling and well-intentioned project get off its feet and get its bugs sorted out.







Chapter 5
Program Out of Your Comfort Zone
Often, our jobs or hobbies will force us into programming in a certain way or certain area all the time. When this sort of stagnation happens - not only in programming but in any realm of activity that you may be involved with - you'll find that it can be terribly difficult and arduous to actually grow as a programmer. And I wouldn't say that it'd be too far off to say that this is because you aren't. Stagnation is the bane of anybody who is actively trying to develop themselves, and should be actively avoided at all costs. In many circles and professions, this sort of stagnation is simply referred to as a "rut".
One really simple way that you can program out of your comfort zone is by completely changing genres in your personal programming. There are techniques and ideas which are used in the various realms of programming, such that you may never encounter them in one but that they may be very prevalent in another. There are a great many things which occur in game programming, for example, that won't occur in other types of programming.
The thing which happens for you when you decide to program out of your comfort zone is that you start working with different APIs and, more importantly, different people who think, well, differently. Programming is a science, yes, nobody would dare say that it's not. But it's one of the few sciences that's also very much an art. One's ability to program is indicated by one's ability to think outside the box. Fostering this ability to think outside the box is foundational to being a great programmer that people will look up to.
I'm going to use here the example of game programming because it's actually the example which I know best. If you wanted to program outside your comfort zone and, for example, learn to program video games in your spare time, you could do so very easily. This is because Python is so popular that you can actually rely on the fact that there are a huge number of APIs out there for anything that you want to do. Indeed, learning to program outside of your comfort zone in Python will enable you to do a lot of things you wouldn't otherwise even really think of doing. There will, too, be a lot of causes where you can't think of a way to do something because you're rigidly stuck within a certain manner of programming and thinking. Programming in multiple different "disciplines" will help you to get over this a lot.
When it comes to Python game programming engines, for example, there is a lot of video and audio support built in to the APIs that would make Python game programming APIs the actual go-to for a lot of multimedia things, where in other cases you wouldn't quite think to use them in that manner. Take, to illustrate, the game programming library PyGame. This is a huge add-on to Python which adds a ton of support for a lot of multimedia extensions using the open source OpenGL and OpenAL. It serves to make the programming process super quick and easy.
Game programming, also, will help you a lot on your geometry due to the nature of things like generation, display, and collision detection. This may help you when you're trying to do things like model data or something of the like within the data examination discipline.
All in all, this isn't a very long chapter, but it's one of the most pertinent: the most important thing that you can do for yourself as a programmer is learn to program in multiple different ways.







Chapter 6
Test Yourself with Daily Challenges
There's little that you can do better for yourself than challenge yourself. Much like a muscle will only grow when it is strained, your ability to program and do anything in general that requires a great deal of cognitive ability and proper thinking in a critical manner will only grow when you test it in the best manner that you can.
Fortunately, there is one really great infrastructure for programming challenges such that you don't have to come up with them all on your own. Remember the reddit site we talked about in the third chapter? Well, it's actually on there. It's called Daily Programmer and it's available at http://reddit.com/r/dailyprogrammer.
This isn't specifically a Python trick, but the vast majority, if not the entirety, of the challenges presented can be performed in Python. The entire goal of the challenges and the philosophy behind their creation is that they're a test of your problem solving ability, not of your ability to worm your way around with this programming language or that programming language. So in that capacity, what it really provides is an excellent way for you to grow as a thinker in general.
And that capacity to think and problem solve effectively is absolutely monumental to you becoming a better programmer. At the end of the day, programming is one-hundred percent purely a reflection of your knowledge of computers, math, and logic, as well as your ability to solve problems with the knowledge that you have. Saying anything else is frankly unfair and somewhat untrue.
The really neat thing about this community is that it sorts the challenges by perceived difficulty. This is great in that it allows you to do only the challenges that you feel most comfortable doing. You don't have to bend over backwards trying to solve a challenge if you don't feel comfortable doing one at that skill level.
The other great thing about this community is that it's still updated from time to time. Not as frequently or "daily" as it once was, but over the tenure of its existence - in its rise from 1 sole programmer to 105,488 programmers - it's developed into a community with an absurd amount of different programming challenges on it. Enough to keep you busy and pretty much never bored for a very long time. Judging by the fact that as of the time of writing, we're on challenge number 301, multiply 301 by three for the number of difficulty levels, and there are at least about 900 days worth of challenges for you to do, or about two and a half years. And by the time you've somehow finished all of those, there will only be more.
And what's better is that even if you try and get stumped, the nature of reddit as a post and response community is that the answers to the challenges are in the comments. If you get absolutely stumped and just can't figure out what to write or do for a challenge, the answers are right there for you to learn from.
This also has the added benefit that you'll learn a lot of new algorithms and ways of doing things that you wouldn't have thought of otherwise, most likely. That's not to say that you concretely would not have, but just that it's most likely that you wouldn't have. There is no one way to solve a lot of these problems. They tend to seek a certain end, but the way that you achieve this end specifically will reflect upon your ability to write concise and expert Python. And that's your goal, after all, no? Writing concise and expert Python code that's worthy of winning a contest?
The brain is a muscle, full stop. The only way that you're going to grow that muscle is by flexing it and constantly striving to be a better programmer than you are right now, right now here meaning of course how good of a programmer you are at any given moment and thus the "right now" of that given moment.
Thus, one of the best things that you can ever do for yourself, and the best tip that I could ever give you, is the ability to flex your brain muscle.
Here's a really easy example of a daily challenge, most of them will be far more difficult than this but this is just a little example of the kind of stuff you'd be working with.
The first one we're going to start with is a simple to-do list. All this does is keep track of things that you need to do. Your to-do list should be made up of a bunch of strings organized in a list. You can add or delete from the to-do list.
The first thing that you're going to do is create your primary functions for adding and deleting items from the list. You should already know how to do this, I'm just going to demonstrate how I did it.
First, we create a function to add items, which takes the argument of the given list.
​def addEvent(list): 
​list.append(raw_input("Enter the event that needs to be added.\n")) 
Super simple. Now all we need to do is create a function for removing an item from the list. What we need here is to print the current events on the list, alongside a corresponding number for the user to enter to delete the given item. After that, we just need the logic for removing that item from the master list. We're going to thus create a function called deleteEvent which takes an argument of list.
​def deleteEvent(list): 
​for i in range(len(list)): 
​print "%d: %s" % ((i + 1), list[i])) 
userinput = raw_input("Enter the number you'd like to delete, or anything else to exit.")
if userinput.isdigit(): 
​inp = int(userinput) 
​if inp > len(list): 
​"That number is invalid. Returning to main program." 
​return 
​else: 
​del list[inp - 1] # adjusting for index 
​return 
else: 
​return 
Pretty simple, no? What we're going is letting the user input a number, casting it to an int if it's a digit, checking if the list even has that number, and removing it from the list as the user specified.
Now what we're going to do is create a viewList() function. This just takes a variable of list and it's a rehash of the first part of the deleteEvent function.
def viewList(list): 
​print "Current list:\n\n\n" 
for i in range(len(list)): 
​print "%d: %s" % ((i+1), list[i]) 
Now we implement the main loop. What this is is basically what's referred to a game loop. What a game loop basically is is implementing a variable and running the loop for as long as the user hasn't issued a certain command or a certain condition hasn't been met. (Sometimes both!)
So here's where we're going to write the main chunk of our code. We're going to need a variable called running and implement the game loop through a while loop. The program will work by asking what the user wants to do, giving options of "ADD", "DELETE", "VIEW", and "EXIT". The program will terminate if the user is to enter "EXIT". Otherwise, it will ask what the user wants to enter again.
​running = true 
​list = [] 
​while (running) 
​print "Welcome to the to-do list. Would you like to:\n\n" 
​print "ADD something to the list," 
​print "DELETE something from the list," 
​print "VIEW the list," 
​print "or EXIT the program?" 
​userinput = raw_input("Enter your choice.\n\n").tolower() 
​if (userinput == "add"): 
​addEvent(list) 
​elif (userinput == "delete"): 
​deleteEvent(list) 
​elif (userinput == "view"): 
​viewList(list) 
​elif (userinput == "exit"): 
​running = false 
​else: 
​print "That's not a valid option. Try again.\n" 
My end result looked a lot like this.
​def addEvent(list): 
​list.append(raw_input("Enter the event that needs to be added.\n")) 
​def deleteEvent(list): 
​for i in range(len(list)): 
​print "%d: %s" % ((i + 1), list[i])) 
userinput = raw_input("Enter the number you'd like to delete, or anything else to exit.")
if userinput.isdigit(): 
​inp = int(userinput) 
​if inp > len(list): 
​"That number is invalid. Returning to main program." 
​return 
​else: 
​del list[inp - 1] # adjusting for index 
​return 
else: 
​return 
def viewList(list): 
​print "Current list:\n\n\n" 
for i in range(len(list)): 
​print "%d: %s" % ((i+1), list[i]) 
​running = true 
​list = [] 
​while (running) 
​print "Welcome to the to-do list. Would you like to:\n\n" 
​print "ADD something to the list," 
​print "DELETE something from the list," 
​print "VIEW the list," 
​print "or EXIT the program?" 
​userinput = raw_input("Enter your choice.\n\n").tolower() 
​if (userinput == "add"): 
​addEvent(list) 
​elif (userinput == "delete"): 
​deleteEvent(list) 
​elif (userinput == "view"): 
​viewList(list) 
​elif (userinput == "exit"): 
​running = false 
​else: 
​print "That's not a valid option. Try again.\n" 
There we go. Pretty simple, but not a terribly difficult challenge to start with. A lot of the challenges won't be anywhere near this easy, and in fact they're divided into difficulty levels. The easy ones will be about this level and probably a little harder, too. But again, this is just an example.







Conclusion
Thank for making it through to the end of Python Tips and Tricks: Learn the Best Tips and Tricks to Get the Most Out of Python Now!, let's hope it was informative and able to provide you with all of the tools you need to achieve your goals whatever it may be.
The next step is to go beyond this book. I've given you a lot of tools and tricks within this book, some of them very concrete and some of them very abstract, some of them full-fledged lessons and some of them just scraping the very essence of the topic, but it doesn't matter what level of detail I went into if you don't use the information I've given you. I can give you all the tips in the world but if you aren't proactive about using them, then you won't be very good at it.
Programming is a lot like language learning. You can be a very solid speaker of a language by acting minimally, sure. But it's only by devoting yourself to a language and immersing yourself in it that you'll be able to be hang with the best in terms of your ability to speak that language.
Programming is no different. If you aren't proactive, if you don't get involved in online and real life communities and try your best to program as much as you can in as many new ways as you can find, then you're going to plateau, and you're going to plateau very, very hard. I've given you tips and tricks to prevent you from doing exactly this, and if you push yourself and keep going with it, then you'll be on the road to being the best Python programmer that you can absolutely be.
In other words, you will get exactly what you give when it comes to Python. If you give a lot of effort to it and work very hard towards becoming a better programmer, you'll become a better programmer. But this isn't going to happen without direct action by you.
I sincerely hope that this book has helped you to find your voice with Python and find a few solutions to help you progress within the language itself. Maybe it helped you find a way to connect to other programmers, and maybe it helped you realize some of the sheer utility of the list and string objects. Maybe I sparked your interest to start programming video games. Regardless of what I did, at the end of the day, what I hope more than anything is that I've written a book which will help you to be the absolute best programmer that you can be and progress upwards constantly in your journey to be a better Python programmer.
Finally, if you found this book useful in anyway, a review on Amazon is always appreciated!  








Python Strategies

Bold Strategies to Go From a Newbie to a Pro 
DANIEL JONES







Introduction
The following chapters will discuss exactly what the title outlined: ideas and strategies to help you go from a beginning Python programmer to a great one. In other words, to fault my own writing with a terrible pun: I'm going to help you put the pro in programmer.
There are a lot of reasons that you might want to learn Python. Maybe you want to be the next great indie game developer. Maybe you're doing it for your career, so you can progress within it. Maybe you're wanting to do it as a future career and just looking for a place to start. And maybe you're just wanting to do it for fun. Regardless of your intentions, I can tell you that by the end of this book, you'll most certainly be able to do whatever it is that you're aspiring to do.
Before you do anything else, though, you need to get into the programmer mindset. Programmers are creative individuals who also love the idea of taking something apart, figuring out how it works, and then putting it back together. Programmers love to tinker, and there's little they love more than problem solving.
So I guess that what I'm saying is that we're in for a long road in this book. Turn on some music that inspires you and get buckled and ready for what will inevitably be the bumpy and frustrating road of learning to program. The sad thing is that there's not a book in the world which could make learning programming not bumpy and frustrating. But there are books that can help you deal with that, and in my humble opinion, this book is just the one.
There are plenty of books on this subject on the market, thanks again for choosing this one! Every effort was made to ensure it is full of as much useful information as possible, please enjoy!







Chapter 1
Become a Hacker
I'm assuming that you're a new programmer in this book, of course. If you aren't, then you can skip past this chapter. This chapter will most likely be one of the lengthiest in the book, and I'd just like to say that much in advance. If you want to do anything with Python, you have to know at the very least how to get around it. In this chapter, I'm going to be covering very cursory explanations of introductory concepts which will help you to get off your feet in terms of Python. By the end of this chapter, you'll feel at the very least confident in your ability to do basic operations in the language.
So Python. Learning the language is a big undertaking, and I commend you for even starting. When I'm trying to teach someone to work with Python, I usually do so by giving long and detailed explanations of everything that I'm doing. Frankly, though, this book isn't about learning Python, so I'm not going to spend too much time covering every last banality. The first thing that you need to do is grab a text editor. The one at http://atom.io called Atom will do great. The next thing that you need to do is grab Python. Head to Python.org and grab the latest copy of Python 2.7. There's a reason you're not getting Python 3: most code out there is written specifically for Python 2. You're wanting to learn how to work with the most code, not the most bleeding edge code, and for that, you'll need Python 2. If you decide you want to work with Python 3 in the future, that's totally on you, and the process will be relatively simple. But my job is to teach you how to become good, and you become good by being able to work with as much code as is possible.
Anyhow, once you have everything set up, you need to create a new folder called code on your desktop. Then open your command line. If you're on Linux or Mac, this will be called Terminal. If you're on Windows, this will be called PowerShell. Once everything's done, you're going to navigate to your desktop in your command line. I'm not sure how it's set up for you personally, it depends upon your operating system, but just find a way to do it. In Windows, at least, you can type "cd desktop" from the command line's launch screen and be there nearly instantly. Anyway, once you're there, type the following command:
​mkdir coding 
You just made a directory called "coding". You can really name it whatever you want (and "coding" is a tad juvenile anyway), but this is the simplest way for now. After that, what you want to do is navigate to that directory:
​cd coding 
Now, you're where you need to be.
Go ahead and open up your text editor and type the following:
​print "hello world" 
Then save the file as hello.py and head to your command line. Type the following command:
​python hello.py 
And watch what happens. It should print out "hello world" to the console. How neat is that? Well, now we're going to deal with other major concepts of the language in a very short amount of time, so just saddle in for what will be a very brisk journey through a lot of proverbial wilderness.
Variables 
Variables are central to Python and programming in general. What a variable is, simply put, is a way to store a value. For example, variables can store numbers:
​oranges = 7 
And they can also store text, known as strings:
​message = "How is it going?" 
They can store whether something is true or false:
​hasARideHome = False 
and they can also store decimal numbers, called floats:
​bodyTemperature = 98.6 
You can modify variables, using math. You'd do this like so:
​oranges = oranges + 1​​# would add 1 to "oranges", making it 8 
Point is, variables are a way to store a given value, and they can always change. You can't change between types, though. Well, you can, but we'll get to that in a second. Let's say we had a string variable called "var1" which had the value of "3", and a number variable called "var2" which had the value of 3.
​var1 = "3" 
​var2 = 3 
var2 represents the actual numeric value 3, where var1 represents the ASCII character 3. Basically, var1 represents a symbol, where var2 represents a number. So you couldn't add the number 8 to var1, but you could to var2.
​var1 += 8​​# would not work : "3" and 8 can't be added 
​var2 += 8​​# would work : 3 + 8 = 11, var2 is now 11 
Do you get the gist of what I'm getting at here? So that's the crash course on variables.
Expressions 
Do you remember how things can be less than or greater than something else? And evaluating those with the respective relevant signs? Well, those are expressions. And they mean something, right?
Take for example the expression 3 < 7, or "3 is greater than 7". This means something, no? It means 3 is greater than 7, and the expression evaluates to true. This is important, remember that concept of expressions evaluating to be true or false, it's going to come in handy momentarily.
There are a lot of different ways in which you can form mathematical expressions in Python. The key thing to remember is that mathematical expressions are just a way of comparing two values. So for this, there are the expression operators which are intended to help you carry out the comparison of two values: greater than (>), less than (<), greater than or equal to (>=), less than or equal to (<=), equal to (==), and not equal to (!=). These are the ones that you need to remember.
So knowing they can evaluate to true or false, let's work with a few examples:
​3 == 5​​# would be false, 3 is not equal to 5 
​3 != 6​​# would be true, 3 is not equal to 6 
​3 >= 3​​# would be true, 3 is greater than or equal to 3 
​3 <= 6​​# would be true, 3 is less than or equal to 6 
​3 > 7​​# would be false, 3 is not greater than 7 
​3 < 2​​# would be false, 3 is not less than 2 
If statements 
If statements mark the beginning of a huge part of your programming career: learning about logic. Logic defines and guides every single program you will ever write and it defines even the manner in which programs run. There's all kind of logic going on behind the scenes of a program even if you don't happen to see it, too. So what do if statements do? Well, they have this basic structure:
​if (condition) is true, { 
​then execute this code. 
​} 
The condition could be anything that can be true or false. This could mean that the condition could be a raw boolean value, like so:
bananas = True 
if bananas { (implicitly says "if bananas is true" without an equation)
​then run this code 
} 
Or it could be an expression, like this:
if 3 > 6 { (the code wouldn't run, 3 is not greater than 6) 
​then run this code 
} 
Or it could even be a method which returns a true or false value. Regardless of what it is exactly, the point is that if statements are structured to evaluate a condition and act in a certain way if it's true. Here's how if statements are structured in Python:
​if condition: 
​# code here, INDENTED! 
​So an example of this code would be: 
​if bodyTemp > 98.6: 
​print "You have a fever." 
This is what I like to call a potential conditional. There's a chance that a chunk of code could be run, given that the condition is met. So if the body temperature were to be greater than 98.6, it would print "you have a fever". If the body temperature weren't, nothing would happen. But what if we want something to happen regardless of whether the condition is met? That's what I like to call an absolute conditional, and that's where the next part comes in handy: else statements.
Else statements make the perfect comparison to the if statement. The if statement branch of the code will check to see if a condition is true and launch certain code if it isn't. The else statement will be your catch all and safety net in this whole equation: if the condition isn't true, then the else statement will launch.
Here's how we'd set up an else statement corresponding to the previous chunk of code:
if bodyTemp > 98.6: 
​print "You have a fever." 
else: 
​print "You don't have a fever." 
So no matter what happens, the program would either print "You have a fever." or "You don't have a fever." depending upon the necessary conditions at the time. There are applications for both potential conditionals and absolute conditionals and you'll learn those applications as you work with either concept more and get more experience overall in the world of Python programming.
So what if we have multiple conditions that we want to test? This is where else-if statements come in handy. These are conditions that are evaluated after the primary if statement if the primary if statement turns out not to be true, but they are evaluated before the else statement so that if the else-if statement is true, the else statement doesn't launch at all. Observe the following code:
​if bodyTemp > 98.6 and bodyTemp < 102: 
​print "You have a low fever. Get some rest, you probably are fighting an infection or illness." 
​elif bodyTemp >= 102: 
​print "You have a high fever. Go see a doctor, there could be a serious problem." 
​else: 
​print "You don't have a fever." 
This program will actually evaluate the user's fever and give them an appropriate response. Let's say this user's temperature was 103. Well, the first if statement would look at it and say "well, the body temp is greater than 98.6, but it isn't less than 102. It fails." and it would send it to the next statement, which checks to see if the temperature is greater than or equal to 102. It would pass this test, so the second condition would be the one which is met and the resultant text would be output to the screen.
Did you notice on the first condition how we evaluated two conditions? This is done using something called a conditional operator.
Conditional operators 
There are three conditional operators that you need to know: and, or, and not. These all serve their own purposes and function rather similarly. They're used to change the way that an if statement parses the logic of the condition.
The and operator checks to see if both conditions are true. So if I had 5 bananas and the condition was like this:
​if bananas <= 4 and bananas != 1: 
​# code here 
Then the condition would be failed, because I have 5 bananas. 5 is not less than or equal to 4. So even though the right side of the condition is correct (5 != 1), the left side is not, and thus the whole thing fails.
The or operator, however, just checks to see if either condition is true. So if we took the same scenario and looked at this chunk of code to see how it functioned, we'd see a different outcome:
​if bananas <= 4 or bananas != 1: 
​# code here 
The code would actually evaluate to true, because even though the left side of the condition is not true (5 <= 4), the right side is indeed true (5 != 1), and only one side needs to be true in the context of the or conditional operator.
not is the last one, and it functions a little weirdly, but in a very easy to understand matter. It just inverts the condition and checks to see if it's false and will only execute if the condition turns out to be false. So if I had 5 bananas, and ran into the following if statement:
​if not bananas <= 4: 
​# code here 
​The code would indeed execute, because the if statement is checking to see if the bananas are NOT less than or equal to four. Do you see what's going on here?
Lists 
In both Python and in life, there will be times where you really need to group related information. This is really obvious sometimes. But how do you do it? For example, if you were going to go grocery shopping, you wouldn't cut the piece of paper into tiny strips of paper according to the lines on the page and then try to keep up with all of the little strips. No, that's silly. What you'd do instead is just keep them all on one page of course. It'd be far more efficient to just do that. So why on earth would you create multiple little grocery variables for each and every item on your list? It doesn't make any sense.
So now the question is how exactly do you create what is the equivalent of "one piece of paper" in Python? And the answer is quite simple: with lists.
Lists are really easy to set up, you can either declare them as empty lists, like this:
​groceryList = [] 
​Or you can declare them with items, like this: 
​groceryList = ["apples", "paper towels", "grape juice", "chicken"] 
​You can add items to the list super easily by using the append() method.. 
​groceryList.append("cabbage") 
You can reference items from the list by referring to their index location. Python is a programming language, which means it talks to the computer, and computers are weird, so the count actually starts from zero. This means that the first item in the list would be at index location zero. So if we did this:
​print groceryList[0] 
​It would print "apples", which is the first item in the list. 
Items can also be really easily removed from lists by way of the del keyword. When you delete an item from a list, everything else will shift back in its place, and it's a really simple way to get rid of items from the list. Let's say we found an old stash of paper towels at home and realized we didn't need them. We'd need to remove the second item from the list, so we'd be removing index position one.
​del groceryList[1] 
Everything after paper towels in the list would now be shifted back an index position, so that grape juice is now at position one rather than position two, chicken is at position two rather than position three, and so on.
Loops 
There are two main kinds of loops in Python. Both of them serve different purposes but they also both will be absolutely instrumental to you going forward in Python. These loops are what will make or break you and will absolutely constitute the vast majority of the logic for any given program that you write. Most of the programs that you will ever write will be controlled by a loop in one way or another, and they're simply put the most effective way to introduce logic and control flow into your programming.
The first kind of loop is the while loop. The while loop basically says "hey, I'm going to run for as long as x condition is true. When it stops being true, I'll quit running." The basic structure for a while loop in Python is like this:
​while condition: 
​# code to run 
Here's how you would code a loop which counts from 1 to 5 in Python using the while loop.
​a = 1 
​while a <= 5: 
​print a 
​a += 1 
What this loop does is say "while the variable a is less than or equal to 5, I'm going to print out the value of a and then increase a by a factor of one."
While loops are really simple to grasp. Their main function comes about when you start to work with game loops. What game loops basically are is a loop which runs while a boolean condition such as running or hasExited is true. For as long as this variable is true, the program will loop over and over. The variable is made false from within the loop by a given condition, such as the user entering "exit" or pressing "quit" or hitting 0 health. Don't be confused, though, this kind of loop isn't solely reserved for games. Any program which loops over itself for as long as the user has logic to enter will function based on a game loop.
There are also for loops. For loops are intended for one purpose alone: iteration. For loops in Python are really cool because they actually make iteration through a list or list-type object like File objects super easy for the programmer to work with.
Here's the basic syntax for the Python for loop:
​for iteratorVariable in iteratedList: 
​# code goes here 
Let's take the groceryList list from earlier. If we wanted to loop through it and print off every item on the list, here's the syntax for it:
​for i in groceryList: 
​print i 
It's super simple but, then again, it's not really supposed to be complicated. The preceding code would print out this:
​apples 
​grape juice 
​chicken 
​cabbage 
Methods 
It's impossible to really write a proper introductory crash course on Python and somehow leave out the all-important notion of methods. Methods are prolific. Methods are important. Methods make up the vast majority of Python code and code in general, and they're what makes it possible for code to be reused and for simple functions like list.append() to be possible. It's of the utmost importance that you understand what methods are and how they're applied within the world of programming.
What a method basically is is a chunk of code which can be called from other places within the program as many times as you wish. You can choose to send arguments to the method, if you wish, or you can opt to not send arguments to it. Arguments are basically values that are sent to the method for it to manipulate and change however you'd like for it to do so.
Here's the barest way that methods are structured in C-style languages:
​data-type function(arguments) { 
​code goes here 
​} 
"Data types" aren't expressed in Python methods, though, since Python has implicit data types and not explicit data types. Data types in the context of methods refers to the data type that the method returns. Methods can return values, should you want them to, which basically means that they'll give a value back. This means that you can actually assign a variable the end result of a function. This is why you can use the raw_input() method to get user input and save the result directly to a variable: when you use the raw_input() method, the user is prompted to enter a string. The raw_input() method returns the value of this string, which means that you can save the value it gets back directly to a variable, like so:
​userInput = raw_input("When is your birthday?") 
​# if the user entered "May", then the raw_input() method 
​# would return "May" as its value. userInput would take 
​# whatever the return value of raw_input() was as its 
​# own value. The value of userInput would thus be 
​# "May". 
​userInput == May 
​# would print True. 
So how do we set up a method in Python? It's rather simple, actually, as are most things in Python. This is the structure for methods in Python:
​def function(arguments): 
​# code goes here, again INDENTED 
As an aside, it's imperative that you pay super close attention to Python's indention practices. Other C-style languages don't both too much with indention; they see whitespace as an organizational tool. Python sees whitespace as an organizational tool, as well, but turns that idea on its head a bit. Indentions are thus used in Python mainly for the purposes of denoting hierarchy. Indentations can tell you where a loop begins and ends or where a function starts and ends, and makes invalid the pesky brackets of other C-style languages. It makes Python look far more pragmatic and cleaner, and makes the code itself a lot easier to read at times. There is no good or bad way, here, it's all a stylistic preference, and Python's stylistic preference is that indentions matter. SO pay attention there.
So let's say that we wanted to write a method which took an argument of a string to print multiple times, and the number of times to print that string. It would then print the string according to how many times the user specified to print said string. Here's how we'd do it.
​First, we'd set up the basic method itself: 
​def loopString(userString, numberLoops): 
​Then we'd create a for loop which would loop the number of times that the programmer specified: 
​for i in range(numberLoops): 
​# the range() method creates something for the for loop 
​# to iterate through, with as many iteration sequences as 
​# its argument specifies; if the user said numberLoops was 5, 
​# the loop would iterate through range(5), so it would loop 5 times. 
​Next we just have to write the print statement for the string. 
​print userString 
​And voila, you're done. The method ends up looking like this: 
​def loopString(userString, numberLoops): 
​for i in range(numberLoops): 
​print userString 
That makes up the bulk of the heaviest Python topics for you to learn as a beginner, but that doesn't mean there isn't more for you to learn. For example, to be an able Python programmer, you'll really want to learn about things like file input and output and object oriented programming, just two things which are absolutely vital to any able Python programmer's arsenal.







Chapter 2
Figure Out What You Like
This may seem like a no-brainer, but we operate a lot quicker and a lot more efficiently when we're learning about or talking about or doing something that we like. It's just the way that we work. And this may seem like a bit of a broad explanation; that's because it is. But one of the most effective strategies in learning Python will always be figuring out exactly what it is that you like.
You may or may not be learning Python for something that you wouldn't otherwise learn it for, like a class or a job. In that case, I'm extremely flattered that you picked up this book in order to learn how to branch out with the language and do great things. But also, I've got to ask - why force yourself to learn in a way that you don't want to learn?
This seems like a no-brainer, but you'd be surprised how many people don't realize it: you only learn something, like really honestly learn something, when you care to some capacity about what you're doing. Otherwise, you may be blindly reciting words from a mouth or code onto a screen, but it has no meaning and no nuance behind it - it's just rote memorization of basic terms and nauseatingly numerous different ways of doing things.
If you find a way to care about what you're doing this, it makes working with Python a whole lot easier altogether. Your mind will forge connections far, far better.
When I was younger, all I wanted to be was a game programmer. Genuinely. As I grew up, I got into programming - I actually started in my early teens - and I got it, but I didn't get it. It wasn't until I started working with Microsoft XNA Game Studio in C# back when it was still relevant that I began to actually stomach and memorize a lot of the concepts. Before I started messing around with game programming, I did a lot of basic things - C++ from a book, learning the essentials of this and that, STL templates like vectors and sets, the whole nine yards. But when it came down to the wire, I didn't really understand a lot of it. The mental connections only started to be forged when I began to actually work with something I cared about, that something being the world of video games. It was working with C# in XNA that I began to understand key concepts like the behemoth of object oriented programming and the numerous keywords like virtual and override and protected that you, for the most part, don't have to worry about in Python. I didn't learn about the concept of lists (which are harder in C# and Java, I promise) and iterators and for each loops from a book; no, rather, I learned them from a marathon run of YouTube tutorials while I learned how to create an ammo system for a video game gun. That simple.
So you can learn concepts from a book, but you begin to realize how they're applied when you learn them in a context that you care about. That's when things really start to click the most. Passion begets intelligence one hundred percent of the time if you use the passion in the right way.
So where from here? Find something you like. If you've always enjoyed tinkering on the web or playing around with HTML and CSS, you might enjoy playing with Python frameworks like Django, Pyramid, and Flask. You'll learn a lot of concepts about web development as you go.
Or maybe if you're like I am and you really enjoy the idea of making games and perhaps have even done so in programs like Game Maker or RPG Maker, then you should look towards the libraries like PyGame, Pyglet, and PyOpenGL (though the PyOpenGL will be really low-level and likely confusing), or the libraries which are higher-level and based off of them such as Game Engine, Ren'Py, Cocos2D, and Arcade. I'll say that game programming teaches you a ton of concepts like geometry and extreme critical thinking along the way, perhaps moreso than other forms of programming. If you think that it will be easy, then frankly, you're wrong and it won't be. But it will also be extremely rewarding for the amount of work that you do decide to put into it.
Maybe you really like data and visualizing data? I think you'd benefit greatly from looking into matplotlib and working with it!
Python is so huge and so prolific that there really is a manner of programming for every single niche on it. It'd be silly of you to allow yourself to learn it in a way that you don't care about when there are so many better ways to learn this dynamic, extensible, portable, and all-around fun language that you in the end would care about.







Chapter 3
Join Up with Communities
There's one strategy which is absolutely foolproof: getting yourself out there. And I don't even necessary mean literally out there. What I mean is that the best way to become a great programmer is to join up with some communities both online and offline that are as committed to programming as you are, if not more.
It doesn't really matter whether you join online or offline communities, or a combination thereof. What it really matters upon is you, how much time you have to dedicate, and how easy it is for you to get around. But what I can tell you either way without a shred a doubt is that this is the absolute best way for a person to become an absolutely fantastic programmer.
You may be wondering why that is. Well, it's really simple to explain. There's not a thing in the world that is more important to a programmer's development as the process of getting direct feedback. There's not a programmer out there who knows everything, and there will never be a point at which you know absolutely everything there is to know, either. The point I'm trying to make here is that there will always be something to gain by talking to others, showing your code, and being able to ask what's wrong with it.
There are all in all a lot of reasons to join communities. However, I can't give you too much direction in joining these communities in real life because, well, I don't live where you live and I of course can't tell you what local groups will work for you.
With that said, many of the even smaller towns will have some sort of Python meetups within, say, an hour's drive. You can find these really easy by going to http://meetsup.com. On this site, you'll almost certainly see a ton of events which very well could catch your eye. The site picks up on your IP address and finds your general location and will automatically suggest some sites. Depending upon the overall population of where you're living, you very well may be able to find a group worth going to. There's a chance that you won't, of course, but there's a much much better chance that you will indeed find something worth going to.
There are a couple ways in which real life Python meetups will help you to develop.
The first way in which it will help you to develop is that going to these meetings will allow you to go outside of your normal comfort zone. There will most likely be some sort of "focus" or presentation for quite a lot of them that will bring up topics that you will probably have not even thought about. And depending on how much your group is geared towards staying bleeding edge, they most likely will also cover the most popular and most recently released APIs, the major updates thereof, and noteworthy developments in Python in general like huge programs being released in Python or seminars and crash courses on the incremental updates of Python which are released every so often.
Going to Python meetups will also benefit you in another less obvious way: it will let you network. This is really important in programming, even if it may not seem like it. Anybody can be a reclusive average programmer, but what will set you apart as a programmer is your ability to meet and work with new people who are working with new ideas that you never have before. There's also a great chance that you'll be meeting people who think similarly and have similar ideals and passions to you. And when you meet those sort of people, something really cool happens: you begin thinking of ways in which you can collaborate. So the people that you meet at these meetups very well could be people that you end up working on a project that one of you has been dreaming up for quite a while.
There are still more ways in which it can help you, too, but they're less notable. But with that said, there is most definitely some kind of mental brightening which happens for both a person's productiveness and creativity when their passions are actively validated by other people around them. The point here is that when you're around people who also love programming, talking about programming with them, you will most definitely start to feel better about yourself and start to feel your code become a lot stronger, too. Having our passions be validated is one of the most important things for people in general.
Anyway, now that we've covered the basics of meeting people offline, I think it's best that we move on to the topic of meeting people online. There's only so much I can say about meeting people offline and after a while, I'm just rambling on about what is pretty much nothing.
So how can you get going with online Python communities? Before we get into that, we should get into the "why?" -- it will make you more eager for the "how?".
There are a lot of reasons you should join online Python communities and if you think you can just weasel out of this step, then you're in for a pretty rude awakening down the line. When you join online communities, you're actually being benefited in manifold ways.
The first such way in which you're being benefited is that it provides feedback. You'll have a lot of people from all walks of Python programming be looking at your code and critiquing it in various ways, as well as identifying any problems that you may ask people to help you identify. When you're learning, having someone to explain the "how"s and "why"s of a lot of programming can make all of the difference in the world.
And there's another way in which it'll help you, too: you aren't the only one being judged. Indeed, your eyes will be opened to the mistakes that others are making, which will actually open up your ability to program by quite a bit. The reason for this is that it will allow you to see the mistakes which others make and this will, at least in the theory of it, make you far less likely to make those same mistakes.
See, being able to see the mistakes of others is a huge part of helping you to become a better programmer yourself. It will actually give you ideas about ways in which you can keep yourself better organized. You'll be able to expand that organization to your code and figure out how to make it more easy to read for anybody else who may be seeing or maintaining your code for the future. These are the natural products, actually, of seeing somebody else having an absolutely terrible set of code with little organizational basis.
But there's also a lot more to it than seeing other people's mistakes; you'll also see the places where they succeeded. A lot of people out there are absolutely gifted when it comes to programming, and they can actually simplify otherwise very complicated programs into super compact solutions thanks to their extensive knowledge of clever methods that a lot of other people tend to miss, or their application of things which you may not have learned yet that they turn you on to. I remember the first time I saw someone use regular expressions, I was absolutely dumbfounded! I had no clue what was going on there. They managed to simplify a block of code that took me something like 20 lines into a simple little operation.
So it's because of these reasons that I've come to the personal conclusion that if you want to be a serious programmer, you have to be an active member of communities, especially online communities. You're going to learn the bulk of everything you do in programming by asking questions and experimenting, and you're going to learn what's left by the questions that others have bothered to ask. You'll see best practices in action, and that will also have a considerable impact on your ability to program effectively.
So we've talked a lot about the merits of joining online communities, but we haven't talked too much on what communities you should actually join. So where can you go? What communities are there? There are three major communities that you absolutely have got to join up with, no questions asked.
The first one is the lengthiest to explain, so I'm just going to get it out of the way: IRC. In case you don't know what IRC is, it was originally designed as a network protocol about thirty years ago in order to allow users to relay text-based messages to one another through a network and thusly facilitating pertinent communication for the users of the network. In the thirty or so years since it's early development, it's both grown and shrunk in its user base a tremendous amount.
During the Nineties and the early Aughts, the IRC format served to facilitate a huge amount of online discussion, growing to be one of the most important chat-based networks on the internet. It still today has a status as the classic secure way to communicate through the internet.
In the last several years, IRC has started to see a major reduction in the number of users that it attracts because it no longer serves as the method of choice for a huge number of communities. Things like Discord, Skype, and even Facebook have grown to better facilitate the notion of chat rooms for exclusive groups of people.
With that said, don't get the idea that it's deprecated. IRC is just as full-featured as ever. It serves one purpose, and it serves that purpose incredibly well: the relay of messages from one user to a group of other users.
IRC was starting to pick up steam by the time that Python rolled around in the early '90s, and as Python began to be picked up by more and more people, as did IRC. Python never tapered off, but given that they in a way grew up together, the notion of IRC and Python are actually somewhat inseparably intertwined.
One of the absolute largest groups on the internet for Python discussion is the Python IRC channel. It has an unimaginable amount of Python users of all skill levels, from seasoned veterans to absolute newbies. Everything from Python to general topics are discussed, and people are invited to join in on the discussion whenever they want. Questions are also absolutely welcome, so this is another place that you'll feel yourself able to access a really fantastic feedback loop.
But let's be honest. It's 2017, as of the time of writing. You very well may not have ever joined an IRC channel, and you may have no clue. If you do, then awesome - the channel is called "python", and it's on the irc.freenode.net network. But just in case you don't know how to, I'm going to explain it.
The first thing you have to do is get a copy of mIRC if you're running Windows or whatever client works for your particular operating system if you don't happen to be. I'm writing solely for Windows in this chapter to be economical in terms of time and space. Adding the other operating systems would be a lot of text for no reason when most of the people reading this will be using Windows statistically.
Anyhow, once you've got mIRC or whatever you're going to use (all IRC clients have the exact same core functionality, so it doesn't matter too much), you're going to connect to Freenode's chat server:
​/server chat.freenode.net 
Now, if you go ahead and join the Python channel directly, you're going to be put in the python-unregistered channel because you didn't take the time to register your nickname, so they don't know if you're a spambot or not. A solid security measure. So to avoid having to deal with that, we're just going to go ahead and register our nickname in the first place.
Choose your nickname. Don't worry, you can have multiple that are registered to the same email address. Just pick whatever you like, and if you decide to go by another, you can change it later with extreme easy.
Now that we have our name picked out, we need to register it. You'll do that by typing this:
​/msg nickserv register passwordGoesHere emailGoesHere 
Your password and your email address are, obviously, going to go in the locations that I specified.
Now, once that's done, you need to head to your email to verify the account. This is really painless and actually very straight-forward. You're going to go ahead and open your inbox and look for a verification code sent to you very recently. Freenode will ask you to type, and you're going to do as it says. Once you've verified your email, it's pretty straight sailing.
Now that we've got the nickname and email registered and they know we're not some leet hacker, we're going to identify ourselves by the nickname that we specified the first time around, using this command:
​/msg nickserv identify yourNicknameHere yourPasswordHere 
Putting your nickname and password in their respective locations. Then boom, you're done.
So what happens if you don't like your nickname? I did indeed say that you could change it. You do so by grouping another nickname to the nickname which you registered with. What you do is switch to the nickname that you'd like to use by typing /nick newNicknameHere and then typing the following into the server:
​/msg nickserv group 
This will group this nickname to your other nickname so that you'll be able to go by either. With that out of the way, you're enabled to join up with one of the most thriving IRC channels around, filling over with developing developers that would love for you to join them on your mutual journey.
There are also a few other communities that it would serve you very well to join up with. You can't get by on IRC alone! In this chapter, I'll be going through two more that you ought to join up with.
The first of these is Stack Overflow. It's not even possible for one to say too much about this site. It's endlessly valuable for newer programmers. It's over at http://stackoverflow.com.
The structure of Stack Overflow is that of a question-answer site. The idea was actually originally developed in order to help people with questions concerning programming specifically, thus giving it its name Stack Overflow, a clever reference to the common programming issue where a program doesn't have enough space in memory for the buffer of the stack and attempts to use more space than it's been allotted. It's branched out quite a bit since then and now serves several purposes in addition to that, but its programming community is still incredibly strong.
Stack Overflow is going to end up being a huge asset for you. I can promise you that. This is a site specifically dedicated to asking questions about programming, and the people there are always, always glad to help you out with any questions that you may have or helping you to figure out how to fix your programs when you're stuck. Bear in mind that you're supposed to answer yes or no questions or questions which can be answered in an objective manner - no opinion questions are allowed.
It's really easy to set up an account for Stack Overflow and it takes all of three minutes, so it's definitely worth the time it takes to get set up because you'll find this site endlessly useful.
The last site that we're going to talk about is the Python reddit communities. The Python reddit communities are really fantastic because they offer many of the same advantages that the others do, but they're more permanent and a bit more formal than IRC just by the very nature of the beast. The two major ones can be found at http://reddit.com/r/python and http://reddit.com/r/learnpython. Both have relatively large user bases, with the Python subreddit having nearly one hundred and fifty thousand subscribers as of the time of writing, subscribers meaning people that have basically asked for the subreddit to be a part of the "feed" on their primary reddit page that they say when they first access the site.
Joining reddit and getting involved is super simple. Looking at the right side of the header, you'll see some small font which prompts you to either log in or register. You obviously are going to register.
/r/Python is more for general Python programming updates and discussion, whereas /r/learnpython is more aimed at people who are new and have questions about how to implement certain things. You'll really be able to feel out what type of content is appropriate for which community just by spending time immersing yourself in the two communities.
I'd say that getting involved with communities is altogether one of the most important things that you can do for yourself in order to become a better programmer, because it enables you to not only ask questions and have them answered, but to see questions asked. It enables you to not only make mistakes and have them corrected, but to see mistakes made. And it of course enables you to whole host of other benefits such as being in the know about the newest technologies that have come to Python and latest news in the programming sphere. The importance of joining up with communities cannot be understated.







Chapter 4
Learn Another Language (Seriously!)
This might seem like a bit of an odd suggestion, but it's really not. Let me explain.
No programming language is all-encompassing. Every single programming language has its own strengths and weaknesses and best applications. Every single programming language is best used in a different setting and every single programming language has its own set of different conventions which it holds to itself.
By learning another programming language, you're enabling yourself. Just how are you doing that? You're doing that by letting yourself explore a whole other paradigm of computer programming. You are shackled to one exclusive paradigm of design or typing.
Python is so one of a kind in its usage and style that there's actually a term for it - "Pythonic". If a program is written in a sparse and super efficient yet totally understandable way, it's said to be Pythonic. The more slim that something can be made, the more Pythonic that it is. Python is a language of pragmatism, and with this pragmatism comes an entire paradigm of effectiveness and pseudo-minimalism that is unrivaled by any other language.
This can be both a great thing and a terrible thing. It's a great thing because it can somewhat make programming into an art form. It's also great because it can make you seek out the most efficient way to do things, and get you thinking in an efficient and compartmentalized manner.
However, as I said, it can also be taxing. It can be taxing because it can kind of drill you into a singular paradigm or mode of thought. For example, if you're only dealing with the modern day fluidity of Python, you're going to miss out on a lot of the lower level processes that you would be keen to if you were programming in, say, C.
Now, that's not necessarily a bad thing, the faster deployment time and easier point of entry for modern programming is pretty much a godsend, especially for newer programmers. However, what this means too is that you're missing out on a lot of information under the hood that you wouldn't be privy to without knowing exactly what was going on.
The example I love to always give is the concept of C strings.
In the 1970s, a huge boon to programming came about: C. Now, a lot of things led to this language being adopted widely. In fact, I'd say it's more of the fact that there was what some would call a perfect storm: computers started to be more widely accepted into the business and, in the 1980s, the home; C was an easy to understand language compared to some of the more archaic languages which came before it; C was developed to be used on Unix systems, which would end up taking over a lot computer architecture; it was easy to do "surface programming" (at least compared to other contemporary languages), not esoterically confined to the purposes of math or business, and still had the underlying architecture to talk directly to the computer... all of these among a lot of other basic factors would contribute to the C programming language being an absolute powerhouse, both in terms of acceptance and in its own relative power.
C would end up influencing a lot of languages which came after it. For example, C++ was developed as a direct successor to C, including familiar C style and even reverse functionality with C code in addition to the object oriented programming paradigms that were starting to take off at the time. Java was developed as what became known as a C-style language - a language which borrows the basic syntax and stylings of C, applied in a different and often more modern manner, and it took off majorly in the 1990s, becoming a huge language in computing circles.
The reason I say this is that Python, too, is a C-style language in one way or another. Python is, of course, a lot slimmer than its great ancestor C. Observe the following code snippets which do the same basic thing:
C
#include <stdio.h> 
int main() 
{ 
​int a = 3; 
​int b = 4; 
​int c = 3 + 4; 
​printf("%d", c); 
} 
Python
a = 3 
b = 4 
c = a + b 

print c 
However, that doesn't mean that they're not beholden to a lot of the same principles. Indeed, a lot of the things which showed up in C show up in Python as well, despite Python's huge amount of abstraction. This is what I mean by the C string example.
C didn't originally have strings. It had a bunch of different data types which would represent numeric values, either on the surface or below the hood, but a way to store plain text messages just simply didn't exist natively. Indeed, this is due to the limitation of computers to represent text and the fact that computers are, at their root, computing machines, geared ultimately towards numbers and representation thereof.
What C did have, however, were arrays. Arrays are a bit of an ancient analogue to Python lists. They're still commonly used in C++ and Java and other languages as such, but scripting languages have for the most part eschewed them in favor of lists. C++ and Java, themselves, have implemented things like Python lists like vectors, sets and, well, lists.
So what's the difference between C arrays and Python lists? Well, not too much. They function pretty similarly. You'll see where I'm going with this in a second, I promise. Anyway, C arrays and Python lists represent the same basic idea: the storage of related data. However, they go about it different. Python lists expand to be the size that is needed; they have the freedom to do so, because Python is built for modern computers with memory to spare. When C was developed, computers didn't have that luxury, so it's built to actually set aside the amount of memory needed for a certain variable. So for example, let's say we had a C array called "grades" which could hold up to 4 values, but we only guaranteed one:
int grades[4]; 
grades[0] = 75; 
The spots at grades[1], grades[2], and grades[3] would be guaranteed open to the program to use. They're reserved:
​Memory slots 
1​​2​​3​​4​​5                            6 
​taken​​grades[0]​grades[1]​grades[2]              grades[3]              open 
​Memory spot closed/open? 
However, if we were to try to insert a value for grades[4], we wouldn't be able to; it'd go beyond the given parameters of what we had reserved for the grades array, despite the slot at memory location 6 being open. It's not there for us to use. However, a Python list would automatically resize the array and take advantage of the open memory slot 6.
So in lieu of strings, what C did have was character values. These are values which represent any given ASCII character, be it alphabetic, numeric, or symbolic. They could be declared like any other data type and would hold the weight of one character.
So early C programmers got to thinking, and they thought - alright, we have arrays, and we have character data types, and we need strings. And a string is just a set of characters in theory, right? So what early C programmers did was actually make that so. Before long there was a C library dedicated to C strings, which were just fixed-length character arrays.
And this brings me to the end of my explanation: if you didn't know anything about C, then that would go over your head. Which means a lot of features that exist in Python strings, such as the ability to print out the letter at position x by way of printing out string[x] is because of the fact that Python are built upon the C string paradigm and are essentially just glorified lists of characters. That is precisely why it's so important to learn other programming languages in addition to your primary language.







Conclusion
Thank for making it through to the end of Python Strategies: Bold Strategies to Go From a Newbie to a Pro, let's hope it was informative and able to provide you with all of the tools you need to achieve your goals whatever it may be.
The next step is to act. I've given you a lot of useful strategies over the course of this book, but it doesn't matter what I tell you if you don't act on it.
There are, for example, plethoras of open source projects out there coded in Python that you could be contributing to right now. You'd learn quite a bit from looking through open source Python projects, actually, and you'd discover a whole wealth of information and good programming practices that you didn't have before.
Overall, through the course of this book, I've tried to set you up with some strategies that will help you to not only succeed but to thrive in the world of Python and programming in general. Programming is not simply about writing code. Programming is an art form, a form of expression, and it's also a science, a very complicated set of maths and technology intermingling in the often bizarre but perfectly amazing area of computers. And in that combination of the two areas of art and science is a lot of liberation, too.
You aren't likely to be the best programmer, there's a one in a billion chance of that. But you can absolutely be the best programmer that you can be, and in that comes its own set of accomplishments and abilities. You don't have to be the best. But you can be pretty great. And you'll become pretty great by acting. Act to join a Python community. Act to work on software. Act to work on something you care about. Act to start a project. Whatever you do, be sure that you act.
I genuinely hope that I've managed to give you personally useful information that will help you on your journey to being an incredibly Python programmer.
In closing, if you found this book useful in anyway, a review on Amazon is always appreciated! I'd love to hear exactly what it is that you have to say about my book.
Best wishes.







SQL
DANIEL JONES








SQL Beginner's Guide

The Ultimate Beginner's Guide to learn SQL Programming effectively 
DANIEL JONES 







Introduction
The following chapters will discuss what SQL is and what you are going to be able to do with it. SQL is a different kind of programming language that has many different uses and hopefully through this book you are going to be able to learn what those uses are and know how you are going to be able to make them work for you!
There are plenty of books on this subject on the market, thanks again for choosing this one! Every effort was made to ensure it is full of as much useful information as possible, please enjoy!







Chapter One
SQL- What is it and Why You Should Learn it.
SQL stands for structured query language. This language is a domain specific language that you are going to use if you are programming or trying to manage data inside of a RDBMS (relational database management system).
SQL was started with math, both tuple relational calculus and relational algebra. There is a lot of data definitions and manipulations along with control language that is going to be inside of SQL. SQL involves the use of things such as delete, update, insert, and query.
In essence, you are going to be able to update, delete, insert, and search for the things that you are going to be putting into the program. It is very common for SQL to be described as a declarative language, however, the program also allows for procedural elements.
This is one of the first languages that was able to use the relational model that was created by Edgar F Codd. Although it is not going to work with all of the rules that are set forth for this model, it is one of the most widely used languages for data bases.
In '86, SQL became part of the ANSI. Then, in '87 it became part of the ISO. However, there have been updates since then that have made it to where the language can include larger sets. Just keep in mind that the code for SQL is not going to be one hundred percent portable between data bases unless there are some adjustments to the code so that it fits the requirements for that data base.
Learning SQL can be one of the better decisions that you make about your career because you can push yourself forward with it that way that you can rely on using your own knowledge rather than having to go to someone else for their knowledge. In fact, people are going to be coming to you to learn what it is that you know about the program.
By learning SQL, you are going to be able to do more than you may have been able to before. Here are a few things that are going to give you a good reason as to why you should learn SQL.
Money
Learning SQL makes it to where you have the opportunity to earn some extra money. Developers that work with SQL earn around $92,000 a year! An administrator for an SQL data base is going to make about $97,000 a year. So, just learning SQL makes it to where you are able to earn around twice as much as what the average American household is going to make in a year.
Highly sought after
Employers are wanting people who know SQL! The more knowledge that you have about SQL the more sought after you are going to by employers. Knowing SQL is not only going to benefit you but your employer as well because they are not going to have to pay for you to learn the program. The interviewing process is going to be better than any other process that you have gone through and you may find that they are going to be willing to give you more money just for knowing SQL over the other person. With SQL knowledge, you are going to be opening yourself up for more careers than you might have been able to apply for before.
Get answers
SQL is going to give you the answers that you are looking for to any questions that you may have about business or data that is being stored inside of your data base. Therefore, you are going to be more self-sufficient and not as dependent on others when it comes to business. If you are able to answer questions on your own that you so that you are not stopping someone else from doing their job, then an employer is going to be able to save money by hiring you because you are going to be able to answer questions on your own rather than having to deal with hiring someone else to answer those questions. Knowing SQL is going to even help you if you are wanting to start your own business or push your business that you have already started to the next step that has just been out of your reach.
More stable than Excel
When you are using Excel for large amounts of data, you may notice that it is too much for the program and therefore the program tends to crash. A crash leads to lost data and extra time that you are going to have to go in and fix anything that may be wrong or entering data that was not saved. SQL is going to be much more reliable for you to use when you are trying to work with large amounts of data and it is going to save you some time working with it because it is not going to require too much for you to work with the processes that SQL offers.
Making reports
Searching in SQL is relatively easy and you can reuse that search when you have to double check to make sure that the data in the data base is accurate. Excel does not give you the proper processes that you need to get ahold of the data that you are wanting to get ahold of.
SQL coding only has to be written once and saved and then it is going to run each time that you need it to. This is yet another way that SQL makes it to where your life is easier because you are not having to take up as much time trying to get the data that you need.
Do not think that SQL is going to be simple, it is complicated and is going to take a lot of time to learn, but the more effort that you put into it, the more it is going to pay off for you. You are going to not only be saving money by learning SQL, but you are going to be increasing what you will be able to make with SQL.







Chapter Two
The Basics That You Need to Know of SQL
Before you can work with SQL, you need to know the basics that are associated with the language. SQL is the language that is used when you are getting data bases to talk to each other and you are going to manage these data bases with SQL as well. Working with SQL, the data that you put into the program is going to form tables with columns and rows just like how Excel does. The columns are going to be known as the fields.
Here are some of the more basic terms that you need to know so that you can know what the program is doing.
-        C.R.U.D.- the four most basic operations that SQL can do spell out the word crud so that it is easier for you to remember what they are. Creation, Reading, Updating, and Deleting.
-        Data base: the collection of tables that you have made.
-        Foreign Key: the key that locates the records of data that are inside of your table so that it can be matched to the primary key that is inside of another table.
-        Query: the search for data in the data base
-        Primary key: the primary key that will be a unique value for every record to be identified with on your table. This can also be automatically generated if you do not want to set a unique one.
-        DBMS: data base management system
-        Syntax: the words and phrases that make up the statements that are entered into SQL
-        RDBMS: relational data base management systems
-        Table: where all the data for SQL is organized.
Your main differences that you are going to see between DBMS and RDBMS is how the data is stored inside of the table. The DBMS is going to store the data in a file rather than a table. SQL is going to work more with RDBMS instead of DBMS.
Primary keys are going to add in more complexity to your code while foreign keys are going to be for one table and will be able to make it to where data from another table is pulled up in your search.
You should also keep in mind that SQL works with three programs. Oracle, SQL, and MySQL. There are going to be different commands depending on which program it is that you are working with. There are also some things that are only going to work in one program and not the other two. It never hurts to try other platforms for your commands to find the one that is going to work best for you.
Data types in SQL:
Here are some of the data types that you are going to be working with in SQL. You will notice that many of these data types also work in programs like Microsoft Excel.
-        Singles: a single floating point number that deals with decimals. Singles have 4 bytes of storage.
-        Byte: this is any number you want to enter between zero and two hundred and fifty-five. There is only one byte of storage.
-        Long: whole numbers that fall between -2,147,483 and 2,147,483,647. There are 4 bytes of storage.
-        Currency: you can have up to four decimal points and can go up to fifteen whole number places. There is 8 bytes of storage here.
-        Memo: larger amounts are going to be put into a memo. So, anything up to 65,536. You can search memos but you cannot sort them.
-        Date and time: this one is very obvious. There are 8 bytes of storage saved for date and time.
-        Text: this is going to be the numbers and letters that you put into SQL. You are only going to be able to store two hundred and fifty-five characters.
-        Double: this is like singles, but it will be double floating point numbers and therefore it is going to be more decimals that can be stored. 8 bytes of storage are saved for this data type.
-        Integer: you are only going to be able to store numbers in this data type. It is going to be between the numbers of -32,768 and 32,767. You have 2 bytes of data that can be stored here.
-        Look up wizard: this is your options list so that you can choose what it is that you are wanting to do. This has 4 bytes of storage.
-        Auto number: the fields are going to be given their own record for data with its own number. It is going to start out with one unless you state otherwise. 4 bytes of data are saved for auto number.
-        Hyperlink: you are going to be able to send the user to a web page if it is necessary.
-        Yes and no: the logical fields that require answers like yes or no or even true or false. The true and false answers are going to be equal to negative one and zero. If no value is allowed, then that field is going to be null. The storage is 1 bit.
-        Ole object: pictures and other multimedia will be placed in this data type. It is known as a blob which stands for binary large objects. You have the largest storage amount here and it is one gigabyte.
You can put all the data types into three different categories.
-        Date and time.
-        Characters
-        Numbers
Logically, the numbers are going to be numbers, date and time is going to be the time and date that is recorded, and characters is going to be text.
Character:
-        Varchar(size): the length of the string that is stored will be able to hold all of the data types that we just talked about. The size is going to be based on what the number is that is in the parentheses. Normally it is going to be texts that you convert.
-        Char(size): the character string is a fixed length that can be the data types that were previously discussed.
-        Blob: there are 65,535 bytes of data that can be held with a blob.
-        Tiny text: you are only going to be able to put two hundred and fifty-five characters in the tiny text.
-        Long text: this is going to hold up the largest number of characters.
-        Text: this is the normal character text that holds up to 65,55 characters.
-        Medium text: this is going to hold around sixteen million characters at most.
-        Set: this is going to be similar to an enum type but is only going to hold up to sixty four items however, you can store more than one data type in it.
-        Medium blob: this holds up to sixteen million bytes of data
-        Long blob: this is going to hold the most bytes of data hence why it is called a long blob.
-        Enum(x, y, z...): every possible value is going to be listed in an enum. It can hold up to 65,535 values. Anything that is not inside of the list will be resulted as a blank value. The values do not have to be put in order when they are entered, they can be sorted at a later date.
Number:
-        Float(size, d):  this is considered to be a tiny number that uses a decimal that can float. The size of the parameters are going to be the maximum amount of values that can be put into the data type. The d parameter is going to be the largest amount of numbers that can be to the right of that decimal.
-        Tinyint(size): you can have -128 to 127 signed values or 0 to 255 unsigned values.
-        Bigint(size): you can have 9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 signed values or 18,446,744,073,709,551,615 unsigned values.
-        Smallint(size): you can hold up to thirty-two thousand signed values or sixty five thousand unsigned.
-        Int(size): holds a set value of signed and unsigned values.
-        Medium(size): holds up to sixteen million unsigned values.
-        Decimal(size,d): you are going to be able to store decimals inside of a fixed point that are inside of the size parameters. The parameters are going to be set by the maximum amount of digits that are found to the right of the decimal.
-        Double(size, d): this is similar to the decimal(size, d) but the number of digits that are to the right of the decimal are going to be set by the parameter which is going to be d.
There is another option that you may have noticed in the integer data types and that is called unsigned. In a traditional sense, the values are going to go from negative to positive. However, when you add in the unsigned attribute, you can move that range up so that it is not starting at a negative number, but it is starting at zero. Unsigned options are mentioned before their numbers so that the system knows where it is that you are wanting to start the values.
Date and time:
-        Date(): dates are going to be entered in year, month, day format.
-        Year(): the year is going to either be inputted in two digit form or four digit form. It is going to depend on what you are doing that will depend on how it is entered.
-        Datetime(): you are going to be putting in a combination of the date and time. It will be entered as the date() is and then the time will be entered hour, minute, seconds.
-        Time(): time is entered hour, minute, second.
-        Timestamp(): the time stamp is going to match what the current time zone that you are in so that you can see exactly when something was done. It will be entered like the datetime().
You need to keep in mind that the date time and the time stamp are going to be the same format and will work the same way. However, the time stamp will update automatically to the time zone that you are working in and the date time is not going to.
Plus, the time stamp does not necessarily have to have the time in its format, it can just have the year, month, and date.
CRUD
CRUD stands for the four main functions that you can use in SQL. When you are first learning about the program, you are going to want to start here because it is going to work with most of the basics for SQL in an RDBMS.
-        Delete: you will remove data from the tables you are working with.
-        Create: you are going to use this command to fill out the data that needs to be in the tables.
-        Update: manipulating the data that is in a table already will be updated with the update command.
-        Read: you can search or read the data that is in the table.
After you understand how to use CRUD, you are going to be able to move on to more complex things about SQL such as syntax.
SQL is similar to how the English language works. The commands have the same basic structure and rules that have to be followed as does the English language.
Here are some of the rules that you are going to need to follow so that you can avoid some mistakes that others have made as they were working with SQL. You are going to find that you will make mistakes, this is not going to be avoided. But, do not let this stop you from still learning SQL, learn from others and make your own mistakes as you learn.
Rules:
-        Make sure that you put a semicolon at the end of every SQL statement just as you would put a period at the end of an English sentence.
-        Tables and column names should start with a letter.
-        Keywords cannot be used that are going to cause the system to think that you are entering a command. So, do not use words like update or insert. The system is going to think that you are wanting to update the table or insert data into it.
-        After you have put your first letter for the column or table name, you can put numbers, underscores, or other letters for the name.
-        You are only allowed to use thirty characters for a column name.
Data creation:
Before you are able to put any data into the data base, you are going to need to have a table to insert the data into. You will use the create table command so that a table is made in the data base. By using this command, a table should be created but you are going to need to put the name of the table next to this command. The parenthesis will be where your keywords are located and then the data types are going to follow the column name and a closed parenthesis.
Syntax:
Create table table_name 
(column_1 data_type, 
Column_2 data_type, 
Column_3 data_type); 
Reading your data:
The data that you have entered into the table can be searched so that you can find anything that it is that you are wanting to relocate. The data has to be saved in the data base before you are able to search it. If you are not wanting to search it, you can also filter and sort it so that it falls into three different statements.
The three ways that you can search data that is in your data base are:
-        Where 
-        Select 
-        From 
Your where statement is going to be all the conditions that are going to have to be met before you are going to get the data displayed to you. At the point in time that you move past the two basics, then you will discover that this statement cannot be used.
The select statement is going to explain to the computer that you are using where the values should be returned and exactly what those values are.
Finally, the from statement is going to give you the data that you are wanting to see and where they are located in the data base.
Updating the data in the database:
Sometimes the data that you have in your tables does not need to be taking up the storage room that is on your data base and you will need to delete it. The table can either be deleted completely or the specific pieces of information that you no longer want gone can be deleted.
The rules that you use for the update command are going to be the same as when you are using the where clause. This clause, if it is not properly placed or is not put into the code, all of the data in that row are going to be deleted whether you want it to be or not.
When you are cleaning up your data base, if the table is no longer needed, you can use the drop table command so that the entire table is gone. The delete statement will not delete the table, instead it will just delete the data that is inside of the table. The drop table command is going to make sure that the table and all of the data that is in it will be deleted.







Chapter Three
Your First Table!
Congratulations! You now know the basics of SQL and how it works. Not only that, but you know the vocabulary and commands that you are going to use when you are working with SQL.
At this point in time you can now create your first table and learn how you will use CRUD with that table.
Table creation:
In order to create a table, you must make the table. You need to make sure that you know what you are wanting to input into the table. After you have figured this out, you will be able to figure out how many rows and columns that you want in your table. All of this is going to go back to what you are putting in your table.
Use the syntax that we stated in the last chapter so that you can create your table. You can use uppercase or lower case letters depending on your preference. The system is not going to care which you choose. With the syntax that you were given, you are going to be creating a basic table. There are ways to get more complex tables but those are covered in more advanced SQL books.
Be sure that you name your table and you can name it whatever it is that you are wanting to name it. You will find that it is going to be easier to name it something that has to do with what it is that you are putting into the table. So if you are dealing with phone numbers for the women that are in your book group, then you may want to name it something like "Phone Numbers" or "Book Club".
Now that you have named your table, you are going to want to have the first name, last name, and phone number of each member. That right there is three columns so you are going to only put three columns into your code.
Lastly, the data type that you are using is going to need to be entered as well. Chances are that you are going to use varchar and then how many characters are allowed inside of that column. Right now you may think that you are never going to be able to do this because it is a little bit of an information overload, but it may make more sense after you see it put to work in an example.
Example
​Create table phone numbers 
​ (first name varchar (10), 
​Last name varchar (15), 
​Phone number varchar (20)); 
This table is going to be named phone numbers and the three columns will be the first name, last name, and phone number. You do not necessarily have to put in the word name because it is going to be assumed that it is the first and last name whenever someone looks at the table.
The number that is inside of the parenthesis is going to be how many characters are able to be in that column. Remember that each data type has a specific set of storage that it is allowed and with varchar you are only going to be able to go up to two hundred and fifty-five characters.
In the event that you are wanting to add in more data to your table, such as the book that they are currently reading, you will just add in another column.
Example
​Create table phone numbers 
​(first name varchar (10), 
​Last name varchar (15), 
​Phone number varchar (20) 
​Book title varchar(100)); 
Now your table has four columns. It is important for you to take notice that your table is the same as it was in the previous example but it now has the added information. Everything is inside of the parenthesis with a semicolon at the end so that the system understands that you have finished your code and that it can now do what you have commanded it to do.
Reading data:
With your table now created, you are going to need to read it or search it. Like we talked about earlier, you are going to be able to do this by following one of the three basic clauses that are used inside of SQL so that the information is filtered and sent back to you.
Remember that your clauses are:
-        Where 
-        From 
-        Select 
When you use the select command, you are going to be able to select the table that you just created so that it is the only one that is being searched.
Syntax:
Select * from table_name 
However, if you are wanting a specific column that is inside of that table, you are going to have to put which column that you are wanting to be searched so that the entire table is not being searched and taking longer than necessary.
The from clause will not display any of the data that you are wanting to see from your search.
In the event that you are wanting to be more specific about the data that it is that you are wanting to get back, you are going to need to use the where clause. The where clause is a different operator that is going to filter all of the information that you are getting back. These operators are going to be used to filter out and get what data you are wanting.
-        %: this will either be placed before or after characters that will match other characters.
-        =: equal to
-        < >: not equal to
-        >: greater than
-        <=: less than or equal to
-        >=: greater than or equal to
-        In: multiple values can be put into a column
-        Between: the place between two different values
-        Like: a pattern that can be used later one.
The operators are going to be placed in the SQL code much like this example.
​Select column number, 
​From name of table 
Where name of column and operator value);
The last clause that you need to know about is the order by clause which is going to be used when you are searching for data in your data base. This clause is most effective when it comes to managing how your data is arranged whenever you receive it.
Modifying data:
Now you need to know how to modify the data that is inside of your table. The data can be updated at any point in time and most of the time it is going to  happen to all of the data inside of the table. For businesses that are larger such as multimillion dollar companies, it is going to happen on a daily basis.
The where clause will be used when you are using the update command. But, where you put this clause is going to be very important because if you put it in the wrong place, then the information is either going to be updated with the wrong clause or you are going to get the wrong information updated.
Syntax:
​Update table_name 
​ (set column_name = new value 
​Where column_name operator value); 
When you are updating the data that is inside of your table it can be updated by using several different methods. One of the easiest ways is to make it to where any value that is inside of your table is going to be updated.
Syntax:
​Update table_name 
​ (set column_name = value); 
Deleting data:
The last thing that you need to learn is how to use the delete command. Whenever data is no longer needed, you will need to delete it so that you can put new data into the space that the data was occupying. With this command, you are going to be deleting specific pieces of information rather than the entire table.
Syntax:
​Delete from table_name 
​Where column_name operator value; 
Your value for the operator is going to be where you can choose what data it is that you are wanting to have deleted. Should you want to delete an entire column, all you are going to do is remove this value. The code is the same except you are not going to have the operator value.
However, commands such as drop table are not only going to delete data that you do not need, it is going to delete an entire table that you no longer need. In doing this, you are going to be freeing up more space on the disk.
The commands that you are going use in SQL are going to either fall into a specific category for the commands or it is going to fall under the CRUD acronym. However, SQL has so much more that it can offer you besides these basic commands.
With more advanced commands, you are going to get more unique results that are going to be appropriate for the business that you are doing with SQL. But, you are only going to be able to do these if you are able to understand how the most basic commands work in SQL.
Should you not fully understand how the basic stuff works, you are going to want to go back and practice it some more because knowing how SQL works is going to the be foundation that you are going to work on whenever you work your way up towards the more advanced techniques. 







Chapter Four
The Commands That Make Up the Foundation for Your SQL Learning
As stated in the last chapter, knowing the basics of SQL is going to make I to where you are going to find it easier to learn SQL. Knowing the basics of SQL means that you need to know the name of the commands and what it is that the command is going to do. Not only that, but you need to know the coding for the command and where you should place it in the code that is already written so that it carries out the command that you are wanting to complete.
Create data base: with this command you are going to create your own data base.
​Syntax: create data base data base_name 
Create table: once the data base has been created, the tables that are going to hold your data need to be created in the data base as well.
Syntax:
​Create table table_name 
​ (column name1 data_type, 
​Column_name2 data_type, 
​Column_name3 data_type,); 
Insert: after the first two steps, have been completed and you are putting your data in, you may discover that you need to have another row added to your table. There is a command that you can use so that you do not have to make a new table which would mean that you have to enter all the data into the table once more and that is not going to be very time efficient.
​Syntax: insert into table_name 
​Values (value1, value2, value3); 
If you do not want to put in a new value but a new column, you can do this as well by using essentially the same syntax that you used to create the table as well as input the new column.
Syntax:
​Insert into table_name 
​ (column_1,....) 
​Values (value 1,....) 
Just like everything else, a new row can be put into the table. With new rows, you are going to have the flexibility to put in different amounts of data at the same time. The data does not have to be of the same type.
If you are wanting to put data into a specific column, you are going to need to make sure that you are telling the system exactly which column you are wanting the data to go into as well as the data that you are wanting to be put in that column.
These are just some of the basic create commands that are available with SQL. If you have mastered these commands, then you are ready to move on to the next commands that are going to make it to where you can search the data that you have entered into the table.
Select: to search through the data base and read the data that is available, you are going to need to select the data that you are wanting to be returned. In order to do this, you are going to be using the select command.
Syntax:
​Select columns 
​From tables 
​[join joins] 
​Where search_condition] 
​[group by grouping_columns] 
​[having search_condition] 
​[order by sort_columns]; 
Just by looking at the syntax you are going to realize that this is a more complicated code and it is going to be used when you are being specific about what it is that you are searching for.
The various clauses, keywords, and operators that you put into the code are going to be put in after you have entered in your basic commands. In order to do that, you need to understand each part of the code and what it is that it will be doing.
When getting, a single column displayed
Syntax:
​Select column 
​From table; 
Returning several columns from the same table
Syntax:
​Select columns 
​From table; 
If you want everything from the table, you are going to use the from keyword as well as the select keyword. The select keyword is going to select the entire table and the from keyword is going to pull that data from that table. There are no keywords after select because you want the entire table and not just specific parts of it.
You already know how to select multiple columns at once, so if you are wanting  to pull the phone numbers from the book club table, you are going to write out something that looks similar to this:
​Select phone numbers 
​From book club. 
Or, if you want to pull the entire book club table, you are going to use this command.
​Select * from book club. 
Those are just a few of the read commands that you are going to use, and they are probably going to be the ones that you use the most when you are working with the data in your data base. They are pretty simple commands, right? Well, if you think you have a handle on them, then you are ready to move on to the next set of commands!
Modification:
There are times that data that is in your table has to be modified because it needs to be updated to more current information or because you entered it wrong and now need to fix it.
Syntax:
​Update table_name 
​Set column1 = value, column 2= value column 3 = value 
​[where search_conditon] 
If you are not putting your where clause in the appropriate place, then your data is not going to be updated properly and you are going to have to go back and make fix it all. Yet again, this is not going to be the most time efficient for when you are working with SQL. Remember, the whole purpose behind SQL is to be more time efficient so that you are not wasting too much time.
For example, in your book club table, you have the members first name, last name, phone number, and the book that they are currently reading. with the where clause, you are going to want to search for information specifically based on the conditions that you have set forth.
At this point you now know how to create tables for your data, read that data, and now you can update it as well. The last thing that you need to know is how you are going to delete any information it is that you are no longer wanting to be inside of your data base. The data that you delete is going to be data that you delete based on the information that you no longer need or want anymore.
Delete:
Rows may need to be deleted whenever you are dealing with a table and data that you no longer want. To do this you are going to use the delete command.
Syntax:
​Delete from table_name 
​ [Where search_condition] 
When you are inserting your search condition, ensure that you are filling in the name of the column or the row that you are wanting to be deleted. If you just use the delete command in general, all the data that is in the table will be deleted and you do not necessarily want that because not all of the data is going to need to be deleted.
Just one row can be deleted and you are going to use the similar syntax as above but you are going to be telling the system which table you want the data deleted from and which data it is that you want deleted.
Using the where clause is going to be a given however, you are going to be adding in a keyword and this keyword is and. With the keyword and it is going to be adding in some more data so that the system cannot mistake what it is that you are wanting deleted. So, if you have data that is similar say the same last name of two members in your book club, then you are going to need to be more specific and pick which piece of data is going to be deleted and that is going to mean that you need to put their first name into the system.
If you are wanting the all the rows to be deleted, you are going to use a code that is similar to the select code that selects the entire table. The table is not going to be deleted, just the data that is in the table. This is going to be helpful if you have new members of your book club or if the data is no longer relevant.
Drop:
The drop command is under the delete category because you are going to be getting rid of an entire table along with all the data that is in it. This command is going to be what is used to also delete data bases as well.
An index is used whenever you are wanting to search for specific information in your table so that the search of your table goes by faster than it might have before indexes are not going to be visible to someone who is looking at the table, but they are going to be visible to those who are searching the table. There are four different ways that you can drop something from the data base.
Access:
Syntax
​Drop index index_name 
Oracle:
​Drop index index_name 
SQL:
​Drop index 
​Table_name.index_name 
My SQL
​Alter table table_name 
​Drop index index_name 
If you are wanting a table to be deleted from you data base, the drop table command is going to be used to achieve this goal.
Syntax:
​Drop table table_name 
If the entire data base needs to be deleted so that you can make a new one or because it is simply no longer needed, you are going to be able to use the drop command for this as well.
Syntax:
​Drop data base data base_name 








Chapter Five
Math That You Can Do in SQL
The standard SQL 92 is going to give you the ability to do the four most basic mathematical functions.
​%: modulo 
​+: addition 
​/: division 
​-: subtraction 
​*: multiplication 
Whenever you using the modulo operator, it is going to determine if the remainder that you got from the dvision is an integer or not. Sadly, ANSI SQUL is not going to be able to support this function, but on the other hand, most data bases are going to support it.
Below are listed some of the mathematical functions that you are most likely going to find yourself using more than the most basic of functions. All of the operations are not a requirement for SQL 92 specifications, so you may need to determine if they are available on the RDBMS that you are using before you try and use them or else they may not work and you may end up frustrating yourself. The good news is that they are available on most of the major data bases that you are going to be working with.
SQRT(x): the square root of the value will be returned
ABS(x): the absolute value of the value will be returned
ROUND(x, d): the rounded value of x is going to be rounded to the number of places that the d value is going to tell the system to round it to.
SIGN(x): the input of x will be returned as -1, 1, or 0.
Round(x): the value is going to be rounded to the nearest whole number.
MOD(x,y): this is a modulo function that is going to return the integer for the remainder of x which was divided by y.
POWER (x,y): the value that is x will be raised to the value that is y.
FLOOR(x): the largest number is going to be less than or even equal to the value of x.
CEILING (x) or CEIL (x): the smallest number is going to be returned as greater than or equal to the value of x.







Chapter Six
SQL Transactions
Transactions are units that will be used against what the data base intended for it to be used to. These units are meant to accomplish a function in an order that makes sense to the user or to the data base.
Transcations are the propgation of changes that you are making in the data base. So, whenever you do something such as update a record then you are performing a transcation on that table and it is changing it in the data base. You need to make sure that you can control your transacations so that you can make sure that the data that is inside of the table that you are working with still has its integrity and that the data base is going to be able to handle any errors that you might get.
In the end, you are clubbing your SQL searches into a group so that they can be done all at once instead of doing them indiviually.
Properties of transacations
There are four properies that are often known as ACID
Atomicity: all the operations in you equations are going to be successful. At any point should your equation fail, the process is going to be terminated an all the previous operations are returned to their former state.
Consistency: the data base will be watched to make sure that any changes made are made properly but only when there has been a successful transaction.
Isolation: transactions are going to be given the ability to run apart from other transactions and will be transparent from each other.
Durability: the result of all your transactions are going to need to survive, even if the system ends up failing.
Control of the transcation
You will use four different commands to ensure that a transaction is controlled properly.
Commit: changes will be saved.
Rollback: all your changes will be reverted back to what there previously were.
Savepoint: this is a point where you will save your transaction so if you need to, it can be rolled back.
Set transaction: the title of the transaction will be placed.
The control commands can only be used with the insert, delete, and update commands only. You cannot use them to create or drop tables since those commands are already in the data base.
Commit command
The commit command is going to be the command that you will use when you need to save changes based on a transaction that was made to your data base.
All your transactions will be saved from the last commit or rollback command that was entered into the system.
Code:
​Commit; 
Example
Think back to the family table we used in our last example. To delete the phone number from the table and use the commit function so that you can ensure your changes are saved in your data base,
Your code will be:
​Delete from family 
​Where phone number = 485-9876; 
​Commit; 
Now your table does not have that phone number while the changes are  saved in your data base.
Rollback command
Your transactions will be undone as long as the transaction has not been saved to the data base. They are only going to able to undo everything back to the last commit command that was done.
Code
​Rollback; 
Since in the last example the commit command was used, you are going to be able to use the rollback command so that you can undo what it was that you did.
​Delete from family 
​Where phone number = 485-9876; 
​Rollback; 
If done properly then you are going to get the phone number back in your table.
Savepoint
Once this command has been put into the system, then you are going to be able to roll back to this point. You need to make sure that you have everything the way that you are wanting it to be before you use the savepoint command because if you need to go back to something that is before this savepoint, you are not going to get it back unless you input it in manually.
Code:
​Savepoint savepoint_title; 
Once a savepoint has been created, the rollback command is only going to be able to undo everything up to this point.
To use a rollback with the savepoint command the code is:
​Rollback to savepoint_title; 
Example
Remember the family table. You are going to create a savepoint that will not only save all of your changes that you have done, but will be the point that you will rollback to when you need to rollback your code.
Your script for constructa save point is going to be longer and appear to be more complex than any other command that you have entered in thus far.
​Savepoint SP 1; 
​Save was created. 
​Delete family phone numbers 
​Phone numbers deleted 
​Savepoint SP 2 
​Save was created 
​Delete family country 
​Country deleted 
​Savepoint SP 3 
​Save created 
​Delete family age 
​Age deleted 
As you can see, you deleted what may be some important information from your family table. You are now going to use the rollback command to go back to the last save point which will be save point 3.
​Rollback to point 3 
Your rollback was successful!
You now have any information that was deleted after the third rollback was created.
Releasing the save point command
When you release your savepoint, you are going to be remoing the savepoint of your choosing.
Code
​RELEASE SAVEPOINT SAVEPOINT_TITLE; 
After you have released the savepoint you are not going to be able to use the rollback code to go back to the last transaction that was performed because there is nothing that has been saved due to the fact that the system has now undone that save point.
Set transaction command
This command is going to be used to indicate a transaction that was made on the data base. This command is going to need to specify the different charactersistcs from the transaction.
So if you are only wanting to read your transaction, you are going to need to specify that.
Code
​SET TRANSACTION [READ WRRITE | READ ONLY ] ;








Chapter Seven
Sub Queries That Are Done Inside of SQL
A sub query is also known as an inner query or a nested query. In essence, it is a query that is going to be inside of another query that has been embedded inside of a where clause.
Sub queries are going return data that came from the query that initiated the proccess due to a condition that is set to restrictand data that will be displayed.
You will use update, delete, select, and insert for your sub queries while also using the basic math operators and the in and between operators.
When you are using subqueries you will have some rules that you will need to follow:
You need to enclose your subqueries in parentheses There can only be one column inside of the select clause. That is unless you have selected multiple columns when you made your main query. The order by command is not going to be able to be used in a subquery, but it can be used in the main one. A subquery has the ability to return more than one row so that it can be used with a variety of operators. Select list cannot be used for any reference to the values that are being evaluated. You cannot enclose a subquery in a set function The between operator does not have the ability to be used in a subquery. 
Subqueries with a select statement
Subqueries are going to be used with select statements.
Code
​SELECT column_title [, column_title ] 
​FROM table 1 [, table 2 ] 
​WHERE column_title OPERATOR 
​(SELECT column_title [, column_title ] 
​FROM table 1 [ , table 2 ] 
​([ WHERE ]) 
Example
If you have your employees titles, ages, countries of birth, and their hire date all in a table, you will code to get it to where you are going to only see a set of data that you are trying to locate.
So if you are trying to see everyone that is under the age of 56:
​Select 
​From employees 
​Where age in ( select age 
​From employees 
​Where age > 45) ; 
Subqueries using an insert statement
You can also use a subquery in an insert statement. This statement is going to use the data that you get and place it into a different table. This data that comes from the subquery is going to be able to be modified with the characters, dates, or number functions.
Code
​INSERT INTO table_title [ (column 1 [, column 2 ] ) } 
​SELECT [ * | column 1 [ , column 2 ] 
​FROM table 1 [, table 2] 
​[WHERE VALUE OPERATOR ] 
Example
Going back to the example we just used, you are going to have a table that is going to be similar to the table that you were just working with, all you are going to do is copy the table in order to get a new table.
Subqueries and the update statement
You can use your subquery with your update statements. You are either going to be using multiple or single columns that are located inside of the table that needs to be updated through the use of a subquery.
Code
​UPDATE table 
​SET column_title = new_value 
​ [ WHERE OPERATOR [ VALUE ] 
​ (SELECT COLUMN_TITLE 
​FROM TABLE_TITLE) 
​ [ WHERE ) ] 
Subqueries and the delete statement
Subqueries are able to be used when you are using a delete statement just like any of the statements that have been mentioned above.
Code
​DELETE FROM TABLE_TITLE 
​ [WHERE OPERATOR [ VALUE ] 
​ (SELECT COLUMN_TITLE 
​FROM TABLE_TITLE) 
​[WHERE) ] 








Chapter Eight
Four Tips That Make Using SQL Easier!
Changing the language on the user interface: close out the program if you have it open and then go to the installation folder. You will right click on the short cut that is on your desk top and open the file location. From there you will open the SQL developer folder and then the first folder that is listed will need to be opened nexted. The next thing that you are going to click on is the SQL developer.conf. You can use any text editor that you are comfortable with using to change the language. You are going to be adding in a new setting inside of the text that is already there to change the language to what it is that you are wanting to see. You can put this new setting anywhere. Putting a comment in the code is going to be a good idea so that you know what you have done if you have to get back into it at a later date. You will AddVMOption before adding in the Duser.lanaguage and you can set it to any language that you are wanting. Now reopen your SQL developer and it will be in the language that you want it in. Constructdata base connections: right click on the connection on the left of the screen and click on new connection. You will need to title the connection whatever it is that you want. You will need to enter the usertitle and password for it. You should change the color if you are going to be working with multiple connections at once. In the role you are going to change the role if you are using a system connection title. You can leave the home host alone if you are using your home computer. However, if you are using a different location, you will need to input the IP address for where the system is going to be running. Leave your part alone and xe should be left alone as well unless you are not working with an express edition of SQL. You can test the connection and if it is successful, you can close the connection down and you have created your connection. If everything is correct it is going to open with no errors and you are going to be able to put in SQL code. Disabling features: there are a lot of features that SQL offers and if you do not use them, then you should disable them so that they are not slowing down the developer. You will go to the tools menu and go down to the features option. Each feature has different folders, it is up to you to decide which features you want to keep running and which ones you want to disable. You can expand each folder down so that you are able to see what each folder contains. All you are going to do is uncheck the feature and it will turn that feature off and cause the system to start to run faster. Be sure that you are going to apply the changes so that they are not turning themselves back on without you turning them on yourself. Executing commands and scripts: use the tool bar that is at the top of the developer and press the play button. Make sure that you have added in your semi colon. You can also use ctrl and enter so that you are not having to pull your hand off the keyboard. To run a script, you are going to you can use the toolbar again just select run scrpts so you run both commands. Or, press the F5 key if that is easier for you. Should your file be external use the at sign and the path file to import it and run it.







Conclusion
Thank for making it through to the end of SQL, let's hope it was informative and able to provide you with all of the tools you need to achieve your goals whatever it may be.
The next step is to get start using SQL. Remember that learning SQL is going to be difficult, but it is going to be well worth it in the end because learning SQL is going to make you a major asset to any employer because they are going to be able to hire you to do one job rather than hire two people to do the same job but separately.
Learning SQL may seem a little difficult at first, but the longer that you practice it, the easier it is going to be for you to understand. You are going to make mistakes, and that is normal, however, do not let these mistakes stop you from continuing in your practice and in your learning. 








SQL Tips and Tricks

Tips and Tricks to Learn SQL Programming Quickly and Efficiently 
DANIEL JONES 







Introduction
The following chapters will discuss some of the ways that you are going to be able to use SQL more efficiently. The hope is throughout this book you are going to be able to find ways that are going to make using SQL easier so that it is not quite as complex.
If you read the beginner's guide, you know that SQL is going to make your life that much easier not only by opening more doors for you as far as employment goes, or you are going to be able to push your own business forward if that is what you are using it for.
So, with this book, we are going to keep adding on and make it to where using SQL is easier to use and you are able to advance your knowledge!
There are plenty of books on this subject on the market, thanks again for choosing this one! Every effort was made to ensure it is full of as much useful information as possible, please enjoy!







Chapter One
Comma-Delimited Output
When you are trying to get, data returned, you are going to probably want it returned as a comma-delimited output so that it is not in a set. In order to do this, you are going to use your cursor and select the column that you wanted to change.
At this point, all of your rows are going to be returned with the cursor and then tied together into the variables that are in the rows each variable being separated by a comma.
Example:
Declare family names cursor for
Select [family name] from [odb] . [family] order by [family name]
Declare @family names varchar(50)
Declare @family name varchar (20)
Open family names
Fetch the next one from family names into @family name
While @@gather_status = 5
Begin
Set @family names =nothing (@family names + ', ', ' ' ) + @family name
Fetch the new one from family names into @family name
End
Close family names
Disregard family names
Select @family names into family name
Go
Okay, that is a lot of code and makes it seem quite complicated, right? So, what happened to SQL supposed to be making it easier to work with for business and making it to where you can save time by using SQL over programs such as Microsoft Excel?
Much like anything else, there are multiple ways that you are going to be able to do the same thing. But, before we go into the simpler way to do the same exact thing, let's examine some of the outcome for the previous example.
Example result:
Family name
Bob, Jim, Tim, Seth, Nate, Andrew, Zander, Luke, Oscar, Frank
The outcome is simple, but the code is not, however, as mentioned, there is a simpler way to do the exact same thing and not even have to use a cursor.
Example
Declare @family names varchar(50)
Select @family names = nothing here (@family names + ' , ' , ' ') + [ family name]
From [odb]. [family name]
Order by [family name]
Select @family names as family name
Go
Seems a little easier does it not? Your result is going to be the same as the last example because you used the same code, but changed it to be shorter and simpler.
Depending on if you want to use the cursor method or not will depend on if you want to use the long code or the short one.
Let's look at another example.
If you are working with a table that has ten different objects on it that are identified by an id number. Out of those ten items, you will have two different parent ids that everything falls under.
So, your result will be the two parent categories with every symptom listed under it. So, to make it easier for you to be able to know which parent the symptom belongs to, you are going to be able to write the parent id and then put a colon before you list the symptoms out.
It would be something like this:
Cold: cough, stuffy nose, body aches, headache
Migraine: pain, light sensitivity, fatigue, noise sensitivity
The select statement is considered to be a function that is defined by the user. However, you have to create it first so that you are going to get the result that you are wanting with the ids that were in the table that we just discussed. By forcing the system to give you a comma-delimited output without the use of the cursor then the function is going to look different.
Example
Create function [odb]. [fun_symptomsofcold] (@id nit)
Return varchar (120)
As
Begin
Declare @symptoms of cold varchar ( 120)
Select @symptoms of cold = nothing there (@ cold symptoms + ' , ' , ' ' ) + [symptom]
From [odb] . [cold symptoms]
Where [ parent complaint] = @id
Return [ cold symptoms]
End
Go
But to get that same example given back in the form of a select statement, you are going to change how your code looks.
Select [ symptom ] , [odb] . [fun_coldsymptoms] ([ parent id] )
From [ odb]. [cold symptoms]
Where [id for parent] includes nothing.







Chapter Two
Figuring Out the Missing Values That are Used for Identity
With a few tables, there are identities that are going to be missing from the table. The ids that are not in the table are going to cause there to be gaps in your table which not only makes your table look messy, but can cause there to be some confusion if the ids are not following numerical order.
In order to create sequential identity columns that are not going to contain gaps between any records whether they are existing records or newly created, you are going to have an id for every object that is located in the table.
Before you are going to be able to make sure that this is going to work, you are going to need to make sure that you are able to identify what the missing ids are. If you do not know what the missing ids are, then you could end up assigning the wrong id to the wrong object and thus causing your table to become screwed up and not work as it should.
There are three ways that you are going to be able to locate the identity that is missing in your table so that you can complete it.
The first thing that you are going to need to do is create a table that is going to be populated with values that you have chosen to be inputted into the table.
Example:
Create table #animals (
[ id] identity,
[ animal name] varchar ( 45 ) )
Now that your table has been created, you are going to be able to fill it out so that it has all of the data that it is supposed to.
Example
Insert into #animal ( [ animal name ] ) value ('tiger')
Insert into #animal ( [ animal name ] ) value ('lion')
Insert into #animal ( [ animal name ] ) value ('bear')
Insert into #animal ( [ animal name ] ) value ('dog')
Insert into #animal ( [ animal name ] ) value ('cat')
Thanks to the select statement, your results are going to be something like this:
1: tiger
2: lion
3: bear
4: dog
5: cat
However, as we are trying to discover how we are going to be able to replace the missing ids, so we are going to continue with the example that we have just set up and this time we are going to assume that there have been some of the records that were deleted.
Example
Delete from #animals where [ id ] in ( 2, 5)
Select * from #animals
With the code that is listed above, you have just told SQL that you want the second and fifth ids to be deleted form the table. This is going to cause your table to look different.
Example
1: tiger
3: bear
4: dog
It is quite obvious to see that there are some identities that are missing from this list. One of the methods that you can use in order to figure out which of the ids are missing is to go through the values and loop them through the table starting with one and going up to the highest number that is in the table.
Example
Declare @ id nit
Declare @maxid nit
Declare @missing animal ids on the table ( [ id ] nit )
Select @maxid = highest id from #animals
Set @ id = 1
While @id <= @maxid
Begin
If you cannot find the value (place x into #animals
Where [ id ] = @id)
Insert the missing ids into the @missing animal ids
Values ( @id )
Set @ id = @id increasing by 1
End
Select * from @missing animal ids.
From here, the values that are not in the table are going to be placed into the table temporarily so that they can be processed at a later time. Your output is going to be the ids that are not in the table because they have been deleted.
Output:
2
5
Just like stated earlier, there are going to be other methods that you can use to get the values that have been deleted from your table so that the identities can be restored and the table is whole once again.
Another way that you can do this is to make a temporary table with a single column with all of the values that could be the missing identity. You are going to want to start at one and go to the highest value that is in the table that you are trying to fix.
Example
Declare @temporary table ( [id] nit )
Declare @id nit
Declare @highest id nit
Select @highest id = [ id ] from #animals
Set @id = 1
While @id <= @ highest id
Begin
Insert into @temporary table ( [id])
Values ( @ id)
Set @ id = @id increasing by 1
End
Select A. *
From @temporary table left out join # animals
On A. [ id ] = B. [ id ]
Where B.  [ id ] has nothing
What you are doing with this code is putting it into a table that only has a single column where all the possibilities for the ids are going to be listed up until you have reached the highest number that is on the table.
However, that is not the only thing that this code is going to do. You are also going to be adding the current table to the table where the variables have been deleted so that you can try and identify any of the possibilities for the ones that are missing. Left outer join will be used when the identity that has been deleted has been located and is checked to ensure that it is the correct id. If it is not the correct id, then the id is going to be null.
So, a table that has been defined by the user is going to be created which is going to return the exact same data that you were wanting previously to figure out which of the ids has been deleted.  







Chapter Three
Random Numbers Being Generated
There is a function that has been built into SQL that is going to make it to where random numbers are generated with the rand() function. This function is a mathematical function that will be returning a float value that falls between zero and one. There is an option you can use that is going to seed the parameter which will give you an integer expression. The integer expressions are known as int, smallint, and tinyint that is going to give you a seed or the value that you are going to start at.
In order to do that you are going to use the select statement.
Syntax:
Select rand() as [randomnumber] 
When you use this code, you are going to be getting a result that the select statement is generating. Keep in mind that you are most likely going to get different results each time which is a good bet the name is random numbers!
Example
Randomnumber
0.25895364824842125
Each output that is sent with this function is going to fall between zero and one as we have already stated. When random numbers are generated, you will need to multiple the result that you get by the maximum number that you are wanting to be generated so that you can get rid of the decimal places.
To get rid of the decimal places, you can use a cast with the int.
Example
Select cast (rand() * 5000 as int as [random number ]
And your result is going to be
5311853
Downsides to RAND
When you are using rand, you need to keep in mind that it is going to work if the seed parameter has been passed through it so that the output comes out as the same each time.
Example
Select rand(4) as [ random number ] 
When you run this statement several different times with the parameter of one, you are always going to get the same result each time that it is returned.
You should keep in mind that when you are using the rand function, it will need to include a select statement so that a value is returned inside of every row and that they are all the same no matter what object it is tied to.
Example
Select bottom five rand() as [ random number ] , [book title], [ book author], [book genre] from [odb]. [books] 
Note: The repetitive invocations that you see when using the rand() function inside of a single search is also going to give you the same value each time that you use it.
Newid()
There is another method that you can use to generate random numbers that does not include you using the rand function. With the newid function, you can then generate a random number that is going to still work with the select statement.
Syntax:
Select abs(cast (cast( newid() as varbinary) as int )) as [ random number ] 
This function will result in in a value that is unique and known as an uniqueidentifier data type. This will then convert the data into an integer after it has been converted to a binary variable. The integer that you get will either be positive or negative as all integers are going to be.
Should you want a positive return, you need to be sure to use the absolute value function. Negative functions will remove the absolute value so that it is not going to be returned positive.
Example (the number you get is going to be different than the number here.)
Random number
5648975
By using the select statement, you are going to also use the newid function so that you get a random number for all of the objects in the table that you are working with.







Chapter Four
Generating Random Records
Generating random records is going to be helpful when you are wanting to randomly pick some of the data that is in your table out so that you can say, pick a winner for a contest or something like that.
Newid()
Once again you are going to want to use the newid function. Just like in the last chapter, the newid function is going to create a uniqueidentifer value that is unique. You are not going to need to create a new column to get random records generated, all you have to do is use the newid function with the select statement to have a random record generated.
Example:
You are wanting to pick three employees to participate in a special project. You will first use order by newid() within the select statement. Being that we are only wanting three records to be pulled, you are going to need to make sure that you tell the system that you only want three records.
Select any  [ employees ] , [ employee department ], [ phone number ] 
From [ odb ] . [ employees ] 
Order by newid ( ) 
By running this code, you are going to get the employee's name, department, and their phone number.
By doing the same search again, you will get a different set of results because of the newid function.
Rand () function
As you have learned, the newid function gives you random results each time that you use the function. But, is there another way that you can get the same results by using a different function?
Example
Say that you want to use the rand() function instead. Your code is going to look a little something like this.
Select any  [ employees ] , [ employee department ], [ phone number ] 
From [ odb ] . [ employees ] 
Order by rand ( ) 
Obviously, you are going to get a set of five employees names after you have run the code through the system. But, if you run it again, you are going to end up with the same results that you got the first time.
So, you cannot use the rand function and expect to get truly random records each time that you run it. You are better off using the newid() function so that you can ensure that you are going to be getting random records each time.







Chapter Five
Sorting Through IP Addresses
When you are working with a table of IP addresses and you discover that they are stored in a character data type with only twenty characters allowed in each row, you are going to want to change how your table is sorted by IP addresses. IP addresses are going to be in a different data type which means that instead of using varchar, you are going to be using the numerics.
Example
Create table [ employee computer ] ( [ IPAddress ] varchar (20) )
Insert [ employee computer ] ( [ IP Address] ) value ( '96.458.1.1')
Insert [ employee computer ] ( [ IP Address] ) value ( '458.48.0.1')
Insert [ employee computer ] ( [ IP Address] ) value ( '999.4.2.0')
At this point you are going to sort your records out by IP address.
Select [ IP address ] from [ employee computer ]
Order by [ IP address ]
458.48.0.1
96.458.1.1
999.4.2.0
Now that you have the IP addresses organized by number, you are not necessarily going to know what varchar is going to go to it. When you examine some of the output, it is going to seem odd that the 458 comes before 96 because when you examine some of the number line, 96 very obviously comes before 458. However, 4 comes before 9 and that is why it is listed in that fashion.
Parsename systems
When you sort out IP addresses, it is going to be easier by using the parsename function because the whole purpose behind this function is to return parts of the objects name to the parts of the object that belong to that name. These objects are things like the data base name and the name of the server.
Being that naming in SQL of objects is going to be similar to when you are naming IP addresses, you are going to need to use a period in order to keep each part separate. There are going to be at least three different periods that you are going to use whenever you are using the parsename function.
A great thing about working with the parsename function is that you are not going to know if the object that is beside the name actually exists or not, you are only getting a return of that part that you have inputted into the program.
As you are using parsename you are going to need to use the select function as well.
Example
Select [ IP address ] from [ employee computer ]
Order by cast (parsename ( [ IP address ] , 1 as nit) ,
Order by cast (parsename ( [ IP address ] , 3 as nit) ,
Order by cast (parsename ( [ IP address ] , 2 as nit)
Output
96.458.1.1
999.4.2.0
458.48.0.1







Chapter Six
Name Splitting
If you are using SQL for business you may have the names of your employees or customers in your data base. Having this data usually means that you have their first and last name so that you do not get John Smith mixed up with John West. However, you can use SQL to split the name so that it is in two different columns. There are three strategies that you can use to do this.
Substring function
The first way to split the names that are in your table is to use the substring function.
Example
Declare @employee name varchar (250)
Set @employee name = John West
Select substring (@employee name, 2 charindex( ' ' , @employee name)  -0 as [ employee first name],
Substring (@employee name, charindex (' ' , @employee name) + 2, nel(@employee name)) as [ employee surname ]
Output
First name: John
Surname: West
The charindex is also used whenever the substring function is used. This index will return the position in which you started so that you get a specified expression in your character's string. Charindex is used when you are looking for the space that is supposed to fall between the two names.
Should a full name only have the surname, then you are going to end up getting an error message because you are trying to get data from the table that does not exist thus is not going to be found.
In order to avoid getting this error message, you are going to need to modify your previous script so that the program does a check to see if there is a space that falls inside of the first name. if there is no space, then your code is simply going to return the surname.
Example
Declare @employee name varchar (250)
Set @employee name = JohnWest
Select substring (@employee name, 2 charindex( ' ' , @employee name)  -0 as [ employee first name],
Substring (@employee name, charindex (' ' , @employee name) + 2, nel(@employee name)) as [ employee surname ]
Output
First name: nothing found
Surname: JohnWest
Left and right functions
When using the left and right functions, you are going to be doing the same basic operation that you were doing with the substring function. In using the left function, you are going to get part of the character returned to you based on how many spots you want it to go over. The right function will do the same thing but from the right side of the expression.
Example
Declare @employee name varchar (250)
Set @employee name = John West
Select substring (@employee name, 2 charindex( ' ' , @employee name)  as [ employee first name],
Substring (@employee name, charindex (' ' , @employee name) + 2, nel(@employee name)) as [ employee surname ]
Output
First name: John
Surname: West
To get the first name by using the left and right function, you are still going to be doing something similar to the substring function, however, you are not going to need to put in a starting point because the program will automatically start at the first position that is available.
When you are trying to get the last name, you are going to be using the right function. There are two parameters to the right function that are going to have to be met in order for the correct character set to be returned.
If you do not want to get an error message for this method, you are going to need to modify your script yet again so that it works properly thus letting the program know that you are not wanting a space to be put in between the names.
Example
Declare @employee name varchar (250)
Set @employee name = John West
Select left (@employee name, nullspace (charindex( ' ' , @employee name) -9, -9)) as [ first name],
Right (@employee name, isempty( nullspace(charindex( ' ' , turn around ( @employee name)) -6, -6),
Nel (@employee name ))) as [surname ]
Your output is going to be the same as when you were using the substring technique.
Parsename function
Surprisingly you are able to use the parsename function to split the name as well.
Example
Declare @employee name varchar(250)
Set @employee name = 'John West'
Select parsename (return(@employee name, ' ' , ' . ' ) , 3) as [first name],
Select parsename (return(@employee name, ' ' , ' . ' ) , 6) as [surname]
Just like when you used the parsename function when sorting IP addresses you are going to get a very specific output. Your output is going to be the employees name.







Chapter Seven
Searching Excel Spreadsheets with SQL
If you do not want to use DTS in order to search through an Excel file, you can use the function known as openrowset. This function is going to be connecting all the information that you are going to need in order to access a data source that is not inside of SQL.
Openrowset is going to be used in order to reference the from clause that you use when searching through the different tables that are in your data base. You can also use the insert, update, and delete functions but those will be discussed at a later time.
Syntax:
Openrowset ( 'giver_name', 
{ 'datasource'; 'user_id'; 'password' |  'giver_string' }, 
{ [ catalog, ] [ schema, ] object | 'search' } 
) 
However, the only thing that you really need to worry about is this when you are working with openrowset
Openrowset ( ' giver_name' , 'giver_string', 'search' ) 
The giver name is going to be the data base that is providing the data that you are looking at. When using Microsoft Excel, it is going to be the name of the Excel sheet that you are working with.
Giver string is the string that is going to be created by the giver that makes sure that there is a connection between SQL and the giver.
Search is the string that is going to be sent and ultimately carried out by the giver so that you can search through what it is that you are looking at. SQL is not going to process your search because technically what you are looking at is not inside of the SQL data base.
Searching an Excel worksheet
If you have a file that you are wanting to work with that holds all of the phone numbers for your vendors. But, you want to search through the file so that you can reach out to them about business.
In SQL, your code is going to look a little something like this.
Select * 
From opemrowset (' Microsoft. Excel. Bedol. 5.2', 
'worksheet 5.3; data base = D: \ input \ phone numbers.xls' , 
'select *from [ sheet 4 $] ' ) 
The code tells SQL what it is that you are wanting to look at. Be sure that you include the dollar sign or else you are going to end up getting an error message that ends up telling you that the program cannot process your request and open the Excel worksheet that you are wanting to be opened.
But, if you do it properly, you are going to get the worksheet that you are looking for with the data that you are wanting to look at.
Make sure that the file is inside of the SQL server or else you are going to get another error message. You should also ensure that you are connected to the location where your SQL server is located instead of the machine that you are working with. If your server is on the machine that you are working with, then you are going to be fine. However, it is imperative that you work with the location that contains your SQL server for this because you are pulling information from an outside source.
Searching an Excel sheet without the use of a header while containing different data types
If you are wanting to search through an Excel spreadsheet or to read it but it does not have a column that is containing the header, your giver string is going to be found in the HDR. Being that your HDR is not going to be specified, your giver is going to the column header.
In order to get the specific giver from your Excel worksheet even though it does not have a header, you are going to add HDR=none into the string.
Example
Select * 
From opemrowset (' Microsoft. Excel. Bedol. 5.2', 
'worksheet 5.3; data base = D: \ input \ phone numbers.xls' ; HDR= none 
'select *from [ sheet 4 $] ' ) 
Since you do not have a column header, each column is going to have a name assigned to it which is going to usually be F1 through the number of columns that are in your table. So, if you have a hundred columns, you are going to have F1-F100.
Searching in an Excel worksheet that has mix data types in the columns
When you are looking at some tables in SQL you may notice that there are some spaces that are null. This usually happens because the giver attempts to guess what it is that should go there based on what it found in the Excel worksheet. This is all done after the system tries to figure out what sort of data is in the table's column and once that has been determined, if there is a no data type that matches what the server found, your result will be null. 
When you are working with different data types you are going to work with the intermixed property.
Syntax
IMEX = 1 
Importing Excel files into SQL
As you have already seen, you can use SQL to look at Excel files with the openrowset function.
Using this function is going to make sure that all of the information that is needed to get to the source is connected correctly. However, there is a way that you can temporarily get ahold of the information by linking the server one time so that you can examine some of the Excel worksheet. You are going to use the from clause. This clause is used to search for the table name so that you are able to do things such as update, delete, and insert data into the file.
In order to import Excel files, you are going to use a code that looks similar to this.
Example
Select * 
From opemrowset (' Microsoft. Excel. Bedol. 5.2', 
'worksheet 5.3; data base = D: \ input \ phone numbers.xls' , IMEX=1, 
'select *from [ sheet 4 $] ' ) 
However, if you want to import the same worksheet without using the DTS so that you are only able to read the data that is in the spreadsheet, you are going to use the select statement as you have been, but you are going to still use your from clause but you will also use an into clause so that the records are placed into a new table on SQL.
Example
Select *
Into [ odb]. [temporary file]
From opemrowset (' Microsoft. Excel. Bedol. 5.2',
'worksheet 5.3; data base = D: \ input \ phone numbers.xls' ,
'select *from [ sheet 4 $] ' )
With the code above, you are going to be making a temporary table in SQL from the data that is located in the Excel spreadsheet.







Chapter Eight
Executing SQL Scripts in Batches
As you work with script in SQL, you are going to have scripts that are going to have their own purpose. For example, you have one script to create a table, one to delete a table, and one for creating functions.
When it comes time to carry out the scripts, you have to do it manually because there are usually several different scripts that are open and needing to be executed by the program. However, what if there was a way that you could make separate scripts that all do something different and are going to work without you having to manually get them to start. It will make your code more complex, but you are not going to be risking the chance that you are going to forget to run a script and get the wrong results.
Example
Create table ##files from the server ( file name varchar (5)) 
Go 
Insert into ##files from the server 
Execute file dob.px_shelldem 
Go 
You can have several more codes in the prompt to be run and they are all going to run as they are supposed to without you having to go in and manually do it. But, you need to ensure that you are putting the go after each code so that the program knows that you are wanting the code to be run the way that it is supposed to be run.
There is no limit to how many codes that you need to have in your prompt, you can have two codes or you can have ten, they are all going to get run as long as you are putting them into your prompt correctly and being granted permission to be executed.







Chapter Nine
Date Formats with the Server in SQL
With SQL, you are able to do a date and time in columns and they do not have to all be in the same format. In order to do this, you are going to use the convert function.
You should keep in mind that the output for each of the format you are going to be using varchar and not the datetime data type like you might think that you would.
Date formats
Default format for SQL
Syntax: select convert (varchar (20), get date(), 100) 
Output: month, date, year, hour: time
MM/ DD/ YY
Syntax: select convert (varchar (8), get date(), 1) as [ MM/DD/YY] 
MM/DD/YYY
Syntax: select convert (varchar (10), get date(), 101) as [ MM/ DD/ YYYY] 
YY.MM.DD
Syntax: select convert (varchar (8), get date(), 2)  as [ YY/ MM/ DD] 
YYYY. MM. DD
Syntax: select convert (varchar (10), get date(), 102)  as [YYYY/ MM/ DD] 
DD/MM/YY
Syntax: select convert (varchar (8), get date(), 3)  as [ DD/ MM/ YY] 
DD/MM/YYYY
Syntax: select convert (varchar (10), get date(), 103)  as [ DD/ MM/ YYYY] 
DD.MM.YY
Syntax: select convert (varchar (8), get date(), 4)  as [ DD. MM. YY] 
DD.MM.YYYY
Syntax: select convert (varchar (10), get date(), 104)  as [ DD. MM. YYYY] 
DD- MM- YY
Syntax: select convert (varchar (8), get date(), 5)  as [ DD- MM- YY] 
DD- MM- YYYY
Syntax: select convert (varchar (10), get date(), 105)  as [ DD- MM - YYYY] 
DD MON YY
Syntax: select convert (varchar (9), get date(), 6)  as [ DD MON YY] 
DD MON YYYY
Syntax: select convert (varchar (11), get date(), 106)  as [ DD MON YYYY] 
MON DD YY
Syntax: select convert (varchar (10), get date(), 7)  as [ MON DD YY] 
MON DD YYYY
Syntax: select convert (varchar (12), get date(), 107)  as [ MON DD YYYY] 
HH: MM: SS
Syntax: select convert (varchar (8), get date(), 108)  
MON DD YYYY HH: MI: SS:MM
Syntax: select convert (varchar (26), get date(), 109) 
MM-DD-YY
Syntax: select convert (varchar (8), get date(), 10)  as [ MM- DD - YY] 
MM- DD- YYYY
Syntax: select convert (varchar (10), get date(), 110)  as [ MM- DD- YYYY] 
YY/ MM/ DD
Syntax: select convert (varchar (8), get date(), 11)  as [ YY/ MM/ DD] 
YYYY/ MM/ DD
Syntax: select convert (varchar (10), get date(), 111)  as [ YYYY/ MM/ DD] 
YYMMDD
Syntax: select convert (varchar (6), get date(), 12)  as [ YYMMDD] 
YYYYMMDD
Syntax: select convert (varchar (8), get date(), 112)  as [ YYYYMMDD] 
DD MON YYYY HH: MM: SS: MMM
Syntax: select convert (varchar (24), get date(), 113)  
HH: MI: SS: MMM
Syntax: select convert (varchar (12), get date(), 114)  as [ HH: MI: SS: MMM] 
YYYY- MM- DD HH: MI: SS
Syntax: select convert (varchar (19), get date(), 120)  
YYYY- MM- DD HH: MI: SS: MMMM
Syntax: select convert (varchar (23), get date(), 121)  
YYYY- MM- DDTHH: MM: SS: MMM
Syntax: select convert (varchar (23), get date(), 126) 
DD MON YYYY HH: MI: SS: MMMAM
Syntax: select convert (varchar (26), get date(), 130)  
DD/ MM/ YYYY HH: MI: SS: MMMAM
Syntax: select convert (varchar (25), get date(), 131)








Chapter Ten
Set vs Select and How They Work When Assigning Variables
When youa re assigning variables in SQL, there are two different ways that you can use. You already know that you can use the declare function, but how do you know if you are supposed to use the set or select function?
Most of the time you are going to use both. However, there are a few times that you will use one or the other or you are going to use the same one twice in the same code block. Let's examine some of the difference and some examples!
Set:
ANSI: this is the standard for when you are assigning variables with the set function.
Assigning a single variable at a time:
Set @index = 4 
Set @loopamout = 455 
Set @initialnumber =8 
Assigning a variable froom a search after you have gotten no result. The null value is then going to be assigned.
Declare @ employee name nchar (9) 
Set @ employee name = abc 
Set @ employee name = ( select [employee name] 
From [dob]. [employees] 
Where [employee name] = dce 
Select @employee name - result is empty
Assigning values after a search wehre multiple values are returned. However, set is going to fail and result in an error
Set = (select [ employee name] 
From [dod]. [employees]) 
Ms 548, level 5, state 9, line 2 
Search returns multiple values
This is not allowed when using subsearch
Follow the operations or when the subsearch is being used as an expression.
Select
None ANSI the standard for assigning variables when using select
Assigning more than one variable at a time 
Select @index = 5 @loopamount = 54 
@initialvalue = 4 
Assigning values from a search and the search gives no result so there is not going to be any change to the variables that are being used.
Declare @ employee name nchar(6) 
Set @ employee name = abc 
Select @ employee name = [ employee name ] 
From [ dib]. [employee] 
Where [employee name ] = jef 
Select @ employee name returns abc 
When you are assigning a value from a search and you are given more than one value the last value is gonig to be assigned and the program will hide that there was ever another value returned.
Select @ employee name = [ employee name] 
From [ odb]. [employee] 








Chapter Eleven
The Len String Function in SQL
Using the len string function is going to return a set number of characters rather than returning a number of bytes that are going to be specific to the string that you are working with. This is not going to include any trailing blanks. When you are wanting to figure out the number of bytes that are in an express where the data length function will be used.
Syntax
Len ( <string_expression> ) 
Your string expression is going to be the parameters that are set into place by the string function. It is also going to be able to evaluate any data type that you are able to convert into the varchar data type.
Example
Counting the occurances of a character inside of a string 
Declare @data varchar (20) = "SpongeBob is a yellow sponge" 
Declare @characters char(2) = S 
Select len (@ data) - len (replace(@data, @characters ' ' )) as [character amount] 
Amount
2
Example
Counting the occurrence of a string in a string value 
Declare @data varchar(100) I want, you to want me. I need you to need me. 
Declare @string var char (52) I 
Select (len(@data) - len(replace(@data, @string, ' ' ))) / len(@string) as [string amount] 
String amount
2
Example
Counting the number of words in a sentence
Declare @ data varchar(85)= I am going to jump over the log so that I can catch the cat. 
Select len(@data) - len(replace(@data, ' ' , ' ' )) +6 as [amount of words] 
Note: you are only going to make this work if each word has a space after it.
Amount of words
15
Example
Figuring out the rows that have the longest length
Select bottom 5 * 
From [odb]. [object] 
Order by len ([ details]) det 
Example
Figuring out if a string has trailing spaces
Declare @data varchar (6) = "Goodbye cruel world" 
Select case when len(@data + ' * ' ) - 2 != len(@data) 
Then 'with spaces that trail the input'
Else' no spaces that trail the input'
End as [there are trailing spaces]
Example
Counting the length of the string including the spaces
Declare @data varchar(6) = 'Goodbye cruel world" 
Select len (@data + ' ' ) -5 as [amount in string] 
Length: 5







Chapter Twelve
Keyboard Shortcuts for SQL
There are some short cuts that you are going to be able to use when you are working with SQL. These keyboard shortcuts are going to make it to where you can keep going through your code and not have to use the mouse to do what it is that you need to do and possibly lose your place.
Show the solution explorer: Ctrl + Alt + L 
Show the new file box so that a new file can be created: Ctrl + N 
Show the new project box so a new project can be created: Ctrl + Shift+ N 
Open the dialog box so that a file can be opened: Ctrl + O 
Change the name of an object that you have selected: F2








Chapter Thirteen
Moving Files in the SQL Data Base
You are going to be able to move files that are inside of your SQL data base however, there is going to be some downtime because you are having to manually move the files across the different data bases.
Detaching and attaching files
Here is where you are going to learn how to detach the file from the data base and move the file to a new location before we attach it there. Whenever the file becomes detached, it is no longer going to be available.
Step one: detaching the data base:
Example
Use surprise 
Go 
Ps_ detach_bd 'SQLServer 
Go 
Step two: move the files to a new location
Example
EcEx px_shelldmc 'Copy files" 
Go 
EcEx px_shelldmc 'Copy files" 
Go 
If you do not have the shell enabled or it cannot be enabled, then you are not going to be able to do this.
Step three: attach the data base
Example
Create data base SQL Server 
On (name of file = file name) 
(file name = file name for attach; 
The downtime is going to start as soon as you detach the file from the data base and it is going to depend on how long it takes you to reattach the data base. If it is a large data base, then you may not be able to actually copy the data base because there is too much data in it.
Altering the data base
When altering the data base, you are going take the data base offline completely. The alter data base function is going modify the location of the information found on the system that it is running on.
Step one: turning off the data base
Example
Alter data base [SQLserver] 
Turn off 
Start rollback instantly 
Go 
Step two: move the files to a new location
Example
EcEx px_shelldmc 'Copy files" 
Go 
EcEx px_shelldmc 'Copy files" 
Go 
Step three: change the data base so that it shows the new location
Alter data base [ SQL Server] change file ( name = SQL Help] file name = new location 
Go 
Alter data base [ SQL Server] change file ( name = SQL Help] file name = new 
Go 
Step four: turn the data base back on
Alter database [SQL Server] 
Turn on 
Go 
Downtime in this is going to start whenever the server is taken offline and then quit once it is back online.
Back up and restore
Should you be working with larger data bases they are going to require extra downtime to make sure that everything gets moved to where you want it to be moved. Because it is going to take a longer amount to time, you may come across the program or the system crashing. In order to save all of data that is in the data base should this happen you need to make sure that you back up all of the system so that the data can be restored. This ensures that you have all your data and you do not have to worry about losing it.
Step one: back up the entire data base
Example
Create first 
Go 
Back up data base [SQL Server] to 
This disk 
Formatting itni 
Go 
Step two: restore the back up as a separate data base
Use first
Go 
Back up data base [SQL Server] to 
This disk 
Do not include recovery 
Move this data base to this new location 
Move this data base to this new location 
Go 
Step three: examine some of the log that includes no recovery
Back up log [SQL Server] 
To this disk 
Do not truncate and format itni 
Do not include recovery 
Go 
Step four: restore the log to the back up using a recovery method
Restore the log to the server 
Pull it from this disk 
Include the recovery 
Go 
Step five: remove the old data base and rename the new one
Remove data base 
Go 
Rename data base SQL Server to SQL Help Server 
The downtime will start whenever the last log back up is performed and you use the no recovery function. It will end after you rename the new data base.







Chapter Fourteen
Generate data with the Recursive in SQL
One of the most common exprssions that you are going to use is the common table expression otherwise known as CTE. This is going to be referenced to when you do a sub search in Oracle. Using the is method is the only way that you can declare a variable in SQL besides using the obscure window clause.
Example
Variables in the table 
With 
Table 1( variable 1, variable 2) as ( 1 and 2) 
Table two (width 3, width 4) as ( 
Select variable 1 * 3, variable 2 * 4 
All from table 1 
) 
Select * 
From table 1, table two 
Your going to end up with the result of 3 and 8 
In using the with clause, you are going to be able to pick out which of the variables on the table that are going to be dependent on each other. It is going to be easier to understand by using the CTE and by using the CTE, you are going to make variables recursive.
Example
With recursive s(v) as ( 
Select 3 -row seed 
Unite all variables 
Select v +6 -recursion 
From s 
) 
Select v 
From s 
Limit 9 
You are then going to get an output that starts at 3 and goes up to 9.
In essence, you aer going to be defining your table's expression so that the subqueries are all united.
The first union of the subqueries is going to be the seed row that is going to initialize the recursion. There can be several rows that are prodced which will then be recursed. You have to keep in mind that everything in your table is going to be recursed and not just indiviual rows or variables.
The second subsearch is going to be when the recursion actually happens.







Chapter Fifteen
Commands You Need to Remember when Using SQL
ALIAS
Sometimes you can give a table or column name the use of an alias to the original name when it is too long or complex. Sometimes complicated or long names can end up costing you more time if you are unable to remember the original name. Longer names also present available chances for typos. In order to set up an alias for an existing table or column, the following syntax should be used as shown below.
For tables: 
SELECT column_name(s)
FROM table_name
AS alias_name
For columns:
SELECT column_name
AS alias_name
FROM table_name
You can even use an alias for individuals or a row. This can make your results appear less complicated and more clear. Below are two examples of what your results could look like without an alias and how they would look like with one.
How it looks without an alias:
SELECT Shipments.ID,
Clients.Last, Customers.First
FROM Clients, Shipments
WHERE Clients.Last= 'Smith' AND Clients.First= 'John'
How it looks with an alias:
SELECT po.ID, c.Last, c.First
FROM Clients AS c, Shipments AS po
WHERE p.Last= 'Smith' AND p.First= 'John'
You can see that the Shipments was replaced with the word "po" and clients were changed to "c". For beginners, this might make it a little complicated to read. For business owners with larger volumes of clients, this can shorten what is required of them to read and go over when they are searching data back to them.
ALTER
When you want to be able to add, delete, or modify any columns contained in an existing table, you can use the ALTER TABLE command in order to do so.
In order to add a column to a table:
ALTER TABLE table_name
ADD column_name datatype
In order to delete a column from a table:
ALTER TABLE table_name
DROP COLUMN column_name
You should keep in mind that some databases won't allow a column to be deleted by itself.
In order to change the data type of a column in an existing table:
ALTER TABLE table_name
ALTER COLUMN column_name
Datatype
For this command, if you wanted to be able to add a row into your table, you could use the following syntax example shown below.
ALTER TABLE Clients
ADD Since date 
The result will add an empty row to the Clients table and thereafter, you can enter the dates that they have been with you.
In order to change data types:
ALTER TABLE Clients
ALTER COLUMN Since year
datatype
In order to drop a column:
ALTER TABLE Clients
DROP COLUMN Since year
AUTO INCREMENT/ IDENTITY
You can allow a unique number to be created whenever new data is entered into a table. You can do this by using the AUTO INCREMENT command.
The syntax shown below shows an example of the syntax used.
CREATE TABLE Clients
(C_Id int NOT NULL
AUTO_INCREMENT,
Last varchar (255),
First varchar (255),
Address varchar (255),
City varchar (255),
PRIMARY KEY (C_Id));
The example defines the "C_Id" column to be an auto-increment key in the "Clients" table. This will allow the auto-increment feature. By default, the number that it starts out with will be 1 any time that you use the auto-increment feature. With each new entry of data, the total number will increase by 1. This can be used in your table in order to easily keep track of how many clients you have or the specific amount of entries.
In the case that you want the auto-increment feature to start out with another number besides 1, the following syntax example can be used as shown below.
ALTER TABLE Clients 
AUTO_INCREMENT=100 
This could be useful for specific reasons. Say you are a company that demands a new client that wants to become a member is required to buy a certain amount of products from you before they are a member. Or let's say that a client is buying a membership that costs a set amount. This can be used in order to easily and automatically keep track of how much is accumulated through those accounts.
The AUTO INCREMENT command is not necessary when entering new data into the "Clients" table in order to specify a value for the column.
INSERT INTO Clients (First,Last)
VALUES ('John', 'Smith')
Here is another statement example: 
CREATE TABLE Clients
(C_Id int PRIMARY KEY IDENTITY,
Last varchar (255) NOT NULL,
First varchar (255),
Address varchar (255),
City varchar (255));
The keyword IDENTITY will be used by the server in order for the auto-increment feature to be used. The starting out value will be 1 for the identity keyword and will increased by 1 with every new data entry. To be more specific, in the example, the "C_Id" column will start out at some specified value or increment. You are able to change the identity keyword by using (start, increment).
Using the IDENTITY is not always necessary when inputting a new data entry into the table.
INSERT INTO Clients (First,Last) 
VALUES ('John', 'Smith') 
As mentioned before, there are different versions of how to form syntaxes depending on what platform you use for SQL.
Access: 
CREATE TABLE Clients 
(C_Id PRIMARY KEY AUTOINCREMENT,
Last varchar (255) NOT NULL,
First varchar (255),
Address varchar (255),
City varchar (255));
Again, in the Access database, the default for the increment will be 1 and will increase by 1 with every new data entry. When entering a new record of data into the "Clients" table, it isn't necessary to have a specific value for the "C_Id" column:
INSERT INTO Clients (First,Last)
VALUES ('John', 'Smith') 
Oracle:
In the Oracle database system, the auto-increment field will have to be created with the sequence object. This object will generate a number sequence. In order to do this, use the CREATE SEQUENCE command.
CREATE SEQUENCE seq_client
MINVALUE 1
START WITH 1
INCREMENT BY 1
CACHE 10 
This will create a sequence that will automatically increase by 1 with each new data entry. In order to specify how many sequence values will be stored in memory and in order to attain faster access, the cache option is placed. In order to enter new data into the "Clients" table, the nextval function will be used to retrieve the next coming value from the seq_client sequence:
INSERT INTO Clients (C_Id,First,Last) 
VALUES (seq_client.nextval, 'John', 'Smith') 
This statement will insert a new record of data into the "Clients" table. In the example, the next number from the seq_client sequence will be assigned in the "C_Id" column. The "First" column would be set to "John" and the "Last" column would be set to "Smith".
BETWEEN 
You are able to select a range of data between two specified values by using the BETWEEN operator. The contained values can be numbers, text, or even dates. You can use the operator in the following syntax shown below.
SELECT column_name(s) 
FROM table_name
WHERE column_name
BETWEEN value1 AND value2
If you needed to be able to find data between the months of May and August of a table, you could use this operation. The example of the syntax is shown below.
SELECT * FROM Sales 
WHERE Date since 
BETWEEN 'May' AND 'August' 
This operator could be useful when you want to find the amount of sales you had between two specific dates.
In different databases, the BETWEEN operator can be formed differently.







Conclusion
Thank for making it through to the end of SQL Tips and Tricks, let's hope it was informative and able to provide you with all of the tools you need to achieve your goals whatever it may be.
The next step is to use what was learned inside of this book in your own workings with SQL.
These tips and tricks are not going to be used by every person that is using SQL. It depends on what you are using SQL for that will depend on if what you found inside of this book is going to work for you!
Be sure to be patient as you are working with SQL because it is not going to be learned over night, nor is it going to be a skill that you are going to pick up by just working with it a few times. Working with SQL is going to take a lot of time and patience before you are able to get the hang of it. But, learning it is going to advance your career more than you ever thought possible.
Finally, if you found this book useful in anyway, a review on Amazon is always appreciated!








SQL Beginner's Guide

Simple and Effective Strategies to Learn SQL Programming 
DANIEL JONES 







Introduction
The following chapters will discuss the various strategies that you can use while you work with SQL so that working with SQL becomes even easier than it was before.
There are plenty of books on this subject on the market, thanks again for choosing this one! Every effort was made to ensure it is full of as much useful information as possible, please enjoy!







Chapter One
Versioned Data
When you are working with versioned data, you are not going to be doing updates to your files, instead you are going to insert any new data that you need in that file. This makes it to where you can find the latest version of the file you want to work with. While it would seem like this is too complicated, what is actually done is that a new file is created and saved with the date of the change. The change to the table can be one row or several, it just depends on what you are doing.
In order to gather data from your code is going  to look very similar to the code that you have already been using.
Example
Select * from odb file s 
Inside join odb version l 
On s file = l file 
And l version = (select bottom (5) 
V4.version number 
From odb version 4 
Where v4.file number = l file 
Order by v4 file number inc 
V4. File inc 
); 
As you are going about your search, you have the option to use the max or even the row number so that you can use a different function and you do not have to rely on the joining function. Each function that we discuss is going to give you the data that you are searching for in one way or another.
Data and the data base 
When you are working with versioned data, you can create a data base that is just going to be for those files so that you can see the different versions that you have as well as note any of the primary keys that you need to know about before you work with the data.
Simple testing
A test can be run in order to make sure that your search is starting where you are wanting it to that way you do not have to bother with subqueries, joins, or anything else that can complicate your code.
Every search that you do is going to have an execution plan, as well as execution time. You may also want to run a freesystemcache or a dbcc freeproccahe code before each search so that you can ensure that your system is not cluttered. Clearing up your system is going to make sure you are getting the proper comparison.
Example:
Select bottom (5) 
From dob.version l 
Where l file number = 587 
Order by l file number inc, 
L version number inc ; 
Once you have fun the test, you are going to get a single scan with three different results. After you have gotten that you are going to run a max query with a sub select.
Example
Select l. * 
From obd. Version l 
Where l file number = 587 
And l.version number = (select max (v4. Version number) 
From odb [ version ] v4 
Where v4. File number = l. file number 
) ; 
Once again you are going to get three different results.
The last search that you are going to do is the row number version search so that you can see how many rows are in each number.
Select l. * 
From (select l. *, 
Row_number () under (order by l. version number inc) as 
Rownum 
From odb. [version] l 
Where l. file number = 487 
) as l 
Where l. rownum =6; 
With your results from this search, you are still going to get three results, however it is going to be more complex than the other results. What you will notice is that this search is going to be a little slower than the other searches because there are going to be more to the results that you get than the other ones.
The plans of execution that you followed when you were doing the top and max searches are going to be identical to what is known as the clustered index seek. But, in looking at the row number search, your plan will be completely different. Your costs for your row number are going to be buried inside of the clustered index seek so that your search is not adding extra scans or reads that you do not need to have.
Join
The join function being used on a version table is going to end up giving you a single result that comes from one row. The first thing you need to do is your yop function.
Example:
Select l [ file title] 
L [ file number] 
T [description for that version] 
T [ file number] 
From dob [file] l 
Join dob [version] t 
On l [file number] = t [file number] 
And t [file number] = t [file number] 
And t [ version number] = select top (4) 
V4. Version number 
From dob [version] v4 
Where v4. File number = t. file number 
Order by v4 file number, 
V4. Version number inc 
Where l [file number] = 9685; 
Your results are going to be returned in thirty seven milliseconds. Even though you only did one scan, you are going to get multiple results for every table that you scanned.
The next step is to run a max search.
Example
Select l [ file title] 
L [ file number] 
T [description for that version] 
T [ file number] 
From dob [file] l 
Join dob [version] t 
On l [file number] = t [file number] 
And t [version number] = (select max (v4. Version number) 
From dob [version] v4 
Where v4. File number = t file number 
Where l [file number] = 9685; 
It is going to take around thirty two milliseconds to get your results back and there will be five reads against each table you ran.
In doing the max search, you will realize that your optimizer is going to work the same way that it did in our example for the testing section. However, your optimizer for the top function is going to create a nested loop with the data instead of giving you each result separately.
The top function ends up running the scan twice giving you six different reads per table as well as joining all the rows that are occupying your table. So, what is going to need to happen is that the version number does not need to be referenced, the file number needs to be referenced instead. Therefore, you are going to need to change your code to reflect this change.
Example:
Where v4. File number = l file number 
Now whenever the search is run, there is only going to be a single scan with six different reads based on the table that you referenced in the search.
So, when you run the top function, you are going to telling the system that the join has to be forced rather than to create a loop with the records that are inside of that particular version. So, what is going to happen if you end up changing your search once more? Before you run your search this time, you are going to change it to where the apply statement is now going to be a part of the join statement.
Example
Select l [file name], 
L [ file name], 
T [ description for the version], 
T[ version number] 
From odb [ file] l 
Cross apply (select bottom (5) 
V4. Version number, 
V4 description of the version 
From dob [version] v4 
Where v4 file number = l. file number 
Order by v4 file number, 
V4 version number inc 
) t 
Where l [file number] = 9685; 
With the scan that you run now, you are going to get five different reads that are going to be for each table that you ran. The execution plan looks very similar to the plans that you have seen before.
But, what does the apply method actually do? This method is going to make it to where one row is going to be taken from the table and find the top matches for that row inside of the table so that the joins are not sorted again and multiple scans do not have to take place.
Row number
Now, how does the join affect the row number? 
Example: 
Select f. * 
From (select l [file name], 
L [ file number] 
T [ description of the version], 
T [ version number], 
Row_number () over (order by t. version number inc) as rownum 
From dob [ file] l 
On l [file number] = t [file number] 
Where l [file number] = 9685 
) as f 
Where f. rownum = 2; 
The results that you get are going to be five reads that are returned within forty eight milliseconds and the execution plan that was followed by the system is different than any other plan that you have seen before.
While the search is only going to run once on every table, the clustered index operation is going to be performed as well. Just like the others, the joins are going to go through an operation that creates nested loops. But, what happens next is that the top operator will get segmented through the operator based on the expression that is inside of the system and pulled from inside of the search most likely by the order by statement.
It is going to look complicated, but you do not have to worry about that because the system is going to take care of it all for you so that you are only getting one par per operation.
Full data set
Now is the point in time that you are going to want to join all the data together. ultimately you will want a list of all of the publications in the table that demonstrate what the max version is. You are going to determine what all the points are that match inside of all the tables are.
Example
L [file name], 
L [ file number], 
Up [ version number], 
T [ name of the author], 
Up [ date of publication], 
Up [ number of publication] 
From dob [ file] l 
Cross apply (select bottom (5) 
V4 version number 
V4 file number 
V4 description of the version 
From dob [version] v4 
Where v4 file number = l file number 
Order by v4 file number 
V4 version number inc 
) as l 
Join dob . [ published] up 
On up [ file number = l [file number] 
And up [version number] = (select bottom (5) 
Up5. Version number 
From dob publication up5 
Where up5 file number = l file number 
And up5 id for publication = up id for publisher 
Order by up5 file number 
Up4 version number inc 
) 
Join dob [publisher] n 
On up [ number for publisher] = n [ number for publisher] 
Where n [ file number] = 56897 
And n [publisher number] = 3687; 
Your search is going to be completed in fifty three milliseconds and you are going to get four different results for your table.
The execution plan is going to be complicated to read, however, twenty percent of the batch is going to go through the nested look join therefore your plan becomes clean and simple for you to read.
Here is where you will see the max version with the from clause.
Example
From dob [ file] l 
Join dob [version] s 
On l [file number = s [file number] 
And s [file number] = (select max (v4 version number) 
From dob [version] v4 
Where v4 file number = s file number 
) 
Join dob [ publication up 
On s [ file number] up [ file number] 
And up [ version number] = (select max (up4 version number) 
From dob publication up4 
Where up4. File number = l file number 
And up4 version number >= d [version number] 
And up4 publiser number = up publisher number 
Join dob [ publisher] e 
On up [publisher number = e [publisher number] 
Where l [ file number] = 68945 
And e [ publisher number] = 3567; 
After forty six milliseconds, the scan will break down the publication, version, publisher, and documents in the table and give you what the reads are.
Once again, your execution plan is going to look complicated and it is going to have nothing but the nested loop operators that work with the top function along with the clustered index seek function. While most of the time there is an easier way to come up with something simpler, you are not going to find anything simpler than this.
What you may find interesting is that your top and max functions are going to act as if your top function has been resupplied. The biggest difference that you will find is that the tables are accessed in a different order than they have been before even though your search is the exact same as it has been the entire time. Should your searches be run at the same time and the results put side by side, you will notice that there really are not any differences that can be found without going through the entire code line by line.
At the point in time that your search changes so that you can find the row number you are going to find a few differences.
Example
Select l [file name] 
L [ file number] 
S [ description of the version being used] 
Up [ version number] 
E [name of the author] 
Up [ date file was published] 
Up [ number of publication] 
From dob [ file] l 
Inner join (select row_number() over (division by v4 file number order by v4 version number inc) nr
V4 version number 
V4 file number 
V4 description 
From dob [version] v4 
) as l 
Left outer join (select row_number() under (division b up4 file number,
Number for author
Order by up4 version number inc) nr 
Up4 version number 
Up4 file number 
Up4 date of publication 
Up4 number of publication 
Up4 publication number 
From dob publication up4 
) up 

On up [ file number] = s [ file number] 
Join dob [ author] d 
On up [ author number] = s [ author number] 
Where s [ file number] = 85964 
And a [ author number] = 5698 
And s. nr = 5 
And up nr = 9; 
At forty four milliseconds you are going to get some scans that you have never had before. However, the search is going to give you the same data that you were seeing before but it is going to give it to you in fewer scans and reads. There are some ways that this search method is going to be more complex than others but it is going to read easier than the others.
Your execution plan is obviously going to be more complex because the number of performances will be increased. Rather than having five cluster index seeks, you are going to have four. You are going to have to do more work by moving the data into different rows, however there will be fewer nested loop joins.
However, what if our results are going to change? Doing the same exact search that you did before, you are going to get even more data returned from just one part. For this example, we will remove the author number from the where clause so that when the search is run, you are only going to get forty nine percent from top and fifty from max.
What is the difference though?
Well, the difference is that you are going to be using part of the aggregate operator so that your data sets are larger and will cost more. It does not matter how many times you execute this plan, you are going to get the same results and the same reads. When you add in the row number search, your results are going to get interesting. When you look at the execution plan, it is going to be ranked as one of the most costly plans that you can run.
This is because you are going to get up to forty eight reads for one scan on the table. That is a lot of reads! Therefore, that is a lot of data off of one scan. But, when you put them side by side, you are going to notice that the data is going to be identical to what you got before. Your execution plan did not change nor did the results that you were getting.
Any differences that are there, are going to be so small that you are not going to really notice them.







Chapter Two
Archiving Your Data onto the SQL Server
Sometimes data is just not needed anymore. When you do not need data anymore you are going to want to archive it onto a server so that you not only have access to it at a later date, but it is not in the way of you performing the tasks that need to be completed.
When there is data that you do not need any more cluttering up your data base, you will not be able to do any maintenance on the table due to the performance issue you will be facing. As a developer, you know that data cannot just be deleted because it is not being used anymore. That is why you are going to want to put the data on the server for later use just in case.
In trying to figure out which method that is going to be best for you, you need to look at your data base closely and address a few issues that may arise first.
-        Look at the legal requirements for the company you are working for. You may come to realize that there are no requirements for retaining data which means you could delete it, but this is not recommended. But, other companies require data to be kept for up to seven years. Once you understand the policy that your company has, you will be able to better make your plan for archiving the data.
-        Look at the data that is in the file. There may be some data that you may still need. Despite that, you need to take a look at the amount of data that you have stored so that you can understand just how much data you are archiving on a quarterly basis.
-        Make sure you are archiving the data properly. If you do not know how to archiving data properly and are afraid you may want to be sure and meet with your IT department so that you can figure out the correct steps to archive the data properly. It is also a good idea to keep up with any updates that may come out in the process that is being used to archive data.
-        Have a feasible reason behind why you are wanting to archive the data. Just because you can does not mean that you are going to be able to archive the data. Some of the better reasons behind archiving data that IT and your manager are going to appreciate are:
Better experience for the user Back ups that take up less space. Performing maintenance that is going to up the performance of the system. Faster times for restoring the data The data base is easier to manage. 
-        If you work with a lot of data, you are going to want to set it up to where a specific file is archived either daily, weekly, or monthly so that your system is running to its full potential.
At the point in time that you can fully understand how it is that data is going to be archived on your system, you are going to be able to make a better decision as to how you are going to want to archive that data.
The data has to be on the same data base that you use all the time then:
-        Modify the ending code so that you can see the data in the table without actually pulling up the table.
-        Insert and delete the data that you are archiving into different tables and make sure that you save the file in a way that is going to make sure that you know that is an archived table.
-        Merge the old data with new data if the users are still needing to see that data in order to make sure the system runs as it should.
-        Make new talbes on a separate disk so that you can improve the performance of the data base.
If you can move the data to a new data base because it is not needed on that data base then:
-        Make sure that your users can still access the data or request access to the data so that applications can be used as they are supposed to be.
-        Insert and delete the table into a different data base or server so that it is not taking up the room on your current data base.
If the data that you are trying to archive is not needed anymore:
-        If the data is going to be needed because of some reason that you cannot predict, then make back ups.
-        Be sure that the data can be restored from the back up and then delete the data off the server.
Automatic archiving options
-        If there are large amounts of data that have to be changed, then you will want to do maintenance on the server as part of the archiving process. This is going to make it to where your server runs faster.
-        Should you not be able to make it to where data is automatically archived, then you will want to build a process that is going to move the data from the system to the archiving system.
Once you have made sure that you are following all company policy and that you are archiving the data correctly so that it is not having to be deleted, now you are ready to archive the data.
Make sure that you test your process to make sure that there is enough time in between making sure that your other work is being completed that you are going to be able to archive your data properly. If your users are just going to delete the data because they do not find it useful, then you may find it easier for you to move the data to a different data base all together for a few months so that if it is needed you will have access to it. If after about three months the data is not needed, then you are going to be able to just delete the data and clear up the disk space for something else.







Chapter Three
Security on the SQL Server
Safety is important to everyone. The more secure your server is, the better your users are going to feel about going through your server and make sure that the data that is on your server is going to be protected from those who may want to hack into your company's server.
-        Get rid of the log in for guests. Doing this will make it to where people you do not want having access to your data base will be removed and if they want to have access, you will have to give it to them.
-        Common work groups are going to be the ones that are most likely going to have access to the data base. To give the whole group access you are going to need to create a profile for the entire group so that they are able to log into the data base and gain access to the data that they are needing to work with.
-        An anonymous long in is going to work best if you are working off of a stand alone server and therefore all other resources that come with the data base are found on this specific IIS machine. Making an anonymous logon will make it to where you can get onto the domain with the account but you will be required to provide some authentication to ensure that someone is not trying to hack the account and get into the data base that should not be there. Another great thing about the anonymous account is that with SQL it will satisfy the pipes authentication process.
-        IIS applications need to have security too. When using the IIS on SQL, it is best you use a standard security mode so that you have flexibility when sending your applications out to various work stations.
-        Some data needs to have who can view it. Restricting views will make it to where only certain people can modify the data let alone who can see it. You can restrict access down as far as you want. If you only want certain columns out of the table to be seen, then you can.
-        If the data that you are working on data that needs to be secured more than normal data, you may want to think about used stored procedures so that you can ensure only users who have the proper authentication can view and modify the data. Or, you can fix it to where no one can modify the data but the creator of the table.
-        Not all users are going to use the same tools and there are times that this is going to be a problem. To fix this issue, you can assign one or even two different tools to each user account. Having two tools will allow for the user to have a choice of which is easier for them to use, but ensure that they are getting the results that you want. Or, will make it to where you get more uniformed results.
Audits are necessary whether you are working alone or with others. The data that you want to be audited will be found by having triggers created that audit be created automatically each time that the table is modified. You are not going to have to have permission from the user to do this. This is going to be a permission that only the administrator has.







Chapter Four
Azure SQL Data Bases
The Azure data base is going to work off Windows and is going to probably be a little different than just working with the SQL server on a Linux system. One of the things that you need to make sure you remember when you are working with the Azure data base is that it is not just another version of SQL. While it does use SQL, it is going to be a completely different platform for SQL.
Here are a few strategies that you may want to keep in mind when it comes to using the Azure data base.
-        Make sure that you have a disaster recovery plan. The Windows Azure SQL Data base (WASD) does not have any way to back up the data that you are working with. So, before you start working with WASD, make sure that you have a way to back up and recover anything that you may end up losing due to system crashes or freezes. It is best that you have this plan in place before you even begin to use WASD.
-        Have the proper resources that you are going to need while working with WASD. You are going to learn effective ways to use WASD as you go through using it if you have never used it before. However, you should do the research that is necessary to make sure that your resources that you are currently using are going to be right for what you are trying to use WASD for. Just because you are using WASD does not mean that you have to get someone completely new to work with the system. The skills that someone else has may work with WASD, you are just going to need to make sure that their skills with SQL are going to cross over to WASD.
-        Test the tools that you are using. The tools you are using on other programs may very well work with the WASD. If you do not have to spend the money, then, why do it? Before jumping onto server take the time to discover what it is that you are going to need to work with the data base. This could even include hiring someone to teach you how to use the tool or to use the tool for you. Also, you need to make sure that the tool works before you go on and spend more money that you may not need to spend. If it does not work after a trial period, then is the time that you are going to want to switch tools or people using the tools if it is in your budget to do so.
-        Break the changes. Since WASD is a different platform than what you are probably used to working with, you are going to need to look at it as the fact that it is going to behave differently than the version that you are going to be. If you expect it to react the same way as a regular SQL platform, then you are going to be disappointed. There is a list of features that WASD supports and you should not assume that what you have been doing this entire time is going to continue to work for you. Once again, you will need to ensure that you do the research that is required to make sure that you understand WASD so that when you go to use it, you are not moving backwards.
-        Do not let mistakes that you make on the platform to stop you. You are going to make mistakes, this cannot be avoided. However, you need to make sure that you learn from these mistakes so that you do not keep making these mistakes and thus setting yourself back on learning about the platform and the way that you use it.
You are going to learn a lot from troubleshooting. If you already have trouble shooting skills, then you are going to be able to put these skills to use when you are working with WASD.







Chapter Five
Compressing Data Inside of SQL
There are functions that are built into SQL that are there in order to assist you in decompressing or compressing the data that is on the server.
-        Compression is when the data is made smaller thus returning a binary string of data.
-        Decompression will take the binary data that you got from the compression and put the data back into its original text.
It does not matter which function you are working with you are going to be using an algorithm that works with the standard GZip in order to allow you to compress the data and then send that data to the SQL server.  If you are wanting to decompress the data, you are going to do it on the client side.
Example of compressed data
Create table books ( 
_title nit main key identity, 
Title nvarchar (full) 
Subtitle nvarchar (full) 
Info varbinary (full) 
) 
From there you are going to be able to load the compressed information into your column.
Insert  into book ( author, subtitle, info) 
Select booktitle subtitle, compress (any other info)  from. Book. Book
Or if you are wanting to, you can send that data right back to the client who can then decompress it should they want it decompressed.
Select title, sub title, decompress (info) as primary 
From books 
Lastly, you can put a computed column in that is going to decompress the data for you.
Alter table books 
Add info_characters as cast ( decompress (info) as nvarchar (full)) 
What if you want to know what the compression rate is?  You can figure that out by creating text and then compressing it in order to see the ratio.
Declare @ characters nvarhar (full) = (select bottom five * from sys. any_item for json path) 
Select length of data (@ characters) as primary length of data (compress (@ characters)) as compressed, 5.9 * length of data (@ characters) / length of data (compress (@ characters)) as ratio. 
The number of rows that are formatted can be changed so that it works with the text that you are currently working with. Either of these functions are going to assist you in choosing what kind of data has to be compressed in the table.
Using compression may even aid you should you find that you are working with text data but it has already been compressed however has not been compressed to a good ratio. If that is the case, you are going to want to spend CPU cycles to fix this issue.







Chapter Six
Population Stability Index (PSI) Inside of the SQL Data Base
SQL is one of the best programs out there that you can work with when you are trying to work with probability. As you are trying to build up a data warehouse, there are going to be cubes that you are going to use that is going to aid you when it comes to comparing values that are in a report versus the value that you are going to get form systems such as SAP or any other transactional system that you may be working with.
There may be times that you find that you are going to be working with reports that are going to compare data that is going to change throughout the use of that table. Even if it does not change, you are going to have to work with figures such as financial figures or population figures. Anything that may change.
For this example, you are going to look at the number of people who have paid their car payment that month and how it is going to affect their credit. What you are going to be doing is working with the Population Stability Index otherwise known as PSI.
Your syntax is going to look a little something like this:
PSI = ∑ (a-b) * log [ A/ B] 
The formula is just the fancy and more complicated way to tell you what it is that the system is going to be working with. However, when you break it down to where you can understand exactly what the system is doing, you are going to need to change the sigma sign to sum() and therefore you are going to understand the formula!
Now, the formula actually looks like this.
PSI = sum() (a-b) * log [a/b] 
That is a lot easier to understand isn't it? And now you are going to be able to do the equation if you so desire to.
Example
Declare @ car table ( number nit identity (2, 6), present month nit, prior month nit, population number float population prior float) 
Insert into @car table amount ( 325164, 1236589, 987, 456) 
Test  data 
Select * from @ car table 
Calculating PSI
Select sum( population number, population prior) * log (population / population prior) as PSI from @ car table 
Group by population, population prior
Now that you can see the equation and how it is going to work into SQL code, it seems a lot less intimidating and you are not going to have to worry about not putting the formula in correctly.
Your PSI is going to show the shift from one month to the next if there is any shift. You are going to be able to create alerts that are going to be based off any values that are going to be returned to you.







Chapter Seven
Hyper Threading- How it Works and When You Should Use it
What is hyper threading and how does it work with SQL?  The first t hing that you should have some knowledge on is the structure of a CPU. The CPU if you do not know is what makes the computer run for example an intel core i5.
The most common thing that people assume is that it has to be bigger to be better. But, when working with SQL, the software will make a huge difference and can end up saving you and your company a lot of money, but only if you can configure your software properly.
The first thing you are going to want to do is download the CPU-Z so that you can get the proper information on your processor that you are working with. You can go to www.cpuid.com/softwares/cpu-z.html in order to get the software. The link that you are wanting to go to will be located on the right hand side of the page.
In the event that you are running off of two cores, thanks to hyperthreading, you are going to be able to gain  threads to work off of. This will be consideredworking with logical CPUs. But, if hyperthreading has been disable on your system, you are going to only be using two threads.
With hyperthreading enabled, you are allowing it to increase your threads before assigning some cache to L3 where the threads are located. Therefore, if you are working off of 4mb of cache then it is going to send out one mb to each thread. But, working with hyperthreading off, you will have 2 mb per thread.
Hyperthreading should be enabled so that you have more for your data to go through. Larger threads of data can be proccessed with less of a problem than if you were working with hyperthreading off.
However, hyperthreading is a personal choice based on what it is that you are doing with SQL. For some projects you are going to want to have your hyperthreading turned off because it is just going to get in the way of what you are doing. But, for other projects, you will want it on because it is going to make dealing with the data that much easier.







Chapter Eight
T-SQL Analytic Functions
There are some SQL problems that you are going to discover that will end up being too complicated to know how to write the code for. There are ways around this though, you just have ot know what it is that you are doing before you can do it. For any one problem, there may be up to around eleven different ways that you are going to be able to solve that problem with SQL.
Example
Set A 
A004  b004  c004  5 
A005 b005  c005  10 
A006 b006 c006  15 
Set b 
A007  c007  d007  20 
A007 c007 d008 20 
A009 c009 d009 30 
The outcome that you are wanting to have is that each set be divided by adding the similar ones together and then multiplying them by your other ones. There are going to be some that are going to come out as null. This is going to see somewhat complicated, so let's look at an example.
Example
Declare @set a table (a varcar(5), b 
Varchar (5) c varchar (5) value nit) 
Insert into @set a amount (a004, b004 c004, 5) 
Insert into @set a amount (a005 b005 c005 10) 
Inset into @seta amount (a006 b006 c006 15) 
Declare @set b table (a varchar 20 c varchar20, d varchar20 amount nit) 
Insert @set b amount (a007 c007 d007 20) 
Insert @ set b amount (a007 c007 d008 20) 
Insert @ set b amount ( a009 c009 d009 30) 
Select * from set a 
Select * from set b 
From here you are going to check the results and use an inner join as well as a left join so that you can locate which one of them is going to be clsoely matched and give you the results that you are wanting. When you test it more, you are going to discover that there are other ways that you can find a solution to this problem.
Select * from @set a inner join @ set b on a =b = c 
Select * from @ set a left join @ set b on a =b =c  = c 
Those are just two ways to find a solution to the same problem. As stated before, you may discover that there are eleven diiferent ways to solve the same exact problem and get the solutions that you are wanting. However, you do not have to go through every possible way to find them all. You can just stop at the one that gives you the results that you are looking for.







Chapter Nine
Do Not Copy, Clone It!
There may be times where you find that you are going to need to have a copy of your table but using the create table and entering all the data into the table is not going to be the best option for you because you need everything to be identical.
When you use MySQL, you will have the best solution
Use the create table command that makes the table exactly like the table you are wanting to copy. Change the code so that the table title to the table that your cloning so that you know that the table will be the same across the entire board. Should you need the entire table be copied, you will use the insert into and select statement. 
Example
Still going with the family table that we have been using for our examples.
Step 1: you need to get the entire structure of the table. This means that you need to get the code for the table so that it can be cloned.
Step 2: the table will need to be retitled and another table created.
Step 3: once step 2 has been completed, you can now clone the table inside of the data base. You can copy the data out of the old table and use the insert into and select statements to get the data into your new table
And congratulations! You have now cloned your table!







Chapter Ten
Sequencing with SQL
Sequences are pretty easy to understand. Most likely, you use them everyday and do not even realize it. A sequence is going to be something that comes in an order whenever it is called upon. But, a sequence is going to be used inside of a data base because there applications that are going to be required that every row of data that is inside of the table is going to have a unique value and the sequence is an easy way for you to generate these values.
Auto_increment 
One of the easiest ways to use sequences in MySQL is to define your columns with the auto_increment command while allowing MySQL to take care of everything else that needs to be taken care of.
Obtain auto_increment values
There is a function that is going to be used in SQL so that you are able to make sure that any client that you are going to be working with is going to be able to understand how they need to set out the SQL statements. The function that you are going to use is last_insert_id ( ). PHP and Perl codes are going to be able to give you exclusive functions that you can use in order to get the auto-incremented value that was last recorded by the system.
Perl example:
You will mysql_insertid function when you are trying to get the value that has been auto-incremented and generated by the query that you initiated. This attribute is going to go through the data base or statement based on how you set up your query
PHP example
Once you have issued a query with PHP, then you are going to automatically get the auto_increment value and it will gather up this value using the same function that was used in the Perl example.
Remember a sequence that already exists
There could be some cases that you are going to have to delete a number of different records from the table that you are working with so that you have the ability to put the records in a different sequence. You are going to do this with a single trick, however, you need to be careful whenever you are using this trick or else you are going to end up with your table joining another table without it being what you really want to happen. If this happens, you are going to end up having to go back and unlink the two tables before you are able to continue.
When you are trying to resequence an auto_increment, it is going to be unavoidable to drop the column and then add it into the table once more.
Example
Alter table inspect drop age; 
Alter table insect 
Add age int unsigned not null auto_increment second 
Add primary numbers (age) ; 
Sequences starting with certain values
MySQL is going to default a sequence so that it starts with the number one. However, if you need to or want to, you can correct your code so that it will start with another number whenever your table is created.
Example
Create table insect 
( 
Age int unsigned not null auto_increment = 50; 
Primary number (age), 
Title varchar(20) not null 
Date date not null, 
Origin varchar(20) not null 
If you so choose, you can also create a table and set the sequence value by using the alter table function.







Chapter Eleven
Your Data Base- How to Tune it
Becoming an expert on data bases or even a data base expert is not going to happen overnight. In fact, it is going to take a lot of time and experience dealing with a variety of data bases doing a little bit of everything so that you have a well rounded education when it comes to the data base.
When dealing with a data base, there are a few things that you may find helpful so that you can become better with the data base.
The design that you should be using is 3BNF for when you are working with a data base. Try and avoid the number to character changes since numbers are going to be compared to character differently and you may end up noticing a downgrade in the performance of your data base. In using the select statement, you are only going to want to have the data that is absolutely neccesary to be displayed returned and try to avoid using an asterisks in these searches so that your system is not loaded when it does not need to be. All the indexes that you make need to be made very carefully for the tables that you will most. When you are not going to use the table much, try not to create an index because the more indexes that you have, the less space on the disk you are going to have and the more update operations you are going to have to deal with. Full table scans are going to occur whenever there are columns inside of a where caluse but there is no index that is listed with that table. A full table scan can be avoided by simply constructan index on the columns that are going to work with that clause. Equality operators need to be used with caution whenever real numbers, times, and dates are being used. There is a chance that there are going to be some differences that you may not notice right away, but it is going to make getting an exact match almost impossible therfore your searches are not going to return any rows. Pattern matching should be used judiciously. A valid where condition would be ilke col%, but to reduce the return of these records with this particular string is not going to reduce the rturn of your results being that you are not going to get them to be evaluated effectively. Trying to do an evaluation is going to be too much of a hassle and you should use a different operation so that you can get your results. Turn you searches by looking at the structure of your search for the code that you are using. You may come to realize that you are going to be able to design your tables so that they can handle a faster manipulation of the data that is inside of them and write the search to work with the table appropriately. When you are doing searches regularly, you need to try and stick to the proceedures that are going to work with large groups of SQL statements. These procedures are going to be put together by the data base before they are executed. SQL statements are not like the engine inside of the data base because the data base is not going to need to optimize the procedure that it is about to carry out. Try to not use the or operator when you are working with your searches if you can. This operator is going to slow do your query when you are using it on any table, no matter how big the table is. Bulk data can be optimized by getting rid of the indexes. Try and think of your history of your table containing over a thousand different rows and this table is most likely going to have an index but possibly more than one. Indexes are going to give you faster access to the data that is inside of the table, but when a batch is loaded, you are going to be better off not having these indexes because it is going to slow down the system that you are working with. Batch transactions need to be performed with the commit function and it needs to be executed after each record is created. The data base will need to be defragmented on a regular bases, and maitenance needs to be performed on a weekly basis. 
Tuning tools that are built in
Oracle contains several different tools that you are going to be able to use when you are dealing with a SQL statement and how it performance. Two of the more popular tools are:
Tkprof: this tool is going to measure the performance that is done over a period of time during every statement that is processed by SQL. Explain plain: this tool will show you the path you need to follow so that the statement is executed properly. 
Should you want to measure the time that passes from each search that is done in Oracle, the SQL*plus command can keep track for you.







Chapter Twelve
Duplications Happen but, How to Fix Them
Situations may be found that there are going to be duplicate records that are inside of your table. While looking at these records, it is only going to make sense to find records that are unique rather than to gather the duplicate records.
The keyword you are going to use is distinct while working with a select statement so that you can get rid of any duplicate records and only find the records that have unique data.
Code
SELECT DISTINCT column 1, column 2 , ..... columnN
FROM table_title
WHERE [condition]
Example
If you are looking at the age of your customers, then you are bound to have several customers that are going to be the same age.
First, you will select query so that you are able to see all of the duplicate records that are in your table.
If you wanted to see the ages of your customers in ascending order, you may come to find that you have three customers that are all 19 years of age.
By using the distinct keyword along with the select query, you are going to get rid of all the duplicate files and only see the single file.
Therefore, instead of seeing that there are three customers that are 19, you are only going to see that one is 19.







Chapter Thirteen
Constraints are Everywhere!
When you want to be able to limit what data can be entered into a table, you can make much use out of constraints. You can set up a constraint whenever a table is created. This can also be done by using the CREATE TABLE or ALTER TABLE commands. Listed below are some of the common constraints that can be used.
CHECK- This specifies a constraint that will limit the value range that can be placed in a column.
DEFAULT- This specifies a constraint that is used in order to insert a default value into a column.
FOREIGN KEY- This specifies a constraint that prevents invalid data from being inserted into the foreign key column because it has to be one of the values contained in the table that it points to.
NOT NULL- This specifies a constraint that enforces a column to not accept values that are null.
PRIMARY KEY- This specifies a constraint that uniquely identifies each record in a database table. It is important to note that each table should have a primary key and each table can only have one primary key.
UNIQUE- This specifies a constraint that uniquely identifies each record in a database table. It is important to note that a table can have many UNIQUE constraints, but only one PRIMARY KEY constraint.
CHECK
How to use the CHECK constraint on CREATE TABLE:
My SQL:
CREATE TABLE Clients
( C_Id int NOT NULL,
Last varchar (255) NOT NULL,
First varchar (255),
Address varchar (255),
City varchar (255),
CHECK (C_Id 0));
SQL Server/Oracle/Access:
CREATE TABLE Clients
(C_Id int NOT NULL
CHECK (C_Id 0),
Last varchar (255) NOT NULL,
First varchar (255),
Address varchar (255),
City varchar (255));
You can name and define a CHECK constraint on multiple columns:
MySQL/ SQL Server/ Oracle/ Access:
CREATE TABLE Clients
(C_Id int NOT NULL,
Last varchar (255) NOT NULL,
First varchar (255),
Address varchar (255),
City varchar (255),
CONSTRAINT chk_Client
CHECK (C_Id 0 AND City= 'LosAngeles'));
How to use the CHECK constraint on ALTER TABLE statement:
MySQL/ SQL Server/ Oracle/ Access:
ALTER TABLE Clients
ADD CHECK (C_Id 0)
MySQL/ SQL Server/ Oracle/ Access:
ALTER TABLE Clients
ADD CHECK (C_Id 0)
ALTER TABLE Clients
ADD CONSTRAINT chk_Clients
CHECK (C_Id 0 AND City= 'LasVegas') 
How to DROP a CHECK constraint:
SQL Server/ Oracle/ Access:
ALTER TABLE Clients
DROP CONSTRAINT chk_Clients
DEFAULT 
How to use the DEFAULT constraint with CREATE TABLE statement:
CREATE TABLE Clients
(Id int NOT NULL,
Last varchar (255) NOT NULL,
First varchar (255),
Address varchar (255),
City varchar (255)
DEFAULT 'LasVegas');
This will put a constraint on the "City" column when the "Clients" table is created. The DEFAULT constraint can even be used in order to insert system values by using functions such as GETDATE():
CREATE TABLE Orders
( ID int NOT NULL,
OrderNo int NOT NULL,
C_Id int,
OrderDate date
DEFAULT GETDATE());
How to use the DEFAULT constraint with ALTER TABLE statement:
MySQL:
ALTER TABLE Clients
ALTER City
SET DEFAULT 'LasVegas'
SQL Server/ Oracle/ Access:
ALTER TABLE Clients
ALTER COLUMN City
SET DEFAULT 'LasVegas'
How to DROP a DEFAULT constraint:
MySQL:
ALTER TABLE Clients
ALTER City DROP DEFAULT
SQL Server/ Oracle/ Access:
ALTER TABLE Clients
ALTER COLUMN City DROP DEFAULT







Conclusion
Thank for making it through to the end of SQL Strategies, let's hope it was informative and able to provide you with all of the tools you need to achieve your goals whatever it may be.
The next step is to take the strategies that you learned and put them to good use. Some of these strategies may not work for everyone, but they are going to work for some and what does work for you will help to make it to where using SQL is more efficient for you.
Do not think that you cannot keep learning though! There is always more to learn! Keep up with what is new with SQL and do your research. There is always more out there for you to learn and figure out to make SQL that much better for you to use.
Finally, if you found this book useful in anyway, a review on Amazon is always appreciated! 
Do not forget to check out the SQL Beginner's Guide and the SQL Tips and Tricks book on Amazon! They will assist you in making sure that you are getting the most out of using SQL.



