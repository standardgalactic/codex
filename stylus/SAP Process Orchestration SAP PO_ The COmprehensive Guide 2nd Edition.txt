




John Mutumba Bilay, Roberto Viana Blanco
SAP® Process Orchestration
The Comprehensive Guide
2nd, updated and revised edition 2017










Imprint

            This e-book is a publication many contributed to, specifically:
         
Editor   Meagan WhiteAcquisitions Editor   Hareem ShafiCopyeditor   Julie McNameeLayout Design   Vera BraunerCover Design   Graham GearyPhoto Credit   Shutterstock.com/315346214/© AGCuestaProduction E-Book   Marissa FritzTypesetting E-Book   Satz-Pro, Krefeld (Germany)
We hope that you liked this e-book. Please share your feedback with us and read the
            Service Pages to find out how to contact us.
         
Library of Congress Cataloging in Publication Control Number: 2017036302
ISBN 978-1-4932-1559-1 (print)ISBN 978-1-4932-1560-7 (e-book)ISBN 978-1-4932-1561-4 (print and e-book)
© 2017 by Rheinwerk Publishing Inc., Boston (MA)2nd, updated and revised edition 2017
         

















Dear Reader,
As the years go by, you've likely found that your system landscape has become more
         and more complex. As the complexity increases, so do the challenges you and your organization
         face, from needing to ensure smooth integration between the various systems and components
         to managing business processes in an efficient manner. This is where this comprehensive
         guide to SAP Process Orchestration comes in!
Whether you're starting fresh or migrating from SAP PI, SAP PO gurus John Bilay and
         Roberto Viana Blanco have got you covered. Not only do they provide you with in-depth
         information on SAP PI, SAP BPM, and SAP BRM (and more!), but they have also created
         detailed, step-by-step exercises to help you apply your new knowledge. It has
         een my pleasure to work with them both, and I think we (mostly them) have produced
         a wonderful book.
What did you think about SAP Process Orchestration: The Comprehensive Guide? Your
         comments and suggestions are the most useful tools to help us make our books the best
         they can be. Please feel free to contact me and share any praise or criticism you
         may have.
Thank you for purchasing a book from SAP PRESS!
          
         
         Meagan WhiteEditor, SAP PRESS
         
Rheinwerk PublishingBoston, MA
         
meaganw@rheinwerk-publishing.comwww.sap-press.com









Notes on Usage
This e-book is protected by copyright. By purchasing this e-book, you have agreed to accept and adhere to the copyrights.
            You are entitled to use this e-book for personal purposes. You may print and copy
            it, too, but also only for personal use. Sharing an electronic or printed copy with
            others, however, is not permitted, neither as a whole nor in parts. Of course, making
            them available on the Internet or in a company network is illegal as well.
         
For detailed and legally binding usage conditions, please refer to the section Legal Notes.
         
This e-book copy contains a digital watermark, a signature that indicates which person may use this copy:
         

 
Notes on the Screen Presentation
You are reading this e-book in a file format (EPUB or Mobi) that makes the book content
            adaptable to the display options of your reading device and to your personal needs.
            That's a great thing; but unfortunately not every device displays the content in the
            same way and the rendering of features such as pictures and tables or hyphenation
            can lead to difficulties. This e-book was optimized for the presentation on as many
            common reading devices as possible.
         
If you want to zoom in on a figure (especially in iBooks on the iPad), tap the respective
            figure once. By tapping once again, you return to the previous screen. You can find
            more recommendations on the customization of the screen layout on the Service Pages.
         









Table of Contents

Dear Reader
Notes on Usage
Table of Contents
Foreword
Acknowledgments
Introduction
Part I   Getting Started
1   Introduction to SAP Process Orchestration
1.1   Historical Overview and Evolution
1.1.1   SAP Process Integration
1.1.2   SAP Composition Environment
1.1.3   SAP Process Orchestration
1.1.4   SAP Process Orchestration 7.5 Highlights
1.2   SAP Process Orchestration Components
1.2.1   SAP Process Integration
1.2.2   Business Process Management
1.2.3   Business Rules Management
1.3   Architectural Overview and Positioning
1.3.1   SAP Process Orchestration Positioning
1.3.2   SAP NetWeaver Application Server for Java: System Architecture
1.3.3   SAP NetWeaver AS Java System Logical Layers
1.4   Installation Options
1.4.1   Case 1: SAP Process Integration Dual Stack
1.4.2   Case 2: SAP PI Dual Stack and SAP Composition Environment in Separate Installations
1.4.3   Case 3: SAP PI Single Stack and SAP Composition Environment in Separate Installations
1.4.4   Case 4: SAP PO—SAP PI and SAP Composition Environment in a Single Installation
1.5   Summary
2   Administration and Development Tools
2.1   SAP Process Orchestration Tools
2.1.1   Enterprise Services Repository
2.1.2   Integration Directory
2.1.3   System Landscape Directory
2.1.4   Configuration and Monitoring
2.2   SAP NetWeaver Administrator
2.2.1   Availability and Performance
2.2.2   Operations
2.2.3   Configuration
2.2.4   Troubleshooting
2.2.5   SOA
2.3   SAP NetWeaver Developer Studio
2.3.1   Use and Download
2.3.2   SAP Process Orchestration and SAP NetWeaver Developer Studio
2.4   Summary
Part II   Advanced Adapter Engine Extended (AEX)
3   Configuring the System Landscape Directory
3.1   System Landscape Directory Components and Features
3.1.1   Landscape
3.1.2   Software Catalog
3.1.3   Development
3.2   Registering Systems to the System Landscape Directory
3.2.1   Connecting to ABAP-Based Systems
3.2.2   Connecting to Java-Based Systems
3.2.3   Connecting to Other Systems
3.3   Administration of the System Landscape Directory
3.3.1   Server
3.3.2   Data and Content
3.4   System Landscape Directory Strategies
3.4.1   Manual Export and Import of Data
3.4.2   Automatic Bridge Forwarding
3.4.3   Full Automatic Synchronization
3.5   Tips and Tricks
3.5.1   Naming Convention
3.5.2   Keeping Your System Landscape Directory Catalogs Up to Date
3.5.3   Self-Registration of a Java-Based System with the SLD
3.5.4   Configuring Data Suppliers from One SLD to Another
3.5.5   Manual Export and Import of Data
3.5.6   Connecting the SLD to CTS+ to Facilitate the Export and Import of SLD Data
3.6   Exercise: Configuring the System Landscape Directory
3.6.1   Exercise Description
3.6.2   Exercise Solution Approach
3.6.3   Exercise Step-by-Step Solution
3.7   Summary
4   Working with the Enterprise Services Repository and Registry
4.1   Basic ES Repository Technical Concepts
4.1.1   Functional Blocks
4.1.2   First Steps in the Enterprise Services Repository
4.1.3   Service Interface
4.1.4   Integration Patterns: Stateful and Stateless Communication
4.1.5   Asynchronous versus Synchronous
4.1.6   Quality of Service
4.2   Design Objects
4.2.1   Software Component Versions
4.2.2   Folders
4.2.3   Namespaces
4.2.4   Mappings
4.2.5   Process Integration Scenario
4.2.6   Actions
4.3   Data Types and Message Types
4.3.1   Data Types
4.3.2   External Definitions
4.3.3   Message Type
4.3.4   Additional Design Objects
4.4   Exercise: Working with the ES Repository and Registry
4.4.1   Exercise Description
4.4.2   Exercise Solution Approach
4.4.3   Exercise Step-by-Step Solution
4.5   Summary
5   Working with the Integration Directory
5.1   Integration Directory Overview
5.2   Collaboration Profiles
5.2.1   Party
5.2.2   Communication Component
5.2.3   Communication Channel
5.2.4   Communication Component without a Party
5.3   Adapter Types
5.3.1   Technical Adapters to Enable Communication with SAP or Third-Party Systems
5.3.2   Application Adapters to Enable Communication with an SAP System
5.3.3   SAP Industry Adapters
5.3.4   Third-Party-Developed Adapters
5.4   Integrated Configuration
5.4.1   Inbound Processing
5.4.2   Receiver
5.4.3   Receiver Interfaces
5.4.4   Outbound Processing
5.5   The XI Message Protocol
5.6   Configuration Scenario
5.6.1   Creating a Configuration Scenario from Scratch (Manually)
5.6.2   Creating a Configuration Scenario from a Model
5.7   Value Mapping
5.7.1   If/Else Logic
5.7.2   Fixed Values
5.7.3   Value Mapping
5.8   Business-to-Business Integration
5.8.1   Business-to-Business On Premise
5.8.2   Business-to-Business Managed Services
5.8.3   Trading Partner Management
5.9   Axis Framework
5.10   Representational State Transfer Adapter
5.11   Message Alerting
5.11.1   Alert Rule Overview
5.11.2   Creating an Alert Rule
5.11.3   Editing or Deleting a Rule
5.12   Publish the Service in the Services Registry
5.13   Integration Directory Programming Interface (Directory API)
5.14   Exercise: Working with the Integration Directory
5.14.1   Exercise Description
5.14.2   Exercise Solution Approach
5.14.3   Exercise Step-by-Step Solution
5.15   Summary
6   Building an Integration Flow
6.1   SAP NetWeaver Developer Studio
6.1.1   Installing SAP NetWeaver Developer Studio
6.1.2   Setting Up SAP NetWeaver Developer Studio
6.1.3   Enterprise Integration Patterns and User-Defined Templates
6.2   Basics of Creating and Configuring an Integration Flow
6.2.1   Creating an iFlow
6.2.2   Configuring an iFlow
6.3   iFlow Example
6.3.1   Creating Products, Software Components, Business Systems, and Technical Systems
               in the SLD
6.3.2   Importing SLD Objects into the ES Repository in SAP NetWeaver Developer Studio
6.3.3   Create Enterprise Service Repository Objects
6.3.4   Create Directory Objects: Import Business Systems and Create iFlows
6.3.5   Testing the iFlow Scenario
6.3.6   Monitoring the Scenario
6.4   New Features of the Process Integration Designer
6.4.1   Export Objects from the Integration Designer
6.4.2   Automatically Deploy after Import
6.4.3   Version History and Deployment Status
6.5   Supporting Multiple Senders for Your iFlow
6.6   Exercise: Building an Integration Flow
6.6.1   Exercise Description
6.6.2   Exercise Solution Approach
6.6.3   Exercise Step-by-Step Solution
6.7   Summary
7   Administration and Monitoring in AEX
7.1   Administration
7.1.1   Central Administration Tool
7.1.2   SAP NetWeaver Administrator
7.1.3   SAP NetWeaver Application Server Java
7.1.4   SAP Process Integration Monitoring (pimon)
7.1.5   SAP Management Console
7.1.6   Config Tool
7.1.7   Administration Using Telnet
7.2   Monitoring
7.2.1   SAP NetWeaver Administrator
7.2.2   SAP Process Integration Local Monitoring
7.2.3   SAP PI Central Monitoring with SAP Solution Manager
7.2.4   Message Retention
7.2.5   User-Defined Message Search
7.3   Troubleshooting
7.3.1   Configuring Log and Traces
7.3.2   Using the Log Viewer
7.4   Summary
8   Migrating Interfaces from SAP PI Dual Stack to SAP PO
8.1   Migration Strategies
8.2   Migrating System Landscape Directory Content
8.2.1   Products
8.2.2   Software Components
8.2.3   Technical System
8.2.4   Business System
8.3   Migrating Enterprise Services Repository Content
8.3.1   Exporting Objects
8.3.2   Importing Objects
8.4   Migrating Integration Directory Content
8.4.1   Manually
8.4.2   Using the Migration Tool
8.5   Summary
Part III   Business Process Management and Composition
9   Introduction to SAP BPM and BPMN 2.0
9.1   Managing Business Processes
9.2   SAP Business Process Management
9.2.1   SAP BPM versus SAP Business Workflow
9.2.2   BPM before SAP BPM
9.2.3   SAP BPM Main Components
9.3   Business Process Model and Notation 2.0
9.3.1   Swimlanes
9.3.2   Artifacts
9.3.3   Flow Objects
9.3.4   Connections
9.4   Summary
10   Creating Your First SAP BPM Process
10.1   SAP BPM Positioning and Development Environment
10.1.1   Positioning
10.1.2   Setting Up Your Development Environment
10.2   Creating and Modeling an SAP BPM Process
10.2.1   Demonstration Scenario
10.2.2   Building an SAP BPM Process: Overview
10.2.3   SAP NetWeaver Developer Studio Perspective Concept
10.2.4   Create a Project in SAP NetWeaver Developer Studio
10.2.5   Creating a Process for Your BPMN
10.2.6   Creating a BPMN Model
10.3   Configuring the BPMN Model
10.3.1   Data Objects
10.3.2   Creating Data Structures
10.3.3   Importing XSD and WSDL
10.3.4   Process Pool Properties
10.3.5   BPMN Flow Objects
10.4   Flow Objects
10.4.1   Events
10.4.2   Tasks
10.4.3   Activities
10.4.4   Gateways
10.4.5   Artifacts
10.5   Build and Deploy Your Process
10.5.1   Steps for Building a Process
10.5.2   Steps for Deploying a Process
10.6   Advanced Mapping
10.6.1   Mappings
10.6.2   Options in Mapping Assignment
10.6.3   Automatic Mapping
10.6.4   Custom Functions
10.7   Implementing Error Handling
10.8   Combining SAP BPM and the AEX
10.8.1   Message from SAP BPM to the AEX
10.8.2   Message from the AEX to SAP BPM
10.8.3   Leverage an ES Repository Mapping in SAP BPM
10.9   Exercise: Creating an SAP Business Process Management Process
10.9.1   Exercise Description
10.9.2   Exercise Solution Approach
10.9.3   Exercise Step-by-Step Solution
10.10   Summary
11   Applying Advanced SAP BPM Concepts and Extensions
11.1   Service-Oriented Architecture Configuration
11.1.1   Configuration for an Automated Activity
11.1.2   Configuration for a Start Event or Intermediary Event
11.2   Testing and Running an SAP BPM Process
11.2.1   Process Repository Overview
11.2.2   Process Testing
11.3   Custom Enterprise Java Bean Functions
11.3.1   Create EJB and EAR Development Components
11.3.2   Create the Enterprise Java Bean
11.3.3   Build and Deploy
11.3.4   Create a New Enterprise Java Bean Function
11.4   Using the Claim Check Pattern
11.4.1   Create Interfaces
11.4.2   Create Mappings
11.4.3   Configure the Channel
11.4.4   Retrieve the Large Message from SAP BPM
11.4.5   Update the Status of the Large Message from SAP BPM
11.5   SAP BPM Application Programming Interface
11.5.1   Prerequisite to Using the SAP BPM API
11.5.2   Implementation Aspects and Examples
11.6   SAP Business Process Management OData
11.6.1   OData Services for Tasks and Task Data
11.6.2   Error Handling
11.7   Using the Push API to Access SAP BPM Lifecycle Events
11.7.1   Accessing Events through a Message Driven Bean
11.7.2   Accessing Events through a Java Message Service API
11.8   Debugging and Troubleshooting SAP BPM Processes
11.8.1   Place Breakpoints in the Process
11.8.2   Add a Debug Configuration
11.9   Tuning SAP BPM-Related Performance Parameters
11.10   Best Practices for Your SAP BPM Application
11.10.1   BPMN, Mapping, and Parallelism
11.10.2   Task Related
11.10.3   Gateways
11.10.4   Looping
11.10.5   Data Object
11.10.6   Correlation
11.10.7   Error Handling
11.10.8   Housekeeping
11.11   Exercise: Applying Advanced SAP BPM Concepts and Extensions
11.11.1   Exercise Solution Approach
11.11.2   Exercise Step-by-Step Solution
11.12   Summary
12   Combining SAP BPM and UI Technologies
12.1   Web Dynpro Java User Interface Technology
12.1.1   Generating a Web Dynpro User Interface
12.1.2   Post-Configuration Steps
12.2   Integrating SAPUI5 into an SAP BPM Process
12.2.1   SAPUI5 Technology Platform
12.2.2   Model-View-Controller Concept
12.2.3   SAPUI5 Components
12.2.4   Other SAPUI5 Concepts
12.2.5   Integration Steps
12.3   Other User Interface Technologies
12.3.1   Visual Composer
12.3.2   Adobe Offline Forms
12.3.3   Support for Custom User Interface Technologies
12.4   Summary
13   SAP Business Rules Management
13.1   How Business Rules Work
13.2   SAP Business Rules Management
13.2.1   Rules Composer
13.2.2   Rules Manager
13.2.3   Rules Engine
13.3   Modeling Business Rules with Rules Composer
13.3.1   Create the Rules Composer Development Component
13.3.2   Adding Context to the Rules
13.3.3   Creating a Ruleset
13.3.4   Flow Ruleset
13.4   Testing Business Rules
13.5   Best Practices for Modeling Business Rules
13.5.1   Separate Decision Logic from Other Types of Logic
13.5.2   Reuse and Extend before Building
13.6   Exercise: SAP Business Rules Management
13.6.1   Exercise Solution Approach
13.6.2   Exercise Step-by-Step Solution
13.7   Summary
14   Implementing Java Proxies
14.1   Java Proxy Concept and Considerations
14.2   Implementation Approaches
14.2.1   Outside-In Approach
14.2.2   Inside-Out Approach
14.3   Technical Implementation
14.3.1   Development Environment
14.3.2   Developing a Server Java Proxy
14.3.3   Developing a Client Java Proxy
14.4   Building an Orchestration
14.5   Exercise: Implementing Java Proxies
14.5.1   Exercise Solution Approach
14.5.2   Exercise Step-by-Step Solution
14.6   Summary
15   Administration and Monitoring Message Processing in SAP BPM
15.1   Monitoring
15.1.1   SAP Business Process Management System Overview
15.1.2   Process Repository
15.1.3   Process Management
15.1.4   Task Management
15.1.5   SAP BPM Inbox
15.1.6   Business Logs
15.1.7   SAP BPM Action Monitor
15.1.8   Process Troubleshooting
15.1.9   Rules Business Logs
15.1.10   SAP BPM Analytics Dashboard
15.2   Administration
15.2.1   Process Data Archiving
15.2.2   Log Viewer
15.3   Summary
16   Migrating ccBPM from SAP PI to SAP PO
16.1   Motivation for Migration
16.2   Migration Approach
16.2.1   Analyze the As-Is Integration Processes
16.2.2   Translate and Redesign
16.2.3   Export and Reuse Enterprise Services Repository Objects
16.2.4   Migrate and Adapt Configuration Scenarios
16.3   Recommendations
16.4   Summary
Part IV   Advanced Concepts
17   SAP Cloud Platform Integration for SAP PO
17.1   Enable Cloud Integration Content in SAP PO
17.2   Reusing Cloud Integration Content
17.2.1   Download Cloud Integration Content
17.2.2   Deploy the Cloud Integration Content
17.3   Monitoring
17.3.1   Monitoring the Integration Gateway Component
17.3.2   Monitoring Messages Related to the Deployment of Cloud Integration Content
17.4   Summary
18   Additional Components for SAP Process Orchestration
18.1   Component Model
18.1.1   Product
18.1.2   Software Components
18.1.3   Development Component
18.1.4   Dependencies among Development Components
18.1.5   Public Parts
18.2   SAP NetWeaver Development Infrastructure
18.2.1   Change Management Services
18.2.2   Design Time Repository
18.2.3   Component Build Service
18.3   SAP Composite Application Framework
18.3.1   Design Time Aspects
18.3.2   Runtime Aspects
18.4   Service Registry
18.5   Enhanced Change and Transport System
18.5.1   SAP PI-Related Transports
18.5.2   Transports for Non-SAP PI Java Objects
18.6   Exercise: Create an SWCV
18.6.1   Exercise Solution Approach
18.6.2   Exercise Step-by-Step Solution
18.7   Summary
19   Landscape Setup Considerations
19.1   Java System Configuration
19.1.1   Java Sizing and Setup Considerations
19.1.2   Java System Architecture
19.1.3   Java Central Services
19.1.4   Java Parameter Tuning
19.2   Handling Certificates
19.2.1   Certificate Key Storage
19.2.2   Encryption of Message Content on Database Level
19.3   Housekeeping
19.3.1   Archiving
19.3.2   Deletion
19.3.3   Restarting
19.3.4   Recovery
19.4   Monitoring
19.4.1   Runtime Workbench
19.4.2   Wily Enterprise Manager
19.4.3   SAP Management Console
19.4.4   SAP Solution Manager Monitoring
19.4.5   Tracing
19.4.6   JVMMON
19.5   Summary
A   Orchestration Outlook
A.1   SAP API Management
A.2   SAP Cloud Platform Integration
A.2.1   Features and Facts Overview of SAP Cloud Platform Integration
A.2.2   Development Guide: Getting Started
A.2.3   Monitoring
A.3   The Integration Advisor
A.3.1   Interface Specifications: Advice from the Advisor
A.3.2   Mapping Guideline
A.3.3   Runtime
A.3.4   Testing
A.4   SAP Cloud Platform Workflow as a Service
A.4.1   Workflow Service
A.4.2   Workflow Modeling
A.4.3   SAP Cloud Platform Business Rules
A.4.4   Workflow Tasks Management
A.4.5   Integration
B   The Authors
Index
Service Pages
Legal Notes










Foreword
In recent years, SAP has released a number of products to cover the roles of enterprise service bus, business rules engine, and business process engine. In 2012, SAP launched another product: SAP Process Orchestration. SAP Process Orchestration combines the power of multiple products (such as SAP Business Process Management [BPM], SAP Process Integration [PI], and SAP Business Rules Management [BRM]) into one single product running on the Java stack. This consolidated product brings numerous advantages to assist organizations in automating their business processes and their integration requirement needs, including (but not limited to) the following:


                Consolidated installation and monitoring
            

                Simpler landscape
            

                Features that support business process automation and integration
            

                Bridging the process modeling gap between the business and IT
            

                Lower cost of ownership
            

A few books have been written in the past to cover different aspects of the SAP middleware landscape, but none of these other books has taken a holistic approach that covers all three main components of SAP PO in a single book. That is what this practical combo book, SAP Process Orchestration: The Comprehensive Guide, does. The book explains how all the tools available in the SAP PO offering can be used to model different kinds of integration scenarios. The covered scenarios range from simple ones that only run on SAP PI, to more complex ones that utilize SAP BPM to coordinate complex flows and SAP BRM to enable flexible business process customizing.
In addition to providing a detailed explanation of the tools mentioned previously with the support of step-by-step examples, this book also explores some of the latest features released by SAP. The authors of the book have a lot of experience and a deep understanding of the subject matter, and they have taken the opportunity to address many other commonly asked questions, including the following:


                How do you migrate from a dual stack to single Java stack installation?
            

                How do you set up the landscape for transporting Java objects?
            

                What are the best practices in the SAP PO space?
            

                What is the possible future of the SAP middleware products combined with SAP Cloud Platform Integration?
            

                What should you consider when setting up an SAP PO landscape?
            

John and Roberto have gone above and beyond by providing exercises and solutions to help you practice and gain hands-on experience. This book is a must-read for any SAP integration consultant who wants to gain a deep understanding of the topic and to be able to support SAP PO implementations on an outstanding level.
Michal Krawczyk SAP Mentor SAP PI/SAP PO book author Eight times SCN Topic Leader in SAP PI/SAP PO SAP Integration Expert at int4.com









Acknowledgments
We would like to thank all the people who have contributed and supported us throughout the process of writing this book. We would like to start by thanking the team at SAP PRESS for all their support throughout the project. We are very thankful for your support and team spirit. You have made it all possible. This team includes Hareem Shafi and Meagan White.
Our humble and thankful recognition goes to Rojo Consultancy B.V. for making the project possible and to our colleagues who have contributed to a few chapters and supported us with their encouragement. Together, we make a great team. We would also like to acknowledge many others we did not mention by name for their direct and indirect support and interest in the book.
John Mutumba Bilay
I would like to thank Michal Krawczyk for his encouragement and for being a wonderful contributor to the SAP integration community.
I could not have asked for a better coauthor and friend than Roberto Viana. It is a true honor to work alongside you on this project that is so special to both of us.
A big thank you goes to my lovely wife Hermien for her loving support, patience, and encouragement. Thank you to Ralph, Luc, and Ruben for their understanding and for allowing me to spend weekends and evenings writing the book.
Without your support, I would have not been up to the challenge. Much love. Finally, thanks to my parents for providing a great model and for the exceptional upbringing that they provided.
Roberto Viana Blanco
I would like to extend my words of appreciation and gratitude to my best friend, John Bilay, who offered me the honor of taking part in this great project and making our dream come true. Thanks, mate. A special thank you goes to my dear wife and friend Mandy for being my cornerstone and for her endless patience and support throughout this period. To my beloved children, thank you for refueling my energies every time I needed it. Thank you very much Gabriel and Anna-Belle for allowing daddy to write and work through the weekends and holidays, when we were supposed to have fun together. I missed you a lot, too.
With this book, I also want to inspire my children (and their generation) to pursue their dreams, follow their hearts, and not stop till they reach their goals.
This book is also dedicated to my mother for being a constant source of positive energy and unconditional love, and to my Grandma Rosa, who always told me to follow my dreams and aim high.









Introduction
More than a decade ago, SAP launched its own enterprise application integration (EAI) platform under the name SAP NetWeaver Exchange Infrastructure (SAP XI). That event marked the beginning of a new era in which it was no longer necessary to rely solely on third-party integration platforms and traditional methods of integrating non-SAP systems with the large range of components and industry solutions delivered by SAP. From that moment, it became possible to support the integration of cross-system processes between SAP and non-SAP systems using open standards and modern integration technologies such as web services, Java, ABAP, and XML-based services. Since the successful introduction of SAP XI, its name has been rebranded twice, first in 2005 when SAP XI became SAP NetWeaver Process Integration (SAP PI), and then in 2012 to SAP Process Orchestration (SAP PO). With the introduction of SAP PO, not only did the name of the product change, but its internal architecture, features, development toolset, and way of creating integration solutions went through a rigorous redesign process. SAP PO now includes three main components that previously existed as separate entities: SAP PI, SAP Business Rules Management (SAP BRM), and SAP Business Process Management (SAP BPM). SAP PO provides enterprise service bus (ESB), process orchestration, and business-to-business (B2B) integration capabilities. In its latest version, SAP PO 7.5, an SAP Cloud Platform Integration runtime engine has been added, making it possible to leverage the cloud integration content for SAP PO. Needless to say, the future looks even brighter with the introduction of SAP PO 7.5!
For an IT organization or a business, SAP PO facilitates enterprise integration by providing a complete infrastructure to support your service-oriented architecture (SOA) strategy. You can now deliver reliable messages across the different systems of the organization using well-established sets of integration standards and communication protocols. The use of SAP PO promises to increase the flexibility of your integration solutions and to reduce the total cost of implementing new processes by encouraging the reuse of existing applications and services.
Furthermore, SAP PO enables the automation of the organization business processes and rules in a way that facilitates bridging the gap between the business and IT organizations. Both business processes and rules can reuse existing IT assets and thereby reduce total cost of ownership. SAP PO and its three core components (SAP PI, SAP BPM, and SAP BRM) will be the centerpieces of this book. The book also explores other platforms in the SAP NetWeaver family that can bring additional functionalities to SAP PO, including SAP NetWeaver development infrastructure, SAP Composite Application Framework (SAP CAF), the Service Registry, and the ability to leverage SAP Cloud Platform Integration artifacts.
Who This Book Is For
The book targets an audience that includes integration architects, business process experts, and developers. Integration architects and developers are responsible for designing, creating, and managing application-to-application and B2B integration within an SAP landscape.
Business process experts and developers are responsible for automating, optimizing, and managing business processes. This book can be used by readers both with and without prior knowledge of SAP PI, SAP BPM, SAP BRM, or SAP PO.
Structure of the Book
Let's take a brief look at what each chapter discusses.
Chapter 1 gives you an overview of the anatomy and features of SAP PO. This chapter will explain the need to move to a single stack and the positioning of different SAP PO components. SAP PO comes equipped with a number of administrative and development tools to provide easy access to its functionality and to empower system administrators and developers to unleash SAP PO's full power.
Chapter 2 makes you aware of the different administration and development tools, explains their backgrounds and roles, and specifies when to use each of them.
Chapter 3 describes the System Landscape Directory (SLD) and its roles within the context of SAP integration. An overview of SLD components is given and their functionalities explained. Detailed instructions on the steps involved in creating each SLD object are provided.
Chapter 4 explores and explains the fundamental concepts and different subcomponents and tools that make up the Enterprise Services Repository (ES Repository). This is a core component within the SAP NetWeaver stack that supports the design time of integration scenarios implemented with SAP PO. It is also a primary component in any enterprise SOA.
Chapter 5 sketches out a step-by-step description of how to combine these components and create a Java-only interface based on the Advanced Adapter Engine Extended (AEX). Different concepts around connectivity, routing, and alerting are covered in more detail. You will be able to build your own interfaces from scratch after reading this chapter.
In Chapter 6, we explore integration flows (iFlows) in detail, describing their role and positioning within the SAP integration landscape. With the support of a practical example and screenshots, we describe and illustrate the actions required to build an iFlow.
The Advanced Adapter Engine Extended (AEX) offers a wide range of tools to perform different kinds of administrative and monitoring tasks around your SAP PO landscape. In Chapter 7, we cover when and how to use which tool.
For those considering migrating from a current dual-stack or an older version of SAP PI to SAP PO, Chapter 8 presents the different available options to help you achieve your migration goals.
Chapter 9 explains the need for SAP BPM as an IT platform to automate your business processes. It introduces the core concepts and essential flow elements of the Business Process Model and Notation (BPMN 2.0), providing you with a solid foundation in understanding and modeling business processes.
Chapter 10 covers BPM concepts from a technical perspective, from modeling, building, and configuring a business process to compiling and deploying it.
After learning how to build an SAP BPM process from the ground up in the previous chapter, Chapter 11 explores how to configure the deployed processes. Furthermore, we look at advanced concepts, such as how to consume and leverage SAP BPM internal functionalities from an external application via the provided SAP BPM application programming interface (API).
To support human-centric processes, SAP BPM needs to integrate with a UI technology to allow the user to interact with the process tasks. This topic is explored in Chapter 12.
Chapter 13 introduces SAP BRM as a technology enabler to streamline the rules governing your business processes. SAP BRM makes it possible to centrally model, test, execute, and manage business rules all from one platform.
Chapter 14 introduces Java proxies and demonstrates how to use them to provide services and build composite services. Java proxies are a good alternative for those developers familiar with the Java programming language.
Chapter 15 explores how to effectively monitor your processes from a technical perspective with SAP BPM and gain a real-time or historic insight into their statuses and thus make informed business decisions.
If you're coming from a dual-stack SAP PI, then there's a high chance that you implemented your processes using cross-component Business Process Management (ccBPM). ccBPM is based on the SAP ABAP workflow engine. Because SAP PO is a Java-only installation, you'll have to migrate your current ccBPM process to SAP BPM. Chapter 16 explains how to approach such a migration.
Since version 7.5 of SAP PO, an SAP Cloud Platform Integration runtime engine has been made available. How to leverage and reuse cloud integration content artifacts from SAP Cloud Platform Integration is addressed in Chapter 17.
The Java stack comes equipped with more components in its toolbox that play an essential role in a good SAP PO implementation. These additional components are covered in Chapter 18.
The architecture and setup of your integration landscape will greatly influence the flexibility and performance of your SAP PO implementation. This is the focus of Chapter 19.
In the appendix, you're given a glimpse of some other neat features and products that can help bring your SAP PO installation to the next level, including SAP HANA Cloud Integration, SAP Cloud Platform Workflow, and SAP API Management.
The book includes a series of practical exercises. These exercises are designed to help you practice what you've learned in the chapters. As Aristotle once said, "For the things we have to learn before we can do them, we learn by doing them." Therefore, go ahead and enjoy these step-by-step guides.
Without further delay, we invite you to hop on to the first chapter and enjoy the journey with us.








Part IGetting Started







1    Introduction to SAP Process OrchestrationIf you can't describe what you are doing as a process, you don't know what you're doing.                                                                                         —W. Edwards DemingAs part of the SAP NetWeaver family, SAP provides a combo product called SAP Process Orchestration (SAP PO), which helps businesses and their IT organizations achieve most of their integration needs. SAP PO is composed of three different components, formed into a comprehensive installation package: SAP Process Integration (SAP PI), SAP Business Rules Management (SAP BRM), and SAP Business Process Management (SAP BPM).
Note
From this point on, we'll refer to SAP Process Orchestration or SAP PO whenever we're talking about the packaging of Advanced Adapter Engine Extended (AEX or SAP PI), SAP BRM, and SAP BPM.
This chapter will first explore how SAP PO came to be, what it is, and what it does. We'll then discuss the different components that make up the SAP PO platform, explore why these components are needed, and how they make SAP PO an essential piece in an organization's technology portfolio.
1.1    Historical Overview and Evolution
The three main components (SAP PI, SAP BPM, and SAP BRM) that make up the SAP PO software originate from SAP PI and SAP Composition Environment. In this part of the book, we'll explore the product's history and the way it evolved over the past years. Instead of focusing on every aspect of the evolution of the products, we'll focus on the highlights. We'll break the evolution history into three sections: SAP PI, SAP Composition Environment, and SAP PO. We'll then highlight some of the new functionality introduced with SAP PO release 7.5.
1.1.1    SAP Process Integration
In 2002, SAP Exchange Infrastructure (SAP XI) was launched as part of the SAP NetWeaver suite. SAP XI version 1.0 evolved into SAP XI 2.0 and SAP XI 3.0 in 2004. SAP XI was built on top of a dual-stack architecture, which includes SAP NetWeaver Application Server ABAP (SAP NetWeaver AS ABAP) and SAP NetWeaver Application Server Java (SAP NetWeaver AS Java).
After a few improvements and new features, the product was renamed from SAP Exchange Infrastructure to SAP NetWeaver Process Integration (SAP PI) in 2005. The initial SAP PI version 7.0 evolved to SAP PI 7.01, SAP PI 7.1, and SAP PI 7.11. The SAP PI 7.11 version included a more prominent Java stack. This was called the Advanced Adapter Engine (AAE) with which you could choose to build an entire interface in the Java stack. Not all types of connections and functionalities were supported at this point. For some scenarios, you still needed to use the ABAP stack.
Figure 1.1 shows a visual representation of the history time line.

Figure 1.1    SAP Process Integration Evolution and History
In 2010, SAP PI 7.3 was released with a more productively equipped Java stack: Advanced Adapter Engine Extended (AEX). This is a robust Java-only enterprise service bus (ESB) that can pretty much cover all the functionalities of the old dual stack, except that the processes previously implemented using cross-component Business Process Management (ccBPM) in a dual stack aren't supported. The functionality to support the automation of a process is now provided in the SAP Composition Environment product. SAP PI 7.3 was later enhanced with SAP PI 7.31 in 2012. We'll discuss SAP Composition Environment in the next section and provide a quick review of SAP PO in Section 1.1.3.
1.1.2    SAP Composition Environment
SAP Composition Environment is a platform that enables the building and running of applications based on service-oriented architecture (SOA). SAP Composition Environment comes equipped with tools that facilitate the development and composition of services and user interfaces (UIs) via a model-driven approach. With SAP Composition Environment, you can orchestrate new and existing services with the use of tools such as SAP BPM, SAP BRM, and SAP Composite Application Framework (CAF), among others. All of these tools facilitate the development of robust composite applications that leverage existing services.
SAP Composition Environment is part of the SAP NetWeaver suite and was first realized in 2007 with version 7.1 (see Figure 1.2). This release included tools such as Composite Application Framework, Guided Procedures, Visual Composer, Voice, Portal Content Modeling, Portal, and the universal work list (UWL). In this version, SAP BPM and SAP BRM did not yet exist.

Figure 1.2    SAP Composition Environment Evolution and History
SAP Composition Environment 7.11 was released in 2008 and included the early versions of both SAP BPM and SAP BRM.
After that, all included components were improved and enhanced in later releases, which included SAP Composition Environment 7.2, SAP Composition Environment 7.3, and SAP Composition Environment 7.31.
From the release of SAP NetWeaver 7.31 in 2012, it became possible to install SAP Composition Environment as a standalone application or as part of the SAP PO package. At the time of writing (2017), SAP Composition Environment version 7.4 is the current release.
1.1.3    SAP Process Orchestration
SAP Process Orchestration (SAP PO) was introduced in 2012. SAP PO is a comprehensive installation package that includes an ESB, business rules engine (BRE), and a BPE (BPE) in one piece of software, which runs on a Java-only stack.
It provides a combo and consolidation package that includes SAP PI and SAP Composition Environment and therefore encapsulates their combined set of features. With SAP PO, organizations can easily deliver reliable messages across the different internal and external systems using a well-established set of integration standards and protocols.
Furthermore, SAP PO provides a complete suite of business process management (BPM) and business rules management (BRM) development and administration tools to help organizations design, model, execute, monitor, manage, and analyze business processes and rules using one platform. This consolidation improves performance, increases efficiency, and reduces total cost of ownership (TCO), among other things.
It's also important to note that because SAP PO is a Java-only installation, ABAP functionalities do not exist and have been replaced by equivalent Java alternatives.
As Figure 1.3 shows, SAP PO was introduced from SAP NetWeaver 7.3 EHP 1 (7.31), and, in 2013, SAP PO 7.4 was released and has evolved since then to the recent SAP PO 7.5.

Figure 1.3    SAP Process Orchestration Evolution and History
Now that you're familiar with the evolution of the different components that make up SAP PO, we can dive into the details of the motivation for each of these components and how they can help meet your organization's integration needs. Before that, however, let's look into the highlights that SAP PO introduced or improved since SAP NetWeaver 7.5.
1.1.4    SAP Process Orchestration 7.5 Highlights
After the launch of the first edition of this book, around October 2015, SAP released SAP NetWeaver 7.5, which is a collection of several on-premise technology components, including SAP PO. New features and important improvements were introduced in different areas of SAP PO. Following are some of the important features introduced in that version of SAP PO:


SAP Java Virtual Machine 8 (SAP JVM 8) To stay on top of the last technology and new functionality delivered by the Java platform, Standard Edition 8 (Java SE 8), SAP NetWeaver Application Server and thus SAP PO run on SAP JVM 8. This means that you can take advantage of new Java features, for instance, in the areas of Java mappings, custom-built adapter modules, custom adapters, and third-party drivers (i.e., Java Database Connectivity [JDBC], Java Message Service [JMS]) needed by some SAP PI adapters.
                

SAP NetWeaver Developer Studio (often shortened to NWDS) support for Eclipse 4.4 (Luna) SAP NetWeaver Developer Studio supports Eclipse 4.4 Luna. You can use the same Eclipse version to build and manage the development of different technology platforms, including SAP PO, SAP Cloud Platform Integration, and SAP Cloud Platform.
                

SAP NetWeaver Developer Studio SAP PO perspectives extended Many enhancements and new capabilities have been added to the SAP NetWeaver Developer Studio Eclipse perspectives available for SAP PO. We'll elaborate further on some of these new features in the next sections.
                

SAP BPM application programming interface (API) enhancements The SAP BPM API was previously introduced to give programmatically and flexible access into the SAP BPM layer. In SAP NetWeaver 7.5, the API has been extended to enable subscription to lifecycle events triggered by processes and tasks. When an application subscribes to a certain type of event, for example, tasks created, task completed, and so on, it gets notified when that event occurs.
                

Running and reusing SAP Cloud Platform content on SAP PO The adoption of SAP Cloud Platform Integration is increasing, which means that the gap between on premise and cloud is becoming blurry. To cope with that trend, SAP has enabled a new feature called hybrid scenarios. This feature allows reusing and running SAP Cloud Platform Integration prepackaged integration scenarios on SAP PO. Section 1.3.1 provides a quick reference and URL to the online repository of available hybrid scenarios.
                










1.2    SAP Process Orchestration Components
To get a better understanding of why SAP PO can be useful, let's explore SAP PI, SAP BPM, and SAP BRM individually and get into the details of how they can support your organization. This section of the book also presents the positioning of these three components within an SAP landscape.
1.2.1    SAP Process Integration
It's far too common in our daily lives to encounter situations in which two or more systems need to be connected to exchange data. In the digital world that we live in, a typical organization will require multiple systems to perform its daily business tasks. The organization's human resource or employee data will be stored in an HR application, whereas financial data will be stored in a financial application. The choices of which software packages, applications, and vendors fit best for the task at hand will vary from organization to organization. However, the different systems in an organization usually need to exchange data and work together to support a particular business process or need.
The systems or applications involved in the exchange of data don't necessarily need to belong to the same organization or be part of the same network. Two companies doing business together might need to exchange information through their respective applications, which come in all sizes, shapes, and flavors. They also generally don't speak the same language, and they cover business processes that belong to different industries. They are located in different time zones and continents and don't have the same security requirements. The list of differences goes on and on. All of these factors increase the complexity and challenge of achieving a seamless integration between all concerned systems.
The next section illustrates two approaches that organizations use to solve these integration challenges. For that purpose, we'll explore point-to-point integration. We'll also look at an integration approach using an ESB, such as SAP PI or AEX, and address why such an approach is a better way to tackle your integration challenges.
Point-to-Point Integration
Some organizations take the easy way and choose point-to-point communication, as shown in Figure 1.4. In a point-to-point communication, each communication involves two systems: the source system sends information to or requests information from the target system. There is a dedicated connection line between the two systems involved in the communication, and the systems can therefore be seen as tightly coupled applications.

Figure 1.4    Point-to-Point Integration: Systems Directly Connected to Each Other
At first glance, this approach looks simple and fast to implement, especially with fewer applications to connect. However, its disadvantages become visible very quickly as the organization's integration landscape becomes more complex and larger. The point-to-point approach forms a spider web of application connections, which keeps growing exponentially as more systems are introduced into the landscape.
Each system is aware of the connection and message details of the system on the other side of the exchange. Every time a particular system changes or needs to be replaced, the impact will be felt by all other systems communicating with it. If a vulnerable security connection is discovered in one of the systems, all applications currently connecting with it will need to be changed, adapted, and potentially be unavailable for a long time, all of which results in higher costs of development and maintenance in the long run.
Integration Using an Enterprise Service Bus
To avoid some of the issues resulting from a point-to-point strategy, you can opt instead for a service-oriented architecture (SOA) strategy. SOA is a design pattern that focuses on exposing the functionalities of a business application as services.
These services can be seen as self-contained components that provide a specific functionality, which can be remotely called or invoked. The services are published, and potential consumers of the services can discover them. This approach encourages loose coupling of functionality and therefore enables reusability and cost savings. SOA has been around for a while and is widely used. There is plenty of information published about SOA, so we'll spare you from the theoretical details in this book. For more information on SOA, refer to www.opengroup.org/standards/soa.
An ESB can enable you to support an SOA in your organization's ecosystem. This is where SAP PI or AEX enters to save the day (see Figure 1.5).

Note
The terms SAP PI and Advanced Adapter Engine Extended (AEX) are sometimes interchangeably used. These terms are pretty much referring to the same product. The only exception is that SAP PI might include a dual stack (Java and ABAP), whereas AEX is always a single stack (Java only).


Figure 1.5    Integration Using an ESB: AEX at the Center of All Message Exchanges
AEX plays the roles of middleman, courier, and translator. AEX is an ESB, and it takes care of implementing the communication and interaction between the software applications that are interacting and exchanging data. It's at the heart of your SOA implementation strategy. Figure 1.5 shows how the AEX can intervene and simplify the communications between the different systems. Some of its duties include the following:


                        Controlling the routing of message exchange between applications
                    

                        Handling the transformation and mapping of the data and messages transferred from the source to the target system and vice versa (which implies that the message structures of the business applications on both ends of the exchange don't need to be the same)
                    

                        Handling the security and conversion of protocol between the service provider and consumer
                    

                        Monitoring the exchange of messages between the involved systems
                    

                        Managing the various versions of the services provided by the ESB
                    

The ESB eliminates the need for a point-to-point connection. By having smaller units of functionality exposed as services, you can build composite services; in other words, you can combine or bundle many smaller services into a new bigger service or composite application.
For the purposes of this book, whenever we refer to SAP PI, we mean the Java-only stack (or AEX), unless specifically stated otherwise, because only the Java stack (also called AEX) is used in SAP PO.
1.2.2    Business Process Management
To run a streamlined business, a typical organization has a clearly defined business process that describes the actions and steps to be performed to complete a particular task. You probably encounter these business processes every day. For example, when a new employee comes into an organization, he needs to send his details to the HR department to complete the hiring business process. Or when an employee needs to order a new computer, the employee's manager might need to approve the ordering of the computer as part of the process that has been defined within the organization. An organization could decide to automate and support such a process by using a business process engine (BPE). Figure 1.6 shows how a business process can be managed in the BPE.
The SAP BPM toolset provides multiple benefits in this arena, including the following:


                    Enables your organization to support both human-centric and system-centric processes
                

                    Improves the visibility and control on your organization's processes


                    Provides flexibility to adapt your processes to the current needs of your business rapidly
                    
Figure 1.6    Process to Order a Computer Using SAP BPM


1.2.3    Business Rules Management
The business world is constantly changing. These changes can be internally influenced by an organization or externally influenced (e.g., a new employment law to a change in consumer behavior).
A typical organization wants to quickly adapt to those changes in the business environment to keep its competitive advantage. This adaptation might result in a change of existing business rules. Businesses can design and define their decisions and business rules in a business rules management (BRM) system. Given that these rules are subject to constant changes, it makes sense to maintain and keep them separate from the actual business applications. This externalization of business rules creates the flexibility to change such rules without having to change the business applications.
As an example, consider an HR application. This application is used to maintain all employees' details, including their position in the organizational structure. Let's consider a hypothetical business rule within the organization which stipulates that if an employee has a minimum of 10 colleagues reporting to him, then he needs to be promoted to manager. Such a requirement is best maintained in a business rule, rather than being hard-coded in the HR application itself. Having the rule outside of the HR application will enable other applications to reuse the application. In addition, the rule can be adapted quickly without needing to change the actual HR application. See Figure 1.7 for an example of this rule's possible implementation in SAP BRM.

Figure 1.7    Business Rule Flow Based on the Rules Modeling Tool of SAP BRM
Here, SAP BRM brings added value. Some of the benefits SAP BRM offers include the following:


Separation of logic and dataData is maintained in the business application, whereas the logic is maintained in the rule engine.
                

Central repository of rules  and knowledgeAll existing rules can be accessed from a central place.
                

AutomationOrganizations are enabled to automate business decisions.
                

User-friendly interfaceFunctional and business users are empowered to be involved in the definition, development, modeling, and modification of business rules via a user-friendly interface. Parts of the automated business rules can be updated by business users themselves without the participation of developers and without the need for redeployment (real-time updates).
                










1.3    Architectural Overview and Positioning
This section explains how the different components of SAP PO fit together. We'll also take a look at the use of each of the components and justify why each component's positioning represents a good approach and a robust architecture. Finally, we'll discuss some of the advantages and disadvantages of using such an architectural approach.
1.3.1    SAP Process Orchestration Positioning
As depicted in Figure 1.8, SAP PO, which includes AEX, SAP BPM, and SAP BRM, is placed between the service-enabled applications (backend applications), the UI (presentation layer), and the external (cloud, business-to-business [B2B] Electronic Data Interchange [EDI], etc.) applications.
The backend applications can be any on-premise SAP or legacy applications that provide a particular business content and functionality to an organization. Most SAP backend applications come equipped with standard enterprise services provided by SAP. Whether delivered with standard services or not, the applications can be connected to via a diverse range of connectivity adapters provided by SAP PI.
The AEX layer links all of the message traffic and exchange of data between applications. It plays the role of ESB and exposes the backend application's functionalities as services or interfaces. It can also leverage enterprise services provided by SAP in the backend applications. The exposed services are presented in a format that suits widely accepted standards and protocols, such as Simple Object Access Protocol (SOAP), JMS, and many others.
The developed services can be maintained, discovered, and managed in the Enterprise Services Repository. The services can be published, searched, and discovered by using the equivalent of the yellow pages for services: the Service Registry.

Figure 1.8    Positioning of SAP PO (SAP Composition Environment and SAP PI)
After all required services have been made available via the SAP PI layer, you can position the SAP Composition Environment layer on top. The composition layer encapsulates products such as SAP CAF, SAP BRM, and SAP BPM. It's now possible to build different composite services and applications based on individual services exposed by the process integration layer (supported by SAP PI or AEX). This approach lets the composition layer leverage and reuse the services already provided by SAP PI and therefore saves on costs. This approach also lets the composition layer focus on the composition and bundling of services together to provide new functionalities and leaves integration-related work to SAP PI.
SAP PO also supports B2B integration scenarios, whether that involves traditional EDI, Secure File Transfer Protocol (SFTP), or modern cloud-based integration, multiple B2B protocols are supported. However, be aware that some specific platform prerequisites might apply to enable the B2B add-on functionality in SAP PO.
Furthermore, since SAP NetWeaver 7.5, you can also reuse SAP Cloud Platform Integration (formerly known as SAP HANA Cloud Integration) content in SAP PO. This so-called hybrid scenario, that is, on premise to cloud and vice versa, support different types of business processes as part of SAP cloud products such as SAP S/4HANA Cloud, SAP Hybris Cloud for Customer, SAP SuccessFactors, and many more. For a complete overview of which prepackaged content SAP is currently offering, you can go the SAP Marketplace and look for the hybrid scenarios overview page via this link: http://service.sap.com/hybrid.
The presentation layer, which includes all technologies the end user directly interacts with, is placed above the composition environment. Technologies such as SAP Enterprise Portal, mobile apps, and desktop applications have the flexibility to directly interact with a business process via the composition environment or alternatively to communicate with the integration layer if no processes or composite services are involved in the scenario.
1.3.2    SAP NetWeaver Application Server for Java: System Architecture
SAP PO is fully built on top of the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java), so it's essential to have a high-level understanding of the SAP NetWeaver AS Java architecture to better understand SAP PO's foundation and capabilities.
SAP NetWeaver AS Java is at the core of the SAP NetWeaver technology. It facilitates functionalities spanning from deployment to running Java applications. Depending on your system requirements, you might consider using an SAP NetWeaver AS Java cluster to enable more scalability and reliability.
As depicted in Figure 1.9, a simple SAP NetWeaver AS Java installation is made up of three main components:


                    A Java instance
                

                    An SAP Central Services (SCS) instance
                

                    A database
                

You can also extend the cluster by adding more Java instances.

Figure 1.9    Composition of a Simple SAP NetWeaver AS Java Cluster Installation
In the next sections, we explain the roles of each component.
Java Instance
The Java instance is made up of two main components. First, the Internet Communication Manager (ICM) is used to regulate the communication between SAP NetWeaver AS Java and any outside application request. Most common requests from outside are made using HTTP, HTTPS, and Simple Mail Transfer Protocol (SMTP). The ICM listens to a specific URL and port number combination through which the requests are made. After receiving the requests, the ICM transfers or forwards them to the relevant internal applications and server processes. The ICM plays the roles of load dispatcher and balancer. It's important to mention that the ICM is responsible for receiving requests and for sending them to the outside world.
Second, the server processes receive all the requests that are forwarded by the ICM and are responsible for the actual execution of these requests with the Java EE applications. Depending on your landscape requirements and the expected load, more server processes can be added. The server processes are multithreaded (i.e., have multiple threads) and are therefore capable of handling a huge number of requests concurrently.
SAP Central Services Instance
The SAP Central Services (SCS) instance plays a critical role and forms the basis and foundation for all synchronizations and communications that take place in your SAP NetWeaver AS Java clustered installation.
The SCS instance is made up of the following components:


Message server The message server maintains availability information about all the server processes of the entire cluster and then provides this availability information to the ICM to help it dispatch the incoming request to the correct (available) server process. As shown in Figure 1.10, another responsibility of the message server is to facilitate the exchange of messages and communication between the different server processes in your SAP NetWeaver AS Java cluster.
                    



Enqueue server This component is responsible for regulating and managing the lock table. All requests to lock resources are forwarded to the enqueue server, which determines whether or not there is already a lock of the resource. If the resource isn't locked, then a lock is placed, and a new record is inserted in the lock table. If the resource has an existing lock (called lock collision), then the lock request is rejected.
                        
Figure 1.10    Message Server Enabling the Communication and Exchange of Messages between the Different Java Server Processes in the Cluster


Database
The central database is responsible for storing and persisting all the application data and the data related to the configuration of the system.
Now that you're familiar with the architecture of SAP NetWeaver AS Java, let's look at the layers that are included in such a system.
1.3.3    SAP NetWeaver AS Java System Logical Layers
The SAP NetWeaver AS Java engine is made up of three main components and layers (see Figure 1.11):


                    Java enterprise runtime


                    SAP NetWeaver AS Java system components or services


                    Applications



Figure 1.11    Main Layers and Components of the SAP NetWeaver AS Java System
These three components depend on each other. They have a dependency hierarchy from the bottom component to the next higher one; the lower components need to be available before the higher ones can be used. This implies that when your SAP NetWeaver AS Java server s starting up, the Java enterprise runtime is started first. Next, the SAP NetWeaver AS Java system components and services are started. Finally, all applications deployed on the server can be started as well.
In the next sections, we'll explore the functionalities and roles of each of the three components.
Java Enterprise Runtime
The runtime provides the core functionalities for the running of all applications. It contains components that have the main task of managing the internal resources of the server. The following are some of the components and their roles:


Session Manager Manages the sessions on the server and ensures sessions fail over. This component ensures that the data saved in a session isn't lost if the application server becomes unreachable.
                    

Application Thread Manager Manages all threads used on the server to process requests on deployed and running applications. This component balances resource allocation for all incoming application requests and prevents a system overload.
                    

Cache Manager Manages all caching functionalities used by the different components in SAP NetWeaver AS Java.
                    

Locking Manager Manages all locking and unlocking of resources based on the enqueue server.
                    

Log Manager Manages the foundation of the logging mechanism in the server. This component is responsible for all logging activities in the application server.
                    

Cluster Manager Manages the communication and exchange of messages between the different cluster nodes or elements.
                    

Database Manager Manages the connections to the database.
                    

Pool Manager Used to manage the pool of existing connections. This component explicitly creates and manages connection pools. All unused connections are cleaned up.
                    

Class Loader Manager Can be accessed in the SAP NetWeaver Administrator. This component enables the management of loading references between the different Java classes or applications.
                    

Configuration Manager All configuration performed in any components or applications of the application server needs to be persisted and saved in the database. This component provides the required support to save and retrieve this configuration data.
                    

Licensing Manager Provides features to manage all SAP license- and certificate-related data in a uniform and central manner.
                    

SAP NetWeaver AS Java: System Components
These components can be seen as services running on the server. Each of these components or services performs a specific task, and together they facilitate the communication and collaboration between the SAP NetWeaver foundation and all of the applications running on top of it. These components can be categorized as follows:


Facades  Provide a means by which an external application can directly communicate to the application server using a Java API.
                    

Interfaces  Provide ways for the different components to communicate with each other.
                    

Libraries  Provide a set of loadable libraries that Java applications can call during runtime.
                    

Services Access and expose the runtime functionality with the use of the framework API.
                    

Applications
This layer comprises different types of Java-based applications—from standard Java applications delivered by SAP to custom Java applications written by you as an SAP NetWeaver developer.
Applications residing in this layer can leverage the different functionalities provided by the SAP NetWeaver AS Java system components layer via APIs.
Applications can be generally categorized into the following different groups:


                        A standalone web module (WAR files)


                        A standalone Enterprise Java Bean (EJB) module (JAR files)


                        A standalone resource adapter module (RAR files)


                        SAP NetWeaver AS Java system components (services, libraries, and interfaces)
                    










1.4    Installation Options
Given that SAP PO is a consolidated package with AEX, SAP BPM, and SAP BRM in one single Java stack, it's interesting to consider moving to an SAP PO installation to reduce your hardware utilization, remove overhead, and save costs.
SAP PO is available from the release of SAP NetWeaver 7.31 as one of the installation options (more are available). In this section, we'll consider other possible installation options and explore the advantages and disadvantages of each.
It's important to mention that the ABAP stack isn't expected to be phased out soon and will continue to be supported, but all new developments around SAP PO will be focused on the new Java-only stack. As a result, we recommend moving to a single-stack installation to benefit from new developments and product features.

Note
Since the introduction of SAP NetWeaver 7.5, SAP Composition Environment is no longer included as an SAP NetWeaver usage type but instead as a separate component. In addition, notice that as of SAP NetWeaver 7.5, the support of SAP PI dual-stack (ABAP/Java) has been discontinued. If you still need an SAP PI dual-stack, then you have the option to install it as separate SAP NetWeaver AS Java and SAP NetWeaver AS ABAP components, each with its own system ID.

Let's move on to discuss the different installation options on a case-by-case basis.
1.4.1    Case 1: SAP Process Integration Dual Stack
In an SAP PI dual-stack installation, you have the full-featured SAP PI equipped with the latest features of both the ABAP and Java stacks as shown in Figure 1.12. Besides the usual components, such as the ES Repository, Integration Directory, and System Landscape Directory (SLD), you also have the following runtime engines:


                    Integration engine


                    Business process engine (BPE)
                

                    Advanced Adapter Engine (AAE) (Java based)
                


Figure 1.12    SAP PI Installation Option, Dual Stack of SAP NetWeaver AS Java and SAP NetWeaver AS ABAP (Not SAP PO)
This implies that you can make use of the ABAP side if it best suits your needs. Two of the disadvantages of this approach include the following:


                    Lack of a business rules engine, which is normally part of an SAP PO or SAP Composition Environment installation
                

                    Business processes can only be implemented using ccBPM and therefore don't take advantage of SAP BPM
                

This installation option can be useful for organizations that have already heavily invested in their ABAP installation (integration engine and ccBPM) and aren't yet ready to make the move to a fully Java-only environment. If you have such an installation option, then it's important to consider developing the new interfaces using Java-based interfaces (whenever possible) because you have a Java stack included in your dual stack.
1.4.2    Case 2: SAP PI Dual Stack and SAP Composition Environment in Separate Installations
This installation option extends the previous option (case 1) with an additional separate SAP Composition Environment installation, so you end up with two separate installations as shown in Figure 1.13. One installation covers the SAP PI dual stack, and the other covers SAP Composition Environment. Each installation has a different system ID. This option presents a mixed scenario. You can choose to implement interfaces using the integration engine (ABAP) or the AAE (Java). Likewise, business processes can be implemented in ccBPM or SAP BPM.

Figure 1.13    SAP PI Dual Stack Installed Separately from SAP Composition Environment: Provides the Same Features as SAP PO
Some of the disadvantages of this option include the following:


                    A communication overhead is introduced by having SAP PI and SAP Composition Environment in separate installations; the two installations have to send each other messages constantly.
                

                    More hardware is used due to having two separate installations, which introduces added costs.
                

                    Both ccBPM and SAP BPM can be used to implement business processes, creating a confusing situation in which you need to guess which business process is implemented in which installation.
                

Because of these disadvantages, we recommend choosing Java-based implementations as much as possible; in other words, it's better to choose the AAE and SAP BPM.
1.4.3    Case 3: SAP PI Single Stack and SAP Composition Environment in Separate Installations
This option is similar to the previous one, but on the SAP PI side, only the single stack (Java) is installed. Both SAP PI and SAP Composition Environment are composed of Java stacks only, but they are installed in two separate installations as shown in Figure 1.14.

Figure 1.14    SAP PI with Java Only (AEX) and SAP Composition Environment in Separate Installations
A clear downside of this option is the network communication overhead created between the two separate installations. However, it's important to mention that such decoupling of the system can bring its own advantages:


                    Reliability (if the SAP Composition Environment installation is down, then all integration-related traffic can still carry on, because it's separated from the SAP PI installation).
                

                    The decoupling of SAP PI and SAP Composition Environment creates a form-inherent distribution.
                

1.4.4    Case 4: SAP PO—SAP PI and SAP Composition Environment in a Single Installation
In this option, a combination of SAP PI, SAP BPM, and SAP BRM is installed in the same installation with the same system ID, as shown in Figure 1.15. This packaging of products is known as SAP PO and provides a lot of benefits.

Figure 1.15    SAP Process Orchestration: AEX, SAP BPM, and SAP BRM in a Single Installation
As a consolidated package, SAP PO provides tight integration among AEX, SAP BPM, and SAP BRM. Some of SAP PO's advantages include the following:


                    Consolidated installation eliminates communication overhead (as observed in cases 2 and 3).
                

                    The cost of ownership is lower due to reduced hardware needs and license costs based on CPU.
                

                    The same technology (Java) is used across the board, which in turn means that you can use the same Java-based development tools across the board, such as in SAP NetWeaver Developer Studio.
                

                    Monitoring is consolidated, and the landscape is simplified.
                

Because of these benefits, we recommend choosing this simplified package.









1.5    Summary
This chapter introduced you to the SAP PO product and provided a high-level overview of its features. We explained that SAP PO is a bundled platform installed on a Java-only stack consisting of SAP PI, SAP BPM, and SAP BRM. The consolidation of these different products into one single Java stack package accounts for a reduction of overhead, lower footprint, up to 60% less energy consumption, improved performance, and a decrease of TCO.
SAP PI plays the role of ESB and enables an SOA strategy implementation in your landscape. In addition to SAP PI, SAP PO is also equipped with a BPM system used to automate both system-centric and human-centric processes and tasks. SAP BPM can be considered an orchestration layer that sits on top of SAP PI. Both SAP PI and SAP BPM components are connected via the proprietary SAP XI 3.0 protocol, which ensures message reliability.
SAP BRM facilitates the easy creation and modeling of business rules. It enables organizations to automate business decisions and to create flexibility to quickly adapt their business rules to the needs of their businesses and markets. SAP BRM constitutes a central repository for all business rules.
We also highlighted some of the new capabilities and improvements of SAP PO found in the release of SAP NetWeaver 7.5, such as the support of SAP JVM 8 and the combination of on-premise to cloud hybrid integration scenarios.
The next chapter will introduce the toolset that facilitates development and administration activities in the SAP PO platform.








2    Administration and Development ToolsImagination is everything. It is the preview of life's coming attractions.                                                                                                    —Albert EinsteinSAP Process Orchestration (SAP PO) comes equipped with a broad collection of administrative and development tools that provide easy access to its internal functionality and that empower system administrators (SAP Basis) and developers to unleash SAP PO's true potential.In this chapter, we'll talk about the main administration and development tools provided with SAP PO and provide guidance about when and how to use these tools for developing and administering your integration solutions.
2.1    SAP Process Orchestration Tools
SAP PO has a home page from which administrators and developers find their way to SAP PO's most important components. All process integration tools are bundled together on that page, as shown in Figure 2.1. Those tools represent the start point of any integration solution built on top of SAP PO. From there, developers and administrators can find all important links (with the exception of SAP NetWeaver Development Studio and SAP NetWeaver Administrator) to the necessary tools and infrastructure to design, build, configure, monitor, and manage integration solutions implemented with SAP PO. Each of these tools can help you fulfill specific administration and development activities during design, configuration, and runtime.

Figure 2.1    Process Integration Tools Landing Page
For those of you who have been working with earlier versions of SAP Process Integration (SAP PI) or SAP Exchange Infrastructure (SAP XI) in the past, not too many differences will be noticeable at first sight. However, the major changes are found in the internal functionality of each tool, as you'll discover in this chapter. A completely new generation of administration and development tools is represented by SAP NetWeaver Administrator and SAP NetWeaver Development Studio (often referred to as NWDS). Both tools fit perfectly into the new generation of Java-based product lines offered by SAP NetWeaver.
To access the Process Integration Tools page, go to http://<hostname>:<port>/dir, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
Table 2.1 provides an overview of the different tools and main areas and components that we'll explain in more detail in the next sections.




                        Main Area
                    

                        Component Name(s)
                    





                        Enterprise Services Repository (ES Repository)
                    



                                Enterprise Services Builder (ES Builder)
                            

                                Enterprise Services Registry (ES Registry)
                            

                                Web UI
                            





                        Integration Directory
                    



                                Integration Builder
                            








                                SAP Cloud Platform Integration content
                            





                        System Landscape
                    



                                System Landscape Directory (SLD)
                            





                        Configuration and Monitoring
                    



                                Monitoring Home (pimon)
                            

                                SAP NetWeaver Administrator
                            





Table 2.1    Process Integration Tools Overview
2.1.1    Enterprise Services Repository
The role of the Enterprise Services Repository (ES Repository) within the context of an enterprise service bus (ESB) such as SAP PO is to maintain specific operational metadata about the services that SAP PO provides and consumes. The ES Repository provides developers with a complete modeling environment for creating service-oriented architecture (SOA)-style enterprise services.
The ES Repository (see Figure 2.2) supports the design time in SAP PO and stores metadata related to the services' versions, namespaces, deployment status, access and security rules, mapping and transformations, service operations, data and message types, and external message definitions, such as Web Services Description Language (WSDL) and Extensible Markup Language (XML) definitions (XSD).

Figure 2.2    ES Repository Architecture
The ES Repository is also used to import and maintain SAP standard content (ES Repository content), provided as part of different SAP industry solutions or by certified third-party software suppliers. The ES Repository content is also called business content and can be downloaded via the SAP Service Marketplace or via the ES Workplace. You'll need proper SAP Service Marketplace credentials to download any content. The business content imported into the ES Repository normally contains repository objects, such as service interfaces and messages types, but it can also offer additional content, such as mappings, integration processes, and so on. The ES Repository may also use external sources from other third-party repositories (Services Registry needed), such as existing Universal Discovery, Description, and Integration (UDDI) directories and Active Directory.
In the following subsections, we'll help you better understand the role of the ES Repository and how to position it within the SAP PO architecture. After that, we'll talk about the ES Builder and Service Registry.
Understanding the Enterprise Services Repository
One of the challenges we commonly encounter as SAP integration specialists is how to explain the roles and functions of the different products contained within the SAP NetWeaver suite to nontechnical and business folks. After many years of dealing with this challenge, we've found a simple yet effective way of achieving that goal by using analogies from our daily lives. Explaining the Enterprise Services Builder (ES Builder) is no exception.
Here's how it works: Try to picture a large, blue, plastic bucket filled with lots of LEGO pieces, all of them in different colors, shapes, and sizes. Now, imagine that you're building an airplane or any other object you would like to build with LEGO bricks. When you have that picture and the process of designing and assembling new objects using different building blocks clear in your mind, you're more than halfway to understanding what the function and role of the ES Repository really is. The LEGO bricks in the bucket are similar to the ES Repository. When you start building your new LEGO creation by searching, selecting, and assembling different LEGO bricks, it's similar to using the ES Repository Builder to build new service interfaces by creating or reusing repository objects stored in it.
Local or Central Enterprise Services Repository
In SAP PO, you have the option to configure one local ES Repository per SAP PI instance (which is the default setup) or to have a central ES Repository connected to all SAP PI systems that are available in your system landscape. These options are as follows:


Local ES Repository per SAP PO instance With this option, each SAP PI instance within the system landscape has its own dedicated ES Repository directly connected to the "local" Integration Directory and runtime engine (i.e., the Advanced Adapter Engine Extended [AEX]). The advantage of this setup is in its simplicity, as well as less initial installation effort required from the SAP Basis team.
                    

Central ES Repository for all SAP PI instances In this setup, a single ES Repository is hosted on the central SAP PO instance. The Integration Directory and the runtime engine (AEX) of the local SAP PO instance are directly connected to the central ES Repository. The advantage of this architecture is that you can minimize total cost of ownership (TCO) because the number of ES Repositories is reduced. At the same time, you save time by removing the need for transport scenarios and administration tasks.
                    

Enterprise Services Builder
You use the ES Builder to access and create content for the ES Repository. It can also be seen as the implementation of the ES Repository and a core component of SAP PO. The ES Builder is a development tool with which you design and develop logical building blocks to support integration applications that follow SOA principles (see Figure 2.3). Object types created in the ES Builder are stored and maintained in the ES Repository.

Figure 2.3    Enterprise Services Builder: ES Repository

Note
The ES Builder is known by most SAP PI developers simply as the Integration Repository or just Repository.


ES Builder: Recommended System Requirements
The following recommendations apply for running the ES Builder on your development laptop or desktop:


                            A minimum of 4GB of system internal memory (8GB is better)
                        

                            Java Development Kit (JDK) 6 or newer
                        

                            Java Web Start
                        

                            Web browser (Mozilla Firefox, Google Chrome, etc.)
                        

                            Windows administrator/developer rights
                        


When you click on Enterprise Services Builder link from the Process Integration Tools home page (refer to Figure 2.1) and enter your SAP PO user credentials, a pop-up will appear, asking your permission to load the ES Builder's required libraries and to run it as a Java Web Start application. After you've given permission, the application will start downloading all necessary libraries from the server hosting SAP PO (see Figure 2.4). This action might take a few minutes depending on the speed of your network connection.

Figure 2.4    Downloading ES Builder's Required Java Client Libraries

Tip
If SAP Single Sign-On (SSO) is available in your SAP landscape, then some of the preceding steps could be skipped. This also depends on your firewall settings for Java programs and antivirus software installed on your local PC.

If you encounter problems launching the Java Web Start application, then you can try one of the following possible solutions:


                        Make sure your users have the proper rights to run Java Web Start from their browsers.
                    

                        Verify the recommended system requirements for running ES Builder (see previous box).
                    

                        Check your settings for the Java Runtime Environment (JRE). In Windows, go to the Control Panel, and choose Java, then click on the Java tab and select View to check your user and system JRE settings. You should see the entry shown in Figure 2.5.
                    


Figure 2.5    Windows Java Runtime Environment
A dialog box with different Available Profiles is presented to the user the first time the ES Builder is started. Within the context of this book (i.e., SAP PO), we'll assume that you should choose the Unrestricted profile (see Figure 2.6).

Figure 2.6    ES Builder: Available Profiles
Tasks Performed from Enterprise Services Builder
The ES Builder is mainly used by SAP PO developers to perform different development activities at design time. The following is an overview of the typical activities performed by developers before and during the development of repository objects inside the ES Builder:


Configure personal settings The behavior of the ES Builder user interface (UI) can be configured to meet diverse personal preferences (e.g., language or navigation options) and certain organizational requirements (e.g., automatic publishing to ES Repository) for different users. To access the personal settings from the main menu, choose Tools • Personal Settings (see Figure 2.7).
                    


Figure 2.7    Configuring Personal Settings from ES Builder


Edit authorizations By default, all objects in the ES Builder initially have unrestricted access for all ES Repository users. By editing the authorizations, specific permissions can be granted to groups, roles, and users to perform activities in the ES Repository.
                    

Define work areas This functionality gives you the opportunity to create new software component versions (SWCVs) (imported from SLD and as local SWCVs), folders, namespaces, and usage profiles on the fly. The same menu can also be opened by right-clicking on a SWCV, namespace, or folder, and then selecting New (or press (Ctrl)+(N)).
                    

Browse and search for object types Repository objects can be used in different integration scenarios and SWCVs throughout the repository. This advanced search function provides an extensive set of search parameters and operators to help you find all kinds of object types across the repository.
                    

Edit object types This is one of the main functionalities when it comes to the common actions executed from the ES Builder repository: creating, editing, copying, and deleting objects. Other useful functions in this category include, for example, the Where-Used list (which shows a list of where the object selected is currently used) and the Check Object function (which validates the overall consistency of the object).
                    

Manage object changes Change lists are created as soon as the user edits or creates new repository objects. A change list is automatically created per SWCV. The user can then accept and activate or reject the change list. Change lists can also be transferred from one user to another if necessary.
                    

Monitor and analyze cache notifications The cache status overview provides a total overview of all cache refresh notifications and their statuses after change list activations are performed by different users from the ES Repository. You can select filters based on period and SAP PI user.
                    

Clear SLD data cache This function allows the developer to clear the SLD data cache used by the ES Builder during design time. This type of cache is maintained by the ES Builder to improve performance while accessing information (metadata) such as SWCV and main instances from the SLD. The SLD data cache is updated automatically when you start the ES Builder.
                    

Enterprise Services Registry
Services are small pieces of software and as such have a lifecycle like any other software: they are designed, created, published, consumed, changed, and, at some point, removed from the software landscape in which they operate. The more services you add to your landscape, the greater the need for a central place where service-related metadata and other related information is kept and managed. This is where the Enterprise Services Registry (ES Registry) comes into play (see Figure 2.8).
As mentioned in Chapter 1, you can think of the ES Registry as a virtual yellow pages directory that maintains a record for all (published) web services available in your landscape. In the ES Registry, you can maintain web services for SAP and non-SAP applications. Services are classified into different categories, depending on their lifecycle statuses. Developers can publish their services into the ES Registry directly from the ES Builder, Integration Builder, or from SAP NetWeaver Development Studio. After a service has been published, it can be queried and found by service consumers on the ES Registry.

Figure 2.8    Enterprise Services Registry

ES Registry: Fact Sheet
The following are a few miscellaneous details about the ES Registry that you should know:


                            ES Registry isn't a mandatory component for the SAP PO landscape. However, when positioned properly, it can add more control and structure to the way web services are managed (service provisioning and consumption) across an SOA landscape.
                        

                            Services created in SAP PI, SAP Composition Environment, SAP Business Process Management (SAP BPM), and an SAP (NetWeaver-enabled) backend can be automatically published in the ES Repository. In the same way, it's also possible to search for and retrieve services by using the ES Repository from the SAP products mentioned previously.
                        

                            Third-party (non-SAP) services can be published into the ES Registry either by directly importing the service's WDSL into the ES Registry or by integrating external UDDI-based registries with the ES Registry. For more information about how to integrate non-SAP service registries with the SAP ES Registry, see SAP Note 1277970.
                        

                            One central SAP ES Registry is sufficient to manage all web services and to be shared across an SOA landscape. However, it can coexist with other service registries if necessary.
                        

                            ES Registry is based on UDDI version 3 and runs on the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java).
                        


Web User Interface
A quick and easy way of browsing, searching, and managing service interfaces and certain related repository objects is provided by the Web UI, also called ES Repository Web UI. This simple tool also enables you to generate a complete overview of all active service interfaces and their related repository object types, such as message types, data types, and external definitions. Furthermore, you can subscribe to specific object types and receive notifications when a change takes place (e.g., a deletion or other change). This functionality can be very useful for system administrators and managers responsible for a certain set of mission-critical interfaces. Figure 2.9 shows what the main page of the ES Repository Web UI looks like.

Figure 2.9    ES Repository Web UI
2.1.2    Integration Directory
So far, we've seen how the process of designing and creating integration building blocks takes place in different areas of SAP PO. This brings us now to another important process integration tool: the Integration Directory, in which everything comes together and new integration solutions are fabricated based on existing integration components available on the ES Repository and SLD. In the Integration Directory, the dots are connected, and the rules of engagement governing a particular integration scenario are set and activated to be executed at runtime. Here, we configure both application-to-application (A2A) and business-to-business (B2B) processes configuration scenarios. We'll discuss this in detail in Chapter 5.
The Integration Directory uses the Integration Builder as the Integrated Development Environment (IDE) to create and maintain configuration objects. We explain that subcomponent in the next section.
Integration Builder
The Integration Builder serves as the UI of the Integration Directory. In the Integration Builder (also known as just the Directory), configuration time is performed. You configure new configuration scenarios based on a combination of configuration objects and repository objects previously created at design time (see Figure 2.10). A configuration scenario consists of one or more integrated configurations (ICOs), each representing a message interaction between two or more systems.

Figure 2.10    Integration Builder
A graphical representation of the message interaction between the business systems is also provided as part of the configuration scenario (see Figure 2.11). Additional configuration objects that are also part of a configuration scenario include, for instance, content-based routing rules, communication channels, alert rules, value mapping groups, and parties. That last object represents an external business party and is mostly encountered only in B2B scenarios.
In addition to the Integration Builder, you can also use an application programming interface (API) to access, edit, and activate configuration objects. This approach is particularly interesting when performing and activating a large amount of changes in the Integration Directory or when embedding Integration Directory functionality into another application.

Figure 2.11    Configuration Scenario: Graphical Representation
SAP Cloud Platform Integration Content
SAP Cloud Platform Integration is a cloud based (iPass) system that facilitates the integration of business processes and data across on-premise and cloud applications (cloud to cloud and cloud to on-premise integration). Since the introduction of SAP PO 7.5, SAP PO is also equipped with an SAP Cloud Platform Integration runtime, which means that you can deploy, run, and manage the cloud integration content artifacts (e.g., Integration Flows [iFlows], value mappings, and security artifacts) in SAP PO. These new features can be accessed via the Cloud Integration Content Management Cockpit. The Cloud Integration Content Management Cockpit can be accessed through the Cloud Integration Content link on SAP PO's landing page as shown earlier in Figure 2.1. The Cloud Integration Content Management Cockpit can also be directly accessed via the http://<hostname>:<port>/IGWGBDeploy/Admin, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
As shown in Figure 2.12, from the Cloud Integration Content Management Cockpit, you can perform the following activities:


Deploy After downloading SAP Cloud Platform Integration content as a file on your local file system from SAP Cloud Platform Integration, this button can be used to upload and deploy the content on your SAP PO system.
                    

Undeploy Use this functionality to undeploy and remove previously deployed content from SAP PO. You first need to select the content.
                    

Refresh Use this to refresh the page and get an update of the status of each deployed integration content.
                    


Figure 2.12    Cloud Integration Content Management Cockpit
To learn more about SAP Cloud Platform Integration, please refer to the book SAP HANA Cloud Integration by Bilay, Gutsche, and Stiehl (SAP PRESS, 2016, www.sap-press.com/3979).

Note
After deploying the SAP Cloud Platform Integration content on SAP PO, the status of the deployed item is displayed in the Runtime Status column. Successful deployments are marked in green, whereas failed ones are in red. The root cause of the failed deployments can tracked via the Log Viewer in the SAP NetWeaver Administrator.

The deployed SAP Cloud Platform Integration content can also be monitored in the same way as SAP PO interfaces are monitored. To read more on the subject of monitoring SAP Cloud Platform Integration content, see Chapter 7, Section 7.2.3. It's important to note that to be able to deploy, view, and use the Cloud Integration Content Management Cockpit, the roles presented in Table 2.2 needs to be added to the user.




                                Roles
                            

                                Description
                            





                                SAP_XI_ADMINISTRATOR
                            

                                Provides display and modify authorization to view and deploy security artifacts in the Cloud Integration Content Management Cockpit
                            



                                SAP_XI_CONFIGURATOR
                            

                                Provides display and modify authorization to view and deploy cloud integration content in the Cloud Integration Content Management Cockpit
                            



                                NWA_SUPERADMIN
                            

                                Provides display and modify authorization to view and import trust certificates in SAP NetWeaver Administrator
                            



                                NWA_READONLY
                            

                                Provides display authorization to view monitoring data in SAP NetWeaver Administrator
                            



Table 2.2    Roles Required to Access the Cloud Integration Content Management Cockpit
More details about the SAP Cloud Platform Integration content are provided in Chapter 17.
2.1.3    System Landscape Directory
The System Landscape Directory is a central information hub supplying the entire SAP NetWeaver ecosystem with system landscape information about its operating environment. Such an environment includes not only other SAP NetWeaver components (such as SAP Composition Environment and SAP Solution Manager) but also SAP backend systems. The SLD contains relevant information about installed software components (SCs) and their versions on the entire SAP landscape, the business systems running that software, and the underlying technical infrastructure supporting those business systems. The SLD supports different types of SAP systems, but in SAP landscapes, the most common are SAP NetWeaver Application Server for ABAP (SAP NetWeaver AS ABAP) and SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java). These types of SAP systems will automatically register with the SLD and send regular updates (via SLD bridge) about their versions and the installed products and SCs they support. Note that previous configuration is needed on the application system (SAP NetWeaver AS ABAP or SAP NetWeaver AS Java) to connect and update the SLD. Configuring the SLD bridge between application systems and the SLD is normally a task for SAP Basis.
SAP's standard recommendation is to use one SLD instance, but in complex and/or highly distributed SAP landscapes, you might have more than one SLD instance available. In such a case, you must take either automatic replication of metadata or transporting SLD objects over different SLDs into consideration. Both approaches will help you maintain your SLD metadata consistently and keep it updated across the landscape.
To access the SLD (see Figure 2.13), go to http://<hostname>:<port>/sld, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.

Figure 2.13    System Landscape Directory
The SLD functionality spans three main functional areas: landscape, software catalog, and development. These areas are described in the next sections.
Landscape
The landscape area of the SLD deals with the creation and maintenance of technical and business systems installed in your system landscape. Technical systems are application systems installed and registered in your system landscape. Typical examples of technical systems include SAP Enterprise Central Component (SAP ECC) and SAP PI. As mentioned previously, they can be of different types, but the most important ones (and relevant for SAP PO) are SAP NetWeaver AS ABAP, SAP NetWeaver AS Java, SAP PI, and third party. A technical system can have one or more business systems assigned to it. For instance, a technical system representing a particular SAP system might contain multiple business systems for each client of that SAP system (see Figure 2.14).

Figure 2.14    System Landscape Directory: Technical Systems
Within the SLD, you can group different types of technical systems in landscapes and sublandscapes based on their logical or technical relationships, which are defined by an SLD administrator. You can create different types of landscapes for different purposes (e.g., administration, general, SAP NetWeaver development infrastructure [often referred to as NWDI] systems, scenarios, transports, and web services).
Business systems, on the other hand are logical systems that can act as senders or receivers within an integration scenario in SAP PO. Business systems are always linked to a technical system in the SLD and can be of the SAP NetWeaver AS ABAP, SAP NetWeaver AS Java, or third-party system types. Business systems are grouped in SLD business system groups and transport targets to facilitate the transport (e.g., from development to test) of integration scenarios created in the Integration Directory.
Software Catalog
The SLD has a software catalog of all available SAP products and SCs in your system landscape. That software catalog includes information (metadata) about support packages and dependencies between the products and SCs.
A product within the context of the SLD is a logical unit that corresponds to a collection of product versions, each with one or more SCs. In an SAP environment, a product represents an SAP technical component. Before you can start developing any integration solution in SAP PO, you first need to create a product and at least one associated SWCV in the SLD.
A SC is a logical unit representing a collection of SWCVs, each with one or more SC units. A software unit supports a specific functionality of a product and SWCV; it also embodies the logical link between the product and SWCV (see Figure 2.15).

Figure 2.15    System Landscape Directory: Products and Software Components
Development
To avoid naming conflicts between SCs, the SLD also provides a name reservation service (also known as a name server), which allows you to reserve names that are guaranteed to be unique. In this section, we discuss name reservations and Common Information Model (CIM) instances and classes.
The SLD offers a tool for managing namespace prefix reservations for both SAP and your own custom SAP NetWeaver software developments. Namespace prefix reservations can be made via the SAP Service Marketplace. Namespaces are unique identifiers for XML structures and particularly useful when working with external parties (i.e., in B2B integration scenarios).
You can manage all CIM instances and classes known in your SLD environment. CIM is a standard of the Distributed Management Task Force (DMTF) and is based on the object-oriented modeling approach. The SLD is currently based on CIM 2.9. You can read more about CIM and DMTF at www.dmtf.org.
2.1.4    Configuration and Monitoring
Prior to the latest releases of SAP PI and the introduction of SAP PO, most SAP PI system monitoring and administrative tasks were performed from either the ABAP stack (Transactions SXMB_MONI and SXMB_ADM) or via the Runtime Workbench (RWB).
The Monitoring Home screen (also known as "pimon") is a new place in which you can monitor and manage different areas of your local AEX. It comes packed with different kinds of monitoring and administrative functions that ease the access to different administrative areas of SAP PO (see Figure 2.16).

Figure 2.16    Monitoring Home Screen for Your Local AEX (pimon)
To access the Monitoring Home screen, simply click on the Configuration and Monitoring Home link from the Process Integration Tools home page, or go directly to http://<hostname>:<port>/pimon, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.

Note
For SAP PI dual-stack systems, the traditional monitoring and administration methods still can be used (i.e., RWB and ABAP stack Transactions SXMB_MONI and SXMB_ADMIN).

Two new features are also provided as part of the configuration and administration tools that deserve additional attention: the Migration tool and the integration visibility configuration.
Migration Tool
The Migration tool supports the migration and mass change functions for process integration scenarios and channels using directory content from your SAP PI landscape. It's extremely interesting, especially if you're planning to migrate your current integration scenarios from a dual-stack SAP PI to a new, Java-only SAP PO environment. You can run the tool, select the directory source objects you want to migrate, and obtain an overview of which objects can be migrated without changing them and which might require additional changes. You also can perform mass changes on communication channels between systems or rename multiple directory objects at once. The tool currently supports the following source systems: XI 3.0 and XI 7.0 or higher.
Integration Visibility Configuration
This tool facilitates the discovery of message flows and provisioning of events to subscribed applications (e.g., SAP Solution Manager or SAP Operational Process Intelligence) interested in consuming technical or business events for process integration visibility. It allows you to configure and schedule the way events are detected and propagated to the subscribed applications. Depending on the functional and technical requirements, it could be positioned as a way of feeding third-party applications that support Business Activity Monitoring (BAM).









2.2    SAP NetWeaver Administrator
For those of you who are familiar with the older versions of SAP PI, you'll remember the pains of jumping back and forth between the different administrative and monitoring tools. These included a mixture of web-based, command-line, and desktop clients. It was time to consolidate the handling of these different tasks and to bring some simplicity and consistency to the table.
SAP NetWeaver Administrator provides a consolidated one-stop shop from which you can perform administrative, monitoring, and troubleshooting tasks. It's a web-based tool that is easy to access and use. SAP NetWeaver Administrator is your entry point to SAP PO's administration environment and serves as a central tool containing a multitude of applications (grouped into work centers) to facilitate the execution of administrative and operative tasks of your SAP PO installation. It's also used by other SAP NetWeaver components and can accommodate users of different expertise. Depending on the user's role, only certain sections of SAP NetWeaver Administrator can be accessed. This ensures that only experts or authorized personnel can perform specific activities.
To access SAP NetWeaver Administrator (see Figure 2.17), go to http://<hostname>:<port>/nwa, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.

Figure 2.17    SAP NetWeaver Administrator

Tips
You can directly access the SAP NetWeaver Administrator section that focuses on SAP PI functionalities and includes all the monitoring tools via http://<hostname>:<port>/nwapi. This way of accessing SAP NetWeaver Administrator is also referred to as the central mode.

Given the many applications and tools hosted on top of the SAP NetWeaver Administrator, finding the right application can be a challenge. To simplify finding these applications, use one of the following methods:


Quick link or shortcut page The quick link or shortcut page can be accessed via http://<hostname>:<port>/nwa/quicklinks, where the <hostname> and <port> are the hostname and port number, respectively, of the SAP NetWeaver installation.
            

Search functionality If you know the name of the tool that you need, you can use the Search box on the top-right side of your screen (see Figure 2.18).
            


Figure 2.18    SAP NetWeaver Administrator Search Area


Browsing the different work centers The administrative functions included in the SAP NetWeaver Administrator are grouped into work centers according to the types of functionality areas they cover. Work centers are divided into work sets, which group related administration areas. SAP NetWeaver Administrator contains the following work centers:
                

                        Availability and Performance
                    

                        Operations
                    

                        Configuration
                    

                        Troubleshooting
                    

                        SOA
                    



Each of these work center categories will be described in the next sections.
2.2.1    Availability and Performance
As part of the availability and performance features, the Availability and Performance work center tab covers the following functionalities:


System Overview Provides an overall status of the performance and availability of different components of the SAP NetWeaver AS Java (see Figure 2.19).
                    
Figure 2.19    SAP NetWeaver Administrator: System Overview


Resource Monitoring Provides monitoring functionalities for the usage of the system resources. This monitoring includes SAP Java Connector (SAP JCo) monitoring, distributed transactions, session management, locks, system performance statistics, and history reports.
                

Process Monitoring Provides an overview of all messages going through the Advanced Adapter Engine (AAE). A detailed and aggregated view of the status of messages is also presented.
                



BPM System Overview Provides an overview of the business process management (BPM) system status, including information such as the following:
                    

                            Process server availability and status
                        

                            Process instance memory threshold
                        

                            An overview of process instances and their statuses
                        

                            An overview of tasks and their statuses
                        



2.2.2    Operations
The Operations work center screen contains relevant tools and applications (see Figure 2.20) to support the day-to-day administration activities required to maintain your SAP PO running interfaces, processes, and SAP NetWeaver AS Java server. The following working areas are covered by the Operations work center:


Systems Provides basic management functionalities for the installed applications and their statuses. You can also stop or start all available applications.
                

Data and Databases Manages all archiving-related activities.
                

Jobs Facilitates the management of scheduled jobs using the Java Scheduler.
                

Processes and Tasks Centrally manage and monitor BPM processes and tasks. It's possible here to view process details, instance flow, definition flow, and running history.
                


Figure 2.20    SAP NetWeaver Administration: Operations Work Center
2.2.3    Configuration
The Configuration work center screen (see Figure 2.21) includes functionalities that can be categorized as follows:


Security Covers all security aspects of SAP NetWeaver AS Java, including SSO, identity management, certificates, and connection destinations.
                

Infrastructure Contains a large number of services and features to support the management of SAP NetWeaver development infrastructure. These features are commonly used during development and troubleshooting activities. They include Java system properties, development infrastructure, log configuration, and system information.
                

Scenarios Facilitates the installation of additional components during the initial setup of the SAP NetWeaver system.
                

Processes and Tasks Enables the viewing of all deployed BPM components and their deployment details (versions, deployment dates, etc.) and also enables starting a BPM process.
                

Connectivity Provides the functionality to create connection destinations and JCo Remote Function Call (RFC) providers between ABAP and Java requests.
                


Figure 2.21    SAP NetWeaver Administrator: Configuration Work Center
2.2.4    Troubleshooting
The Troubleshooting work center screen delivers numerous debugging and monitoring applications (see Figure 2.22) capable of providing support for troubleshooting your integration and BPM applications running on your SAP NetWeaver AS Java.

Figure 2.22    SAP NetWeaver Administrator: Troubleshooting Work Center
The Troubleshooting work center also includes an extensive Log Viewer tool that enables log, trace, and application dump analysis features for troubleshooting SAP PO. See Figure 2.23 for a closer look at the Log Viewer inside this work center.

Figure 2.23    SAP NetWeaver Administrator: Log Viewer
2.2.5    SOA
The SOA work center screen comes loaded with a broad set of configuration tools (see Figure 2.24) that mainly specialize in enabling the provision and consumption of web services. The monitoring area within the SOA work center also groups different types of monitoring tools (Message Monitor, IDoc Adapter Monitor, Performance Monitor, etc.) to help you find the correct tool from the same place.
In this work center, you define and manage different communication and technical configuration used by SAP PO main components (i.e., SAP PI, SAP BPM, and SAP Business Rules Management [SAP BRM]). Make sure you get familiar with its tools and functions because you'll use it often, in particular when developing and configuring SAP BPM solutions to configure service groups and communication components.

Figure 2.24    SAP NetWeaver Administrator: SOA Work Center
The SOA work center functions are categorized as follows:


Technical Configuration Maintain and configure destinations to other (external) services and components used by SAP PO, including logon credentials, and so on.
                

Application and Scenario Communication Provides functions for administration and configuration of web services, service groups (very critical for BPM applications), and the communication configuration of entire business scenarios. From here, you can also define Service Registry publication rules applicable for specific services or service groups.
                

Log and Traces Provides similar functionality to that of the Troubleshooting work center, but specifically for controlling and debugging message traffic connectivity. From here, you can configure, search, and analyze logs and traces of deployed web services and RFCs in SAP PO.
                

Monitoring  An extensive collection of monitoring tools covers almost every corner of SAP PO, including IDoc adapter monitoring, proxy runtime monitoring, cache monitoring, and so on. From this area, you configure user-defined message search and message alert. Background jobs and component monitoring is also available. Message retention periods can also be configured from this area.
                










2.3    SAP NetWeaver Developer Studio
SAP NetWeaver Developer Studio is based on Eclipse, an open-source integrated development environment (IDE). The Eclipse platform has been around for more than a decade and has been adopted by most major software vendors with focus on Java development and related technologies. Eclipse offers a generic workspace approach that can be used to work on different development projects, each customized for different software development if necessary, including Java, C++, JavaScript, and so on. SAP NetWeaver Developer Studio has a flexible plugin framework that enables new functionality and extensions by allowing the installation of plugins for different purposes and technologies. After you've downloaded and installed a new plugin in SAP NetWeaver Developer Studio, a new set of perspectives and views become available, which you can then use to design, build, or test new SAP NetWeaver applications.
2.3.1    Use and Download
Within the context of SAP PO, you use SAP NetWeaver Developer Studio in two ways:


                    To create integration content (e.g., Integration Flows [iFlows])
                

                    To model and configure business process management (BPM) and business rules management (BRM) solutions
                

When you download and install SAP NetWeaver Developer Studio, it comes prepackaged with the necessary SAP PO plugin and perspectives to start developing process integration and orchestration solutions.

iFlows
iFlows are graphical representations of an integration configuration made in SAP NetWeaver Developer Studio. They are based on Business Process Model and Notation (BPMN), which is also the standard used for modeling business processes in SAP BPM as part of SAP PO. iFlows offer a simple yet effective way of modeling end-to-end integration scenarios all together in a single graphical tool.

You can download the latest version of SAP NetWeaver Developer Studio at http://service.sap.com/swdc (please note that SAP might change this link without notice; in that case, visit the SAP Community website or the SAP Service Marketplace). You'll also need an SAP user/customer/partner account to download the files.

Tip
You should confirm the version of your SAP PO server with your SAP Basis team before downloading SAP NetWeaver Developer Studio. To avoid version conflicts, the versions of your server and SAP NetWeaver Developer Studio should always match.

Note that since SAP NetWeaver 7.5, SAP NetWeaver Developer Studio now supports the Eclipse 4.4 (Luna) version. As a result, it's now possible to run many SAP plugins in the same Eclipse instance, including SAP PO and other SAP development tools such as SAP Cloud Platform Integration tools, SAP HANA tools, SAP Cloud Platform tools, and so on.
2.3.2    SAP Process Orchestration and SAP NetWeaver Developer Studio
Now, we'll discuss how SAP PO works in SAP NetWeaver Developer Studio. The first time you start SAP NetWeaver Developer Studio (see Figure 2.25), a welcome page will show the main areas of the tool and provide links to follow tutorials or browse through some samples and documentation. You'll notice that there are also other SAP NetWeaver development areas (i.e., Visual Composer, Java Web Dynpro, and SAP Composite Application Framework [SAP CAF]) presented on the welcome page; you're free to explore them, or you can just ignore them for now.

Figure 2.25    SAP NetWeaver Development Studio: Welcome Page
When you click on Workbench, you can then proceed with the first steps, which involve configuring connections to your SAP PO environment, including SAP NetWeaver AS Java (i.e., where you deploy your software), ES Repository, SLD, and, optionally, the Services Registry. You can perform the configuration in different ways, but the easiest way is to go to the main menu, choose Windows • Preferences, and then search for "SAP NetWeaver AS Java" and "System Landscape Directory" to configure communication for those components, as shown in Figure 2.26.
When developing SAP PO integration content, you'll be working mainly with the following perspectives in SAP NetWeaver Developer Studio:


                    Design Time Repository
                

                    Development Infrastructure
                

                    Process Development
                

                    Process Modeling
                

                    Rules Composer (for building business rules)
                

                    SAP Process Integration Administration
                

                    SAP Process Integration Designer
                

                    SAP Process Integration Runtime
                    
Figure 2.26    Configuration of SAP NetWeaver AS Java in SAP NetWeaver Developer Studio


If you're developing an application that also contains GUI components such as forms, dashboards, or other type of views, then you'll have to choose the relevant perspective (e.g., Web Dynpro, Visual Composer, etc.) for that technology in SAP NetWeaver Developer Studio.
To open a perspective in SAP NetWeaver Developer Studio, choose Window • Open Perspective • Other from the main menu, and then select the correct perspective (Figure 2.27).

Figure 2.27    SAP PO Perspectives in SAP NetWeaver Developer Studio









2.4    Summary
In this chapter, we took a look inside SAP PO and discussed the different components and development and administrative tools that SAP PO is composed of. We discussed the main differences between older versions of the SAP PI administration tooling and the new generation of administration tools offered by SAP PO. We also covered new features and efficient ways of performing administrative and monitoring tasks using tools such as SAP NetWeaver Administration and SAP NetWeaver Developer Studio.
You should now feel comfortable talking about these areas and explaining their roles within SAP PO. In the next chapters of this book, we'll go into more detail regarding these components and give you practical tips about how to get the most out of them.








Part IIAdvanced Adapter Engine Extended (AEX)







3    Configuring the System Landscape DirectoryFinally we shall place the Sun himself at the center of the Universe.                                                                                         —Nicolaus CopernicusThe System Landscape Directory (SLD) plays a critical role in an SAP system landscape. As a central repository, it manages information about all installable and installed elements of your system landscape in your organization. The repository includes a list of SAP and non-SAP systems from a technical and business perspective, and the information available is used by other SAP applications, such as SAP Process Orchestration (SAP PO), SAP Solution Manager, SAP NetWeaver Administrator, and the SAP NetWeaver development infrastructure.The information contained in the SLD also includes which products and software component versions (SWCVs) are installed in a particular application or system. You can make systems that participate in the landscape automatically register themselves and update the SLD with recent information as they become available. As time goes by, the initially installed SLD content becomes outdated and will need to be updated with a more recent version. The most up-to-date SLD content can be found on the SAP Service Marketplace.You can access the SLD via http://<hostname>:<port>/sld, where <hostname> is the hostname of the SAP NetWeaver system and <port> is the port number of the SAP NetWeaver system. The SLD is a Java-based component that can be installed on an SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java). The SLD is included in the SAP_JTECHT software component (SC) delivered by SAP.A newly installed SLD comes prepopulated by default with some initial data provided by SAP, including a catalog of all possible installable SAP products, SCs, and details about support packages. You can use this default data and these SCs as dependencies for your own custom content.In this chapter, we'll explain the SLD's roles within the context of SAP integration. We'll discuss the SLD components and explain their functionalities. This chapter also includes an exercise, which serves as an implementation example.
3.1    System Landscape Directory Components and Features
To fulfill its role of central information repository for the entire system landscape, the SLD facilitates easy access to the information of different systems and software. In the System Landscape Directory landing page (see Figure 3.1), the information is categorized in the following sections or categories:


Landscape


Software Catalog


Development



Figure 3.1    System Landscape Directory Landing Page
In the next sections, we'll explore each of these categories in more detail.
3.1.1    Landscape
The Landscape category includes functionalities covering the maintenance of technical systems, landscapes, and business systems.
Technical Systems
Technical systems are SAP and non-SAP backend applications in your landscape. Any SAP components (SAP ERP Human Capital Management [SAP ERP HCM], SAP Customer Relationship Management [SAP CRM], etc.), SAP NetWeaver applications, third-party applications, or legacy systems in your landscape can be considered technical systems to be maintained in your SLD. If an application registers itself with the SLD (as discussed in Section 3.2), then a technical system will be created in the SLD to represent it.
Assume that an SAP CRM system has a system ID of ECD. In that case, a technical system with the name ECD will be created in the SLD. As demonstrated in Figure 3.2, a lot of information about the ECD system is maintained in the SLD. Some of this information includes the following:


                        System name
                    

                        Hostname of the server
                    

                        Version number of the system
                    

                        Type of system
                    

                        When the data was last updated
                    

                        Details about the database (see the Database tab)
                    

                        List of existing clients (see the Clients tab)
                    

                        Details of the message server of the application
                    


Figure 3.2    A Technical System in the SLD and Various Tabs Containing Its Data
If a system wasn't automatically registered in the SLD (especially in the case of a third-party system), then you can manually create a new technical system. To do so, click the New Technical System button (as shown in Figure 3.2) and follow the wizard. You'll be required to specify the type of technical system to be created. The possible choices include the following:


SAP NetWeaver AS ABAP Systems with an SAP NetWeaver AS ABAP. Most SAP backend systems will fit into this category.
                    

SAP NetWeaver AS Java Systems with SAP NetWeaver AS Java. Such a system can consist of one or multiple instances.
                    

Standalone Standalone Java applications.
                    

Third-party Systems containing third-party (non-SAP) applications and products.
                    

Landscapes
Landscapes provide the facility to group systems in a logical manner. A landscape can be seen as a development environment that includes a number of servers and applications intended for a specific stage in a release process.
For each landscape, you can create a group in the SLD and include all applications and systems belonging to that stage. To create a new landscape for the development stage, follow these steps:


                        Choose Landscape from the System Landscape Directory landing page.
                    

                        Click on New Landscape to define a new landscape.
                    

                        Add all the relevant systems belonging to this stage (see Figure 3.3).
                        
Figure 3.3    Adding Different Systems to a Landscape


You can add systems to a particular landscape by performing the following steps:


                        Select the desired landscape.
                    

                        Click the Systems tab.
                    

                        Click the Add System button.
                    

                        Choose the type of system from the Type dropdown.
                    

                        Select the desired system, and click OK.
                    

Business Systems
A business system is a logical name given to a particular system or application. In general, the business system name is unique in the landscape and is used in an SAP PO scenario to represent the system or application as a sender or receiver. There is a direct relationship between a business system and a technical system. Every technical system can have at least one business system. For an SAP ABAP backend system, every client can have its own business system. This is only relevant for SAP NetWeaver AS ABAP systems because SAP NetWeaver AS Java-based systems aren't partitioned in clients.

Figure 3.4    Relationship among Business Systems, Technical Systems, and Software Components
Figure 3.4 depicts a situation with a technical system called TS_A that has two clients (100 and 200). Each client is linked to a different business system—namely, BS_A and BS_B.

Note
The backend systems (ABAP) regularly retrieve their business system names from the SLD. If the SLD becomes unavailable, then the SAP backend system won't be able to update its current business system name and might be using an outdated business system name that it keeps in its cache.

You can perform all management tasks from the SLD: create, update, delete, and search or filter on business systems. Compared to technical systems (which are created automatically when the application systems register themselves to the SLD), the business systems need to be manually created. To create a business system, follow these steps:


                        From the System Landscape Directory landing page, choose Business Systems • New Business System to start the wizard.
                    

                        Select the type of technical system that the new business system will be linked with.
                    

                        In the next step of the wizard, you'll be asked to choose the related technical system and client (for the ABAP system).
                    

                        Give your business system a logical name.
                    

                        Choose the products and SCs that are installed in your business systems.
                    

                        Select the role of your business system. The following options are available:
                        

Application System This option will be used most of the time and is relevant whenever the business system to be added represents a backend application or system, in which case, it's required to specify its related integration server. The related integration server represents the SAP Process Integration (SAP PI)/SAP PO system that will act as the enterprise service bus (ESB) for the business system in question (see Figure 3.5).
                            

Integration Server This is relevant in cases in which the system in question is middleware: an SAP PI or SAP PO system.
                            




Figure 3.5    Specifying a Business System's Role While Creating a New Business System
A business system can be described by a number of attributes. After selecting a particular business system from the SLD, a few tabs are presented: General, Integration, Transport, and Installed Software (see Figure 3.6).

Figure 3.6    Business System: Integration Details
When dealing with business systems, it's very useful to understand the concept of business system groups, which represent a grouping of business systems that belong to the same environment, thus effectively dividing your landscape into different controllable parts. Most organizations have the following four environments in their landscapes:


                        Development
                    

                        Test
                    

                        Acceptance
                    

                        Production
                    

In most organizations, systems belonging to the same group will often be named in similar ways. Of course, this depends very much on the organization's naming conventions. For example, all systems of the development environment might have the format SYSTEMNAME_D, where D represents "development," and all test systems might have the suffix _T. In this way, it's easy visually to identify the environment that the system belongs to based on its name.
It's common to have a group of business systems defined in the SLD for each one of the environments or stages of your landscape. SLD groups play an important role in managing transport targets. To manage groups, follow these steps:


                        From the System Landscape Directory landing page, select Business System.
                    

                        From the Groups dropdown, choose Edit Groups.
                    

                        Select New Group.
                    

                        Give the group a name, and select an integration server responsible for all integrations in this group (this is basically the SAP PO server for this group).
                    

You don't have to add a business system to the group; it's only required to link a group of business systems to an integration server. In addition, all the business systems linked to the same integration server automatically belong to the same group.
3.1.2    Software Catalog
The SLD is also equipped with a repository of SAP products and SCs (see Figure 3.7). This repository contains a catalog of SCs and their dependency relationships with each other. In the software catalog, you can differentiate products and SCs.

Figure 3.7    Relationships among Products and Software Components
In the next sections, we'll explore products and SCs in more detail.
Product
A product is an installable unit of software that includes a logical bundling or grouping of multiple SCs. A product is the highest object in the software catalog hierarchy. A product has a version.
As illustrated in Figure 3.7, the intention is to group SCs in a logical way together into the same product. Therefore, a product called "Banking" assumes a grouping of various SCs related to banking services. To create a new product, follow these steps:


                        From the System Landscape Directory landing page, select Products.
                    

                        Select New, and follow the wizard.
                    

                        You'll be prompted to create a SC as part of this wizard. Be aware that it's also possible to add more SCs later.
                    

Software Component
A software component (SC) is a reusable module of a product. It can be upgraded or patched for bugs. A SC is the foundation on top of which an integration developer will develop his interfaces and mappings.
SCs can be dependent on other SCs. The dependency encourages reusability and is also called usage dependency. Usage dependency is used to define a relationship toward other SCs and therefore reuse their functionality.
When setting up dependencies, it's possible to choose from among the following options:


InstallationTime With this dependency type, a particular SC needs another SC to be installed. This SC can't work without the dependencies being installed first.
                    

BuildTime This dependency type defines the dependencies that are required during compilation of sources and archives. The SC's sources need the resources of the SC that it depends on to be built and compiled.
                    

MetaDataRequest This dependency type is used when the metadata of another SC is required during the installation time.
                    

To create a new SC, follow these steps:


                        From the System Landscape Directory landing page, select Software Components.
                    

                        Select New, and follow the wizard.
                    

                        Select the product version and product instance that this new SC should belong to.
                    

                        Specify the SC name and version.
                    

                        Click Finish.
                    

                        After successfully creating a SC, you can create dependencies by clicking the Dependencies tab.
                    

                        From the Context dropdown, select the desired dependency type: BuildTime, InstallationTime, or MetaDataRequest (see Figure 3.8).
                    

                        Select the Define Prerequisite Software Component Versions option and the required SC.
                    


Figure 3.8    Adding Software Component Dependencies in the SLD
To properly manage the SCs in your landscape, you need to have a good approach for how to classify and organize them. This is also referred to as the SLD SC model. The SLD SC model helps you determine how many SCs should be used to represent a particular integration scenario. It's important to think about the component model or strategy to be used and to choose one that fits best in your situation. The SLD SC model will typically be part of your development standard.
In general, three SC model strategies are widely used (see Table 3.1 for more details).




                                Model Name
                            

                                Description
                            





                                One SC model (also referred to as the horizontal approach)
                            

                                In this approach, a single SC is created for all interfaces of the entire organization. Namespaces are then used to separate the different domains or groups of objects.
                                The obvious big disadvantage of this approach is that there is no reusable unit of software.
                            



                                Two SC model (also called the vertical approach)
                            

                                In this approach, two SCs are created: one encapsulating the sender and the other encapsulating the receiver. All objects and message structures belonging to the sender systems are placed in one SC. The same applies to the SC of the receiver system.
                                The question to be asked with this approach is where to place common or shared objects (e.g., mappings) to make the translation between the sender's message structure and the receiver's message structure.
                            



                                Three SC model


                                This approach uses three SCs: the first for the sender system, the second for the receiver system, and the third for all shared objects.
                                This means that objects such as mappings should be placed in the third software component. This model represents a clear separation between the different SCs and encourages reusability. This model is the most commonly used.
                            



Table 3.1    Software Component Models

Note
You can also come up with your own SC model and a strategy that will best suit your own needs.

3.1.3    Development
This section of the SLD contains tools designed to facilitate SAP NetWeaver development activities: name reservation and Common Information Model (CIM) instances and classes. We'll explore each of these tools and explain their roles.
Name Reservation
All organizations should have a naming convention. In addition to all the benefits stated in the previous section, a good naming convention allows the developers to create unique development objects and avoid name clashes and confusion between different objects. This is especially relevant when different developers and teams are working on the same project. In a typical project, not everyone is allowed to define the name of the development component (DC) as they wish. These names are predefined by an administrator, and the developers only need to use them. This approach introduces a high level of control and avoids inconsistent definition of DC names.
Name reservation (or the name server) enables the Java development team to define and reserve some names globally throughout the entire landscape. This guarantees the uniqueness of the reserved name. It's also possible to use the namespace concept to reserve a unique name in the name server.
A namespace always starts with a namespace prefix. Namespace prefixes defined in a name reservation can later be used in the SAP NetWeaver development infrastructure. You should use your Internet domain names in the namespace definitions to make sure they are globally unique.
It's important to note that the SLD isn't automatically activated as the name server for your SAP NetWeaver development infrastructure developments. You can activate the name server role in the SLD used by SAP NetWeaver development infrastructure by following these steps:


                        From the System Landscape Directory landing page, click on Name Reservation.
                    

                        Choose Enable This SLD as Name Server for NWDI.
                    

After the name server has been activated for the SAP NetWeaver development infrastructure development, you can create prefixes in advance. To add a new prefix, follow these steps:


                        From the System Landscape Directory landing page, click on Name Reservation.
                    

                        Make sure you're in the Name Prefixes tab.
                    

                        Click the New Name Prefix button. You'll see the screen shown in Figure 3.9.
                    

                        Choose the desired Name Category. Because this is for an SAP PO development, choose either Development Component Name or Software Component Name. What you choose depends on whether you want to reserve names for a SC or a DC. The concept of DCs is relevant for Java development and will be explored in Chapter 16.
                        
Figure 3.9    Adding a New Name Prefix in the SLD Name Reservation


                        Specify the name prefix. You can specify a name up to 256 characters long. In our example, we used the name com.rojoconsultancy.finance. As you can see, this name contains an Internet domain name and department. In this way, you can categorize your namespaces.
                    

                        To complete the task, click Define.
                    

Now that you've reserved a name prefix, you can predefine some DCs in the name server and make use of the previously reserved name prefix. To define a name (for a DC or SC), follow these steps:


                        From the System Landscape Directory landing page, click on Name Reservation.
                    

                        Make sure to be in the Names tab.
                    

                        Click the New Name button. You'll see the screen shown in Figure 3.10.
                    

                        Select the desired Name Prefix. In this case, the previously created com.rojoconsultancy.finance is selected.
                    

                        Specify the name of the DC by adding a name after the "/" character.
                    

                        Specify the Caption (a short description) for the DC name.
                    

                        Click Reserve.
                    


Figure 3.10    Adding a Name in the SLD Name Server
Now, we're ready to use this DC name during development in the SAP NetWeaver development infrastructure.
Common Information Model Instances and Classes
The Common Information Model (CIM) is a standard based on an object-oriented modeling approach. The standard is championed by the Distributed Management Task Force (DMTF). CIM is used to model hardware and software objects and elements. SAP uses the CIM to capture key properties to identify and to specify a product. It contains metadata information such as the name, vendor, description, and caption of a product. The CIM class and CIM instance are two key concepts of the CIM.
A CIM class represents a group of artifacts and objects with similar properties. A CIM class can be associated with one or more other CIM classes. For more information on the CIM standard, visit www.dmtf.org.
For the purpose of SAP PO, the CIM is used to hold the description of components, products, and the system landscape. To view and maintain the CIM Instance and classes in your SLD, select the CIM Instance and Classes link from the System Landscape Directory landing page.
You can update existing descriptions or CIM content in your SLD by using the import functionality. See Section 3.3 to learn more about how to update your existing CIM.









3.2    Registering Systems to the System Landscape Directory
As the previous section explained, it's important to make all participating systems in your SAP landscape register themselves and report to the SLD. To register your system, you need to create a connection between these systems and the SLD. These connections can be achieved using Remote Function Calls (RFCs) or HTTP and are commonly referred to as data suppliers. Data suppliers collect a range of data from SAP systems, including the following:


                Application servers and instances
            

                RFC gateways
            

                SAP products
            

                Installed software components
            

                Installed support packages
            

                Compound systems
            

                HTTP ports
            

                Network services
            

                liveCaches
            

                SAP message servers
            

                RFC destinations
            

                Hosts
            

                Clients
            

                Databases
            

                CIM associations between generated objects
            

The collected data is periodically sent to the SLD using CIM over HTTP.
3.2.1    Connecting to ABAP-Based Systems
For ABAP-based systems (from SAP Basis release 6.4.0 and up), it's possible to use data suppliers to send the data to the SLD bridge via an RFC connection and SAP Gateway (as depicted in Figure 3.11). In an ABAP-based system, the data supplier uses data collection programs to collect the needed data. For SAP NetWeaver AS ABAP systems, you can modify data collection programs to change their behavior.

Figure 3.11    Connecting an ABAP System to the SLD

Tip
For an ABAP-based system on SAP Basis release 4.0B and up, use Transaction RZ70 to set up SLD data suppliers.
For SAP systems running on an SAP NetWeaver AS ABAP older than 6.40, you can't configure data suppliers using Transaction RZ70. This configuration will need to be manually performed for such systems.

3.2.2    Connecting to Java-Based Systems
For Java-based systems, configuration of data suppliers is automatically performed during the installation of the system (see Figure 3.12). You can manually change it afterward using SAP NetWeaver Administrator.
To change the data supplier in a Java-based system, follow these steps:


                    Go to the SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.
                

                    Navigate to Configuration • Security • Destinations.
                

                    Change or create a destination with the name "SLD_DataSupplier" and of type HTTP.
                

                    You can now enter or change the details in the URL field to point to the SLD system. Don't forget to enter the login details under the Logon Data tab.
                

                    Test your destination by using the Ping Destination button.
                


Figure 3.12    Connecting an SAP NetWeaver AS Java System to the SLD
You also have the option to force an SAP NetWeaver AS Java system to collect and send the data to the SLD server at any given time by performing the following steps:


                    Go to the SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.
                

                    Navigate to Configuration • Infrastructure • SLD Data Supplier Configuration.
                

                    Click on the Collect and Send Data button (see Figure 3.13).
                


Figure 3.13    Forcing an SAP NetWeaver AS Java System to Push Data to the SLD
3.2.3    Connecting to Other Systems
Systems other than ABAP or those based on SAP NetWeaver AS Java can also be connected to the SLD and can send their data using an executable program called sldreg. See Table 3.2 for a summary of the approaches to follow to connect a given application system to the SLD, depending on its type and version.




                            System type
                        

                            Approach
                        





                            SAP system with SAP NetWeaver AS ABAP older than 6.40
                        

                            Manually update SLD data.
                        



                            SAP System with SAP NetWeaver AS ABAP equal to or greater than 6.40
                        

                            Configure data suppliers to automatically update SLD using Transaction RZ70.
                        



                            SAP system with SAP NetWeaver AS Java older than 7.1
                        

                            Configure via the Visual Administrator tool.
                        



                            SAP system with SAP NetWeaver AS Java equal to or greater than 7.1
                        

                            Configure via the SAP NetWeaver Administrator tool.
                        



                            Standalone and third party
                        

                            Manually update SLD data.
                        



Table 3.2    Overview of Approaches to Connect a System to the SLD
The next section discusses the components and available features of the SLD.









3.3    Administration of the System Landscape Directory
In this section, we'll explore some administrative functionalities of the SLD, focusing on those functionalities that are commonly used and relevant to an SAP PO installation. The main page used for the administration of your SLD can be reached by clicking on the Administration menu link from the System Landscape Directory landing page. From this page, you can distinguish the server and content categories, which will be explored in this section.
3.3.1    Server
This category contains applications that expose different aspects of the SLD server. We'll explore each application.
Status of the System Landscape Directory
To view the current status of the SLD, whether it's currently running or not, check the traffic light on the top left of the SLD Administration screen (see Figure 3.14).

Figure 3.14    SLD Administration Screen
Like any conventional traffic light, a green light will mean that your SLD is up and kicking, whereas a red light will indicate that it's down and might require manual action.
Stop or Start the System Landscape Directory
You can temporarily stop or start the SLD using either the Stop SLD or Start SLD button, located at the right side of the traffic light (refer to Figure 3.14).
Log
With this logging functionality, you can view the SLD server logs. From this page, for example, you could get more details about failing data imports or exports. It's also possible to set logging and tracing parameters here.
Details
From the Details page, it's possible to see all detailed information about your SLD server. As shown in Figure 3.15, the following details are displayed:


GeneralThis tab contains details of the SLD such as running statuses, versions, SAP Java Virtual Machine (SAP JVM) memory, JVM version, Java system properties, and so on.
                    

DataThis tab contains CIM-related totals and information such as counts of CIM classes, instances, and associations.
                    

Data SuppliersThis tab has details about the data supplier and which other SLDs are being updated by the local SLD. Figure 3.15 shows that the local SLD server is forwarding data to another (central) SLD.
                    

ServerThis tab has information such as CIM service version, utilization capacity, hit rate, and so on.
                    


Figure 3.15    SLD Administration Details Page and Available Information
3.3.2    Data and Content
Data and content can be added to the SLD via three different options: data import, system self-registration, and manual creation of data.
Import and Export
This functionality enables the import of the CIM and data from a local file. You can also export the CIM and data of the current SLD via the export functionality.
You can use the export function to perform a full backup of the current SLD data. It's also possible to perform an incremental export. Incremental exports only export the delta objects that were added to the SLD since the last time an export happened. As such, the incremental method of performing an export requires good administration.
Synchronization
If you have multiple SLDs, and you need to keep their content in sync, then you might opt to synchronize them or to transport the content between the different SLDs. It's then possible to choose between a fully automated synchronization and a manual synchronization. The synchronization of SLD content will be broadly explored in Section 3.4, when we discuss the different SLD strategies. During a typical synchronization, the data and content from one source SLD are propagated to another target SLD.









3.4    System Landscape Directory Strategies
Given the role played by the SLD, it's important to come up with a proper SLD strategy to be used in your organization. There are many approaches to run an SLD in your landscape. To start with, ask yourself if you need one or multiple SLDs in the landscape. To properly answer this question, you need to look at the organization's landscape and requirements. Consider the following questions:


                How big is the landscape, and how many systems will be using the SLD?
            

                How spread out are these systems? Are all the systems part of the same network, or are they spread across the globe?
            

                Do you want to keep the data of your different environments or stages separated?
            

Depending on your answers to these questions, you may want to consider multiple SLDs. Having more than one SLD can bring some advantages:


                Data views are separated (the administrator of each group can only see a limited view or subset of data).
            

                Your SLD data and content are highly available.
            

                Any changes to a local SLD's data will only impact a limited part of the organization. Because of the separation of SLDs, it becomes possible to choose the right time to reflect the changes in the rest of the organization (e.g., after a successful test of the performed changes and after you feel comfortable reflecting the changes in the rest of the organization).
            

With more than one SLD instance in your landscape, the need arises to distribute the data between the different SLDs and to set up a synchronization mechanism between them. There are different approaches to synchronize data between the SLDs, including the following:


                Manual export and import of data (full or delta) using the enhanced Change and Transport System (CTS+)
            

                Automatic forwarding of data suppliers
            

                Full automatic synchronization
            

In the next sections, we'll explore each of these approaches.
3.4.1    Manual Export and Import of Data
If you facilitate the manual export of any selected data from your SLD, then the exported data can be manually imported into the next environment or local SLD. This approach has the major downside of requiring human manual action. It's better to couple this approach with a CTS+. To manually export an SLD object (using a business system here as an example), follow these steps:


                    From the System Landscape Directory landing page, select Business Systems.
                

                    Filter and select the business system that you would like to export.
                

                    With the business system selected, click on the Export button (see Figure 3.16 1).
                    
Figure 3.16    Steps to Manually Export an SLD to a Business System


                    Click on Download File from the Download tab 2, and save the resulting TPZ file on your local file system.
                

                    The saved TPZ file can then be imported into the target SLD system.
                

3.4.2    Automatic Bridge Forwarding
The automatic bridge forwarding approach copies all technical systems data in the source SLD and distributes them to the next SLD system. Most of the time, this approach is used to synchronize the central or master SLD with local SLDs. It's also referred to as one-way distribution or SLD bridge forwarding. This approach only forwards data that is received in the SLD via a data supplier. The manually entered data isn't propagated. To set up automatic bridge forwarding, follow these steps:


                    From the System Landscape Directory landing page, select Administration and Data Suppliers.
                

                    Under Update Other SLDs, click on the Add button (Figure 3.17 1).
                

                    Fill in the details of the target SLD system 2.
                


Figure 3.17    Steps to Set Up an SLD Automatic Bridge Forwarding
3.4.3    Full Automatic Synchronization
The automatic synchronization mechanism ensures that all data entered manually in the local SLD and updated by the data supplier is automatically replicated and pushed to the target SLDs. This is a favorable mechanism because it reduces the need to manually keep the SLDs in sync and therefore reduces the risk of human error. It's important to note that the automatic synchronization is supported as of SAP NetWeaver AS Java 7.1 SPS 1 and higher. A synchronization can be unidirectional or bidirectional:


Unidirectional Data from the source SLD is synchronized with the target system. This implies that all the data present in the source SLD is also present in the target SLD, but the target SLD might have more data.
                

Bidirectional In this situation, both SLDs are identical. The SLDs can be seen as each other's clones, in terms of their data. Bidirectional SLD synchronization can be used as a way to create an SLD backup or redundancy (see Figure 3.18).
                


Figure 3.18    Bidirectional Full Automatic Synchronization Example
The automatic synchronization uses HTTP and is asynchronous. To configure the full automatic synchronization of your SLD, follow these steps:


                    From the System Landscape Directory landing page, choose the Administration link on the top menu and then the Synchronization link in the resulting page.
                

                    You're then forwarded to a Maintain SLD Content Synchronization screen. Click the Add button (see Figure 3.19 1).
                

                    In the next screen, select the following values:
                    

                            For the Source, select the Remote (Sync with another SLD) radio button 2.
                        

                            Make sure the Bidirectional checkbox is selected.
                        



                    In the subsequent screen, maintain the hostname and logon details to be used to connect to the target SLD.
                


Figure 3.19    Steps to Configure the SLD Full Automatic Synchronization
After you've finished providing details in the second step of the wizard, follow these steps:


                    Define the source namespace and rank. The source namespace represents the namespace from the source SLD to be synchronized. By default, the sld/active namespace is selected. However, you can choose another namespace from the dropdown values. Follow the wizard's steps.
                    The rank helps resolve conflicts. The namespace rank number specifies the priorities of SLD data in the synchronization process. A higher rank number means that the data of the source SLD namespace will "win" in conflicts with data of the target SLD's namespace (see Figure 3.20 1).
                

                    Maintain the URL and login details of the local SLD. In addition, you need to choose the target namespace and its rank.
                

                    You'll be presented with a summary of all the values you entered. Click Finish after checking that the summary is correct.
                

                    You can now check the status of the full sync by selecting the Full Sync (Active) link. You can also force a full sync by clicking on the Full Sync button 2.
                


Figure 3.20    Configuring the SLD Full Automatic Synchronization: Defining Ranks









3.5    Tips and Tricks
In this section, we'll share some tips and step-by-step guides to perform some administrative tasks in the SLD.
3.5.1    Naming Convention
Consider using a convenient naming convention when naming your SLD objects. A good naming convention has numerous advantages, including the following:


Creates order When the objects are named in a logical manner, their purposes will be obvious to every developer. When looking at the name of an object, it should be obvious which type of SLD object you're looking at, and you should have an idea of what role it plays in the landscape.
                

Creates a recognizable structure A good naming convention makes life easier for the developers and people taking care of the operational side of the SLD, especially when you're dealing with a complex landscape and a growing number of systems and interfaces.
                

Increases productivity When the naming convention is simple and logical, it becomes easier to group, sort, find, and search objects, which will help speed up and simplify the development process. This in turn will result in an easy adoption of the naming convention and increased productivity.
                

Having a naming convention alone won't cut it. It's important to encourage everyone to make a good habit of using the naming convention and to facilitate its adoption. Furthermore, someone needs to be responsible for enforcing the naming convention.
3.5.2    Keeping Your System Landscape Directory Catalogs Up to Date
It's strongly advised to always keep the SAP-provided catalogs of content up to date. You can update the SLD catalog content by following these steps:


                    Download SAP content from the SAP Service Marketplace via http://service.sap.com/swdc.
                

                    Navigate to SAP Software Distribution Center • Download • Support Packages and Patches • Entry by Application Group • SAP Technology Components • SAP CR Content. You can then download the relevant content (provided as ZIP files) and place it into a local file system. Be aware that you don't need to download the entire software catalog. Each package is a delta of the previous version, so you can download all the packages subsequent to your current version and import them in order.
                

                    Import the files into the SLD. From the System Landscape Directory landing page, go to Administration • Import (under Content).
                

                    Select the ZIP file via the Browse button.
                

                    Click the Import button. Depending on the size of the file to be imported, you can expect this update process to run for a while (see Figure 3.21).
                


Note
If you need to import multiple CIM files, make sure that you import them in the right order and sequence because each package is a delta of the previous version.


Figure 3.21    Import a New SLD CIM or Data
Figure 3.21 shows the CIM and data import functionality. On this screen, you can also see the version of the content currently loaded in the SLD. For obvious reasons, it's important to verify the current CIM version to determine the version to be imported.
3.5.3    Self-Registration of a Java-Based System with the SLD
To let an SAP NetWeaver AS Java-based system register its technical system with the SLD, you need to configure its data supplier. To configure data suppliers of the SAP NetWeaver AS Java-based system, perform the following tasks:


                    Log in to the SAP NetWeaver Administrator of the concerned system, via https://<hostame>:<port>/nwa.
                

                    Go to the Destinations section by following the path Configuration • Connectivity • Destinations.
                

                    Filter for and select the SLD_DataSupplier destination, and edit it (see Figure 3.22).
                

                    Change the URL field (in the Connection and Transport tab) to show the URL of the SLD that the system needs to register itself with. Note that the format of the URL should be http://<hostname>:<port>.
                

                    Add the required login details in the Logon Data tab.
                

                    Test your destination setup by clicking on Ping Destination (see Figure 3.22). After a successful ping, you're ready to register the system with the SLD and send some data.
                


Figure 3.22    Steps to Self-Register a Java-Based System with the SLD
To manually push the data to the SLD or to force the self-registration of an SAP NetWeaver AS Java system, follow these steps:


                    From SAP NetWeaver Administrator, navigate to Configuration • Infrastructure • SLD Data Supplier Configuration.
                

                    You should see information about the next scheduled or automatic send time. Select the Collect and Send Data option. If everything was well configured, then you'll get a successful send data message.
                

                    You should now be able to log in to the target SLD and verify that the new system registered itself. You can find this out by looking up the list of technical systems in the target SLD.
                

3.5.4    Configuring Data Suppliers from One SLD to Another
All data about technical systems that an SLD receives can be forwarded to another SLD using the data supplier. It's important to stress that only data which arrived via data suppliers (such as technical systems) are forwarded. All manually created data (such as business systems) aren't included in the forwarded data. Use the manual export and import options described in the next section for manually created SLD data.
To set up data forwarding between a source and target SLD (or data supplier target), perform the same steps as described previously for automatic bridge forwarding (Section 3.4.2; also refer to Figure 3.17).
3.5.5    Manual Export and Import of Data
It's possible to manually export any data from a source SLD to a target SLD by using the import and export features. In this way, you could export and import manually created business systems, for instance. The steps to export a business system were described previously in Section 3.4.1. We'll extend those steps by mentioning the required steps to import an exported business system into a target SLD.
The required steps are as follows:


                    From the System Landscape Directory landing page of your target SLD, click on the Administration link.
                

                    Then click on Import.


                    You're offered the possibility to import an archive file. Choose the file that you exported from the source SLD.
                

                    Start the import procedure by clicking on the Import button.
                

                    You'll see another screen that requires you to confirm or cancel your import. Click Continue Import.
                

                    After this step, a message confirming the successful import of the new business system will be displayed.
                

3.5.6    Connecting the SLD to CTS+ to Facilitate the Export and Import of SLD Data
To facilitate the propagation of SLD data from one SLD to another, we recommend that you use a transport mechanism rather than the manual export and import feature. CTS+ is the recommended tool to manage your SAP PO transports. To connect your development SLD to CTS+, follow these steps:


                    Make sure that you have a communication user in the SAP NetWeaver AS Java that belongs to the SAP_SLD_Administrator group. If such a user doesn't exist, then create it before proceeding to step 2.
                

                    Go to the SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.
                

                    Navigate to Configuration • Connectivity • Destinations.
                

                    Create a destination called "sap.com/com.sap.tc.di.CTSserver" if it doesn't already exist. Give it the type RFC, and click Next. Note that the destination name is predefined by SAP and therefore must match exactly. It's also case sensitive (see Figure 3.23 1).
                

                    In the next wizard step, add details of the transport system, including logon details to be used to connect to it. Make sure to use a technical user for the logon data 2.
                

                    Click Finish.
                


Figure 3.23    Steps to Set Up a Destination from SAP PO to CTS+
Now that you've connected your system to CTS+, you can test the export functionality via the following steps:


                    Log in to your SLD, and navigate to the object you want to export via CTS+. As an example, export a SC.
                

                    From the System Landscape Directory home or landing page, select Software Components.
                

                    Select the SCs in question, and click on Export.
                

                    You'll see an Export screen with the Transport tab enabled. If the steps for configuring the destination to CTS+ aren't performed properly, you'll see an error here, and the Transport tab won't be enabled (see Figure 3.24).
                


Figure 3.24    Exporting SLD Objects with CTS+ Enabled









3.6    Exercise: Configuring the System Landscape Directory
This exercise is meant to serve as an implementation example and provides a practical insight into the SLD and its objects. We begin with a description of the exercise, briefly touch on what the solution would look like, and then provide step-by-step instructions for the solution.
3.6.1    Exercise Description
Imagine that you're employed by a fictitious company called Reader's Paradise as an SAP integration expert. Reader's Paradise is a bookstore that specializes in selling exclusive books. The company uses SAP PO, and you've been asked to build an interface enabling Reader's Paradise to order books from its main supplier, Book Fountain. This means that you need to build an interface that will fetch a purchase order from Reader's Paradise's system and send the order to Book Fountain.
This first exercise focuses on creating all necessary SLD objects required to build the interface, as illustrated in Figure 3.25.

Figure 3.25    Scenario to be Built for Purchase Order Transfer
3.6.2    Exercise Solution Approach
In this first exercise, you're only required to create the relevant SLD objects. The SLD objects to be created include the following artifacts:


                    A product
                

                    Three SCs (given that we want to use the three components model, the SC containing the shared object needs to have a dependency to the other two SCs)
                

                    Two technical systems (for sender and receiver of the third-party type)
                

                    Two business systems (for sender and receiver of the third-party type)
                

A graphical representation of these artifacts and the relationships among them is depicted in Figure 3.26.

Figure 3.26    The SLD Artifacts and Their Relationships
We provide the step-by-step solution of the exercise in the next section.
3.6.3    Exercise Step-by-Step Solution
The activities and steps to create the objects (as listed in the exercise solution approach) are described in the following subsections.
Log On to the System Landscape Directory
To log on to the SLD, open a browser, go to http://<hostname>:<port>/sld, and log in with your credentials when prompted to do so. In the preceding URL, <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
Create a Product
To create a product that will hold the SCs, follow these steps:


                        Click on the Products tab of the System Landscape Directory landing page.
                    

                        Click on the New button to follow the wizard for creating a product (see Figure 3.27).
                        
Figure 3.27    First Steps for Creating a Product in the SLD


                        Follow the wizard, and enter the name "PR_READERSPARADISE" for your product. Enter "ReadersParadise.com" as the product vendor (see Figure 3.28).
                    

                        Click on Next, and you'll be asked to fill in data to create the SC.
                    


Figure 3.28    Creating a Product in the SLD
Create Three Software Components
Because we're following the three SC model, we'll need three separate SCs to hold the sender, receiver, and canonical objects.
To create the SCs that will hold the objects and artifacts during design time and with which the technical and business systems will be associated, follow these steps:


                        Click on the Software components tab of the System Landscape Directory landing page.
                    

                        Click on the New button to follow the wizard for creating a new SC. Follow the wizard, and name the SC "SWC_READERSPARADISE". The final results are shown in Figure 3.29.
                    

                        Click on Finish.
                    

                        Repeat steps 2 and 3 to create two more SCs, with the names "SWC_BOOKFOUNTAIN" and "SWC_MAPPINGS".
                    


Note
You need to select the product (PR_READERSPARADISE) that was previously created for your SCs.


Figure 3.29    Creating a Software Component in the SLD
Given that the SC named SWC_MAPPINGS will contain the mapping and transformation object, it needs to have dependencies to both SWC_READERSPARADISE and SWC_BOOKFOUNTAIN SCs. To create dependencies for the SWC_MAPPINGS, follow these steps:


                        From the System Landscape Directory landing page, select Software Components.
                    

                        Search or filter for the SC to which the dependencies need to added—in this case, the SC called SWC_MAPPINGS.
                    

                        Click on the Dependency tab, and filter for or select the SC SWC_READERSPARADISE.
                    

                        Click on Define as Prerequisite Software Components. The final result should look like Figure 3.30.
                        
Figure 3.30    Creating Software Component Dependency to Other Software Components


                        Repeat steps 2, 3, and 4 to define another dependency from SWC_MAPPINGS to SWC_BOOKFOUNTAIN.
                    

The dependencies are defined to ensure that the Enterprise Services Repository (ES Repository) objects (data, messages types, and service interfaces) of SWC_BOOKFOUNTAIN and SWC_READERSPARADISE can be accessed from the SC SWC_MAPPINGS.
Create Technical Systems (Sender and Receiver)
To create a technical system with which the business system will be associated, follow these steps:


                        Click on the Technical Systems tab of the System Landscape Directory landing page.
                    

                        Click on the New Technical System button to follow the wizard for creating a new technical system.
                    

                        Follow the wizard, and specify the type of the technical system as Third Party.
                    

                        Click on the Next button to proceed to the next screen.
                    

                        Name the technical system "TS_READERSPARADISE" to represent the sending system (see Figure 3.31).
                        
Figure 3.31    Creation of a Technical System


                        Select the products and SCs that are installed in this technical system. If you don't add a SC to a technical system, then it won't be possible to use its service interfaces in your scenario (see Figure 3.32).
                    

                        Repeat steps 2, 3, and 4 to create a new technical system for the receiver system called TS_BOOKFOUNTAIN.
                    


Figure 3.32    Adding Software Components to a Technical System
Create Two Business Systems (Sender and Receiver)
To create a business system that will represent the sender and receiver applications during configuration in the Integration Directory (see Chapter 5), follow these steps:


                        Click on the Business Systems tab of the System Landscape Directory landing page.
                    

                        Click on the New Business System button to follow the wizard for creating a new business system. Click on Next.
                    

                        Follow the wizard, and specify the Type of business system to be Third Party/Other. Click on Next.
                    

                        On the next screen, choose the technical system for this business system. Choose TS_READERSPARADISE because you're required to create a relationship between a business system and its corresponding technical system. Click on Next.
                    

                        On the next screen, name the business system "BS_READERSPARADISE" to represent the sending system. Click on Next.
                    

                        Because you linked the new business system to an existing technical system, all products and SCs used in that technical system will be automatically loaded. You still have the option to select or deselect products and SCs on this screen.
                    

                        In the final step, select the Integration Server (SAP PO system) to be used by this application system. You can select from a dropdown list of all SAP PO/SAP PI systems in your landscape.
                    

                        Repeat steps 1 to 7 for a new business system for the receiving system. This last business system needs to be named BS_BOOKFOUNTAIN and will need to be linked to the technical system previously created and named TS_BOOKFOUNTAIN.
                    










3.7    Summary
In this chapter, we demonstrated that the SLD is a critical component of your landscape, and we explored how it supports the SAP PO middleware by providing it with all necessary foundation objects. This chapter also explored all of the administrative tasks provided by the SLD. These administrative tasks include stopping and starting the SLD, exporting and importing SLD objects, configuring data suppliers, and viewing logs.
Given the critical role that the SLD plays in your organization, the chapter also explored different SLD strategies and approaches to take into consideration during your implementation.
After reading this chapter, you've obtained the foundation required to start building ES Repository objects, a topic that we'll cover in the next chapter.








4    Working with the Enterprise Services Repository and RegistryLook up at the stars and not down at your feet. Try to make sense of what you see, and wonder about what makes the universe exist. Be curious.                                                                                              —Stephen HawkingThe Enterprise Services Repository (which we'll refer to as the ES Repository) is a one-stop shop for designing and developing integration solutions enabled for service-oriented architecture (SOA) and based on SAP Process Orchestration (SAP PO). The ES Repository is the central area in which you design, build, and maintain the logical building blocks that are used to create new integration scenarios during configuration time. It's designed around a model-based architecture, which means that service interfaces are designed using the underlying information model and the business processes providing or consuming them. Because of this strategy, services created in the ES Repository can be maintained and extended in a flexible manner during the lifecycle of the systems and business processes that use them. This approach adheres to one basic principle of SAP PO, which is to decouple the business semantics from the technical aspects of the physical system landscape.
Note
Since the introduction of early versions of SAP Exchange Infrastructure (SAP XI) and SAP Process Integration (SAP PI), the term Integration Repository applied to most functions provided today by the ES Repository. To be consistent with the new terminology, we'll only use the new terminology as used by SAP: Enterprise Services Repository (ES Repository) and Enterprise Services Builder (ES Builder).
In this chapter, we'll first discuss the technical basics of the ES Repository. Then, we'll dive into some of the most important components and explain how to use them. We'll carry on with this journey through the ES Repository with the assumption that you've previously configured the System Landscape Directory (SLD) and that you've already created the necessary products and software component versions (SWCVs), as described in Chapter 3. If that isn't the case, then you can still take a look at Chapter 3, in which the concepts and tools of the SLD are further explained. If you're totally new to SAP PO, then we recommend that you gain that knowledge first because we'll be applying some of those concepts during design time. This chapter ends with a practical exercise focused on the ES Repository online.
4.1    Basic ES Repository Technical Concepts
Before we discuss the specific components of the ES Repository, we'll discuss the main functional blocks and then move on to the central role played by service interfaces in all phases of any SAP PO integration scenario.
4.1.1    Functional Blocks
The ES Repository is made up of two main functional blocks in SAP PO: the ES Builder, which is where you execute the majority of the design-time activities, and the Enterprise Services Registry (ES Registry), which (as mentioned in Chapter 2) can be seen as the yellow pages of services, a directory in which service interfaces are published by service providers and discovered by service consumers (see Figure 4.1).

Figure 4.1    ES Repository: Components Interaction
We already discussed the ES Builder in Chapter 2, Section 2.1.1, so we'll focus on the ES Registry here. The ES Registry centrally stores information about services within an enterprise SOA landscape. The ES Registry contains vital details about the functionality offered by services available in a particular SOA landscape. You can query the ES Registry to retrieve the Web Services Description Language (WSDL) of registered services and their operations and endpoints. Furthermore, services published into the ES Registry can be classified using specific categories, such as their lifecycle status (Released, Configured, Deprecated, etc.), which makes it possible to label services with this information.
The ES Registry is also a central source for SAP PO developers to find available services in their system landscape that they can reuse in integration scenarios. Administrators can find available service endpoints and manage connections between consumer and provider systems. The ES Registry provides support for SAP and non-SAP applications as well as visibility and additional control over the available services in an SOA landscape, providing answers to questions such as the following:


                    Which services are available and where?
                

                    What does the WSDL of the available services look like?
                

                    Which services have been modeled but not yet implemented?
                

                    Which services have been configured and can be called?
                

                    Which endpoints are available (secure or nonsecure) for the services?
                

Normally, after the development of a service interface has been completed, the developer will publish the (new) service interface into the ES Registry so that it can be discovered by service consumers. This procedure doesn't necessarily apply to all organizations and varies depending on the enterprise integration architecture policies of each organization. However, it should be considered and applied whenever possible because it truly contributes to enhancing the level of service reusability and the SOA maturity level within most organizations. Figure 4.2 depicts the interaction between the individual components of the ES Repository.
From a general SOA point of view, the ES Repository also plays a critical role in providing the foundation of enterprise SOA. It's a cornerstone component responsible for storing all relevant aspects of service interfaces consumed and provided by SOA applications. Common service details typically stored in the ES Repository include versioning, namespaces, data types, security policies, operations supported, release status, and so on. Within the context of SAP PO, the scope of the information stored in the ES Repository is much broader and richer, as we'll discover in the next sections.

Figure 4.2    ES Repository: Service Provisioning and Discovery
4.1.2    First Steps in the Enterprise Services Repository
When you open the ES Repository, the first thing you need to do is import the software components (SCs) metadata from the SLD into the ES Repository. You also have the option to create repository objects for testing purposes under a local SWCV. Local SCs don't depend on data from the SLD and so don't need to import anything from the SLD. Regular and local SCs are the virtual containers in which you'll store the repository objects you'll be building during design time in SAP PO.
There are two main types of SWCVs: those delivered as part of SAP or by third parties as business content (i.e., prepackaged integration solutions) and those that are custom built and that you define in the SLD. In this book, we'll mainly deal with the second type. However, the import procedure from SLD into the ES Repository is similar for both types. The only difference is that for custom-built SWCVs, we'll have to create our own repository namespaces, whereas namespaces for business content SWCVs have already been defined by the software supplier. Typical examples of ready-to-use business content shipped by SAP include the ES bundles. An ES bundle offers a set of enterprise services that support a particular business process as part of the SAP enhancement packages for SAP core modules (e.g., SAP ERP Human Capital Management [SAP ERP HCM], SAP ERP Financials [SAP ERP FI], etc.) or for industry-specific solutions, such as Industry Solutions for Utilities (IS-U) or Industry Solutions for Insurance Companies, Claim Management (IS-CM) and Policy Management (IS‐PM).
4.1.3    Service Interface
A service interface in SAP PO is a platform- and programming language-independent interface definition that follows a model-driven approach to define service operations (methods) that will be implemented at a later stage by an SAP or non-SAP application system. A service interface has a one-to-many relationship with the operations it contains.
Depending on the business process and application functionality to be supported by your service interface, it will fall into one of the following categories: inbound, outbound, or abstract.
Service interfaces represent the principle deliverable as a result of the activities performed during design time in the ES Repository. After the service interface is ready, it can be released for proxy generation and further implementation on the application side (e.g., an SAP ABAP or Java backend system). During the process of proxy generation, the following development objects will automatically be created on the application side:


Proxy development objects (i.e., classes, methods, and data types) A service definition for mediated or point-to-point communication using the web service runtime.
                

Inbound (service provider) You want to expose specific application functionality available on the backend system to service consumers. The consumers of your services can be either other application systems or users. From an SAP PO perspective, the system receiving or processing the requests is the inbound or server (proxy) application.
                

Outbound (service consumer) You need to consume information provided by an external system from your backend system. The invocation of an outbound service can be either automatically or manually triggered from the backend system. From an SAP PO perspective, the system sending the messages is the outbound or client (proxy) application (see Figure 4.3).
                


Figure 4.3    Outbound vs. Inbound Service Interfaces


Abstract (only applicable for SAP PI dual-stack systems) A special type of interface used in integration processes, and part of the cross-component Business Process Management (ccBPM) framework. Abstract interfaces can't be used to generate and implement service interfaces on the backend system. Furthermore, they can only run under dual-stack (ABAP) systems and therefore aren't applicable for SAP PO Java-only systems.
                

4.1.4    Integration Patterns: Stateful and Stateless Communication
Each service interface created in SAP PO has an integration pattern assigned to it. This functionality enables developers to build different types of integration scenarios. Currently, four different types of integration patterns are supported in SAP PO, as discussed in the next sections.
Stateful
A service consumer sends a request to a service provider, and the service provider receives and processes the request. If required, the service provider will send an answer back to the service consumer. After the message exchange has completed successfully, the information (status) contained in the request and response messages remains available for the messaging runtime. This is known as stateful communication.
Stateless
Service consumers send their request to service providers, and service providers receive and process the information. If required, the service provider will send an answer back to the service consumer. After the delivery of messages involved in the message exchange has completed successfully, the information (status) contained in the request and response messages is no longer available for the messaging runtime. This is known as stateless communication and is integration pattern you'll encounter in most integration scenarios.
Stateless (XI30-Compatible)
This integration pattern offers backward compatibility with all existing protocols (up to SAP NetWeaver 2004s) in backend systems that were generated and implemented based on message interfaces. Message interfaces are the predecessors of service interfaces. If you're migrating message interfaces previously created with the Integration Repository of SAP NetWeaver 2004s into service interfaces in the ES Repository, then they will be assigned to this interface pattern. This particular interface pattern only allows one operation per service interface.
Tentative Update and Confirm or Compensate
This pattern is SAP's own implementation of the widely known two-phase commit protocol. Its goal is to support atomic transactions executed across distributed systems. From an SAP PO point of view, it makes it possible to enhance the Best Effort (BE) Quality of Service (QoS) provided by synchronous messages to Exactly Once (EO). Technically speaking, this pattern allows you to synchronously distribute information across systems using both QoS BE and EO.
One good example of the application of this type of integration pattern is provided these days by many airline online booking websites. When making a new flight reservation, the customer gets the option to make a prereservation without having to confirm the ticket. That can be handy if you need more time before you decide to buy your ticket. Later on, you can come back to the airline's website and make the final reservation or even cancel it.
4.1.5    Asynchronous versus Synchronous
From a system integration perspective, information interchanged between systems can be grouped into two main categories: unidirectional or bidirectional. When the information flows from one system to another, and the sender of that information doesn't expect a direct answer from the receiver, this is asynchronous communication. With synchronous communication, the sender of the information (question or request) expects a direct answer and waits until the answer (also called a response) is sent back by the receiver. This might sound like a very trivial and logical subject, but it's one of the most discussed topics in system integration architecture and system integration development decisions. Therefore, it's very important that you're able to identify whether your service interfaces should support asynchronous or synchronous operations, based on the business process functional and technical requirements. Let's see how these two different types of communication can be compared with our daily lives in the following subsections.
Asynchronous
A good example of asynchronous communication from our daily lives is interaction in social media platforms, such as Facebook or Twitter (see Figure 4.4). When you send a tweet to your followers, you don't necessarily expect an answer from your followers. However, if you do expect an answer, then it might take some time before you see the reactions in your lists of tweets.
Synchronous
The analogy we always use to explain synchronous communication is quite simple but very effective (also shown in Figure 4.4). When you call someone on the phone, you expect a direct answer from the person you're calling on the other side. If the person doesn't answer the phone, then you might try one more time, call at a later time, or maybe leave a message on his voicemail system. This last option, in turn, is a good example of buffering messages on the receiver side for later processing, as we'll explain in the next section about QoS.

Figure 4.4    Examples of Asynchronous and Synchronous Communication
4.1.6    Quality of Service
Service interfaces can be configured to meet different types of processing requirements set by the sender of the messages into SAP PO. The sender uses the different types of QoS to specify how the messages should be delivered. SAP PO currently supports the following QoSs:


Best Effort (BE) Messages are sent synchronously by the sender system. The sender waits for a response before it continues processing. This is the default QoS for synchronous interfaces, such as Remote Function Calls (RFCs), Business Application Programming Interfaces (BAPIs), synchronous ABAP proxies, and web services.
                

Exactly Once (EO) The message is sent asynchronously. The sender doesn't wait for a response. The Advanced Adapter Engine Extended (AEX) guarantees that the message is sent and processed exactly once. You normally select this QoS for most asynchronous interfaces, such as integration via Java Message Service (JMS), IDoc, asynchronous ABAP proxy, or file-based interfaces.
                

Exactly Once in Order (EOIO) Similar to the EO QoS messages, EOIO QoS messages are sent asynchronously; however, in this case, messages are delivered in the same order as they were sent from the sender. Messages are delivered to a specific set of preconfigured queues as supplied by the application. Always use this QoS with caution and only apply it when no other alternative is provided by the sender or receiver system because it introduces more complexity and potential performance issues to your integration scenario. For instance, when one of the messages generates an error during processing, it will block all subsequent messages that arrive after that erroneous message. To restore the flow of messages, the message causing the error must be retried, saved, or deleted from the queue.
                

In this section, we've discussed the centerpiece of the design objects: the service interface. What else do you need to make information interchange between systems and business processes possible? We'll discuss design objects next.









4.2    Design Objects
Design objects come in different shapes, categories, and names—each covering specific tasks within the ES Repository spectrum. However, they all share the same common goal, which is to make integration between systems and business processes possible. In this section, we'll uncover the other design objects needed to support several types of integration scenarios.
4.2.1    Software Component Versions
A SWCV is a virtual logical container that stores all relevant design objects created during design time in the ES Repository. It's also used to define a shipment unit as part of an integration solution. This shipment unit can be then delivered and installed on the customer side (i.e., in a different SAP PO system). A SWCV is always linked to its parent product (as defined in the SLD), and there can be one or more versions of the same SWCV available.
As explained before, you can also create local SWCVs for test purposes in your development environment. When working with local SWCVs, keep in mind that they can't be transported or used to configure integration scenarios in the Integration Directory. However, you can decide later on to transfer local objects to a transportable SWCV via release transfer.
4.2.2    Folders
With repository folders, you can add more structure to the design objects created under a particular namespace. Each folder can contain any number of subfolders, just like in Finder for Macs or in Windows Explorer. For instance, you can create folders based on the design object category, such as service interfaces, mappings, and so on. Another option is to introduce folders as a way to separate certain design objects that belong to specific business processes or functionalities.
4.2.3    Namespaces
When working with XML documents, you normally assign one or more namespaces to the XML documents' elements and attributes to differentiate them from other elements and attributes with the same names that might also exist in other XML documents. The purpose of namespaces in the ES Repository isn't much different—namely, it's to guarantee the uniqueness and differentiation of object types within an SWCV. Namespaces are created at the SWCV level. You need to create a namespace within an SWCV before you can start adding new design objects to that SWCV. You can share the same repository namespaces in different versions of the same SC, but you must use different repository namespaces for different SCs.
When defining ES Repository namespaces, consider the following best practices:


                    Introduce and stick to naming conventions. If possible, use existing naming conventions available in the SAP PI developer's community as a foundation, and extend them with your own conventions if necessary.
                

                    Try to define namespaces based on the following criteria:
                    

                            The business processes they support (e.g., HR, legal, logistics, etc.)
                        

                            The business domains or geographical areas of the organization (e.g., consumer products or Business-to-Business [B2B], or US, EU, APJ [Asia Pacific Japan], etc.)
                        

                            A combination of the preceding criteria (e.g., US:HR, EU:HR, etc.)
                        



                    Give preference to Uniform Resource Name (URN)-style instead of URL-style namespaces to avoid confusion with callable URLs.
                

                    Use only lowercase when defining namespaces.
                

                    Namespaces must be unique across different SCs in the same ES Repository.
                

                    Keep the length of namespaces as short as possible.
                

Let's go over a few examples of possible namespace syntax:


Based on business processes urn:[company urn]:[process]:[sub process*]:[application*]
Example: urn:rojoconsultancy.com:hr:recruitment:peoplesoft
                

Based on geographical area urn:[company urn]:[geographical_area]:[application*]
Example: urn:rojoconsultancy.com:eu:peoplesoft
                

Based on a combination of both urn:[company urn]:[geographical_area]:[process]:[application*]
Example: urn:rojoconsultancy.com:eu:hr:recruitment:peoplesoft
                


Optional
Depending on the size and complexity of your system landscape, you'll have to choose the appropriate namespace approach to accommodate not only your current but also your future design objects in the ES Repository. By doing so, you're paving the way to an extendable and logical way of organizing and managing content in the ES Repository.


Predefined ES Repository Namespaces
When IDocs, BAPIs, or RFCs are imported into an SWCV, you'll notice that these types of objects already have their own predefined namespaces. Table 4.1 shows an overview of how these namespaces look in the ES Repository.





                            Namespace
                        

                            Area of Application
                        





urn:sap-com:document:sap:idoc:messages


                            Imported IDoc interfaces
                        



urn:sap-com:document:sap:rfc:functions


                            Imported BAPI or RFC interfaces
                        



http://sap.com/xi/XI/System/Patterns
http://sap.com/xi/XI/SFTP


                            Imported business content provided by SAP or a third party
                        



Table 4.1    Predefined ES Repository Namespaces
We'll now talk about operation mappings and message mappings, which are both absolutely crucial repository objects in most SAP PO or SAP Business Process Management (SAP BPM) integration solutions.
4.2.4    Mappings
Common mediation services offered by an ESB such as SAP PO include, for example, the transformation and mapping of multiple message protocols. Thanks to this feature, you can create integration solutions that can support any-to-any interaction between services from almost any type of system (SAP and non-SAP). It doesn't matter which service initiates (sends a request) or answers (sends a response) the message interaction—SAP PO can support the mapping or transformation logic needed to generate the required target message protocol.
Operation Mapping
An operation mapping is used to map and/or translate the message structure from one service interface operation into another. The message structures define the actual contents of a service interface operation, as declared in its WSDL. It's important to emphasize here that an operation mapping is configured to map web service-styled operations. The messages mapped don't always necessarily represent a real web service operation as such, but they can be almost anything (a text file, a binary file, a database query, a mainframe message, etc.) as long as they can be represented as XML documents while being processed by SAP PO. For instance, you might want to map a flat file or a database query outbound message into an IDoc or ABAP proxy structure (see Figure 4.5).

Figure 4.5    Operation Mapping
Define the assignment of the operations linked to each other in an operation mapping. The number and type (message mapping, Extensible Stylesheet Language Transformations [XSLT], Java, etc.) of mapping programs or transformation rules you need to configure for an operation mapping depends, among other elements, on the communication mode and the complexity of the mapping to be performed:


Synchronous communication Synchronous operations always have a request, a response, and an optional fault message. In that case, you have to define separate message mapping programs for request, response, and fault messages.
                    

Asynchronous communication For 1:1 mappings, you only need one mapping program. Only in some special situations, you'll need to declare more than one mapping program as we'll explain in the next section.
                    

More than One Mapping Program
Depending on the complexity of the mapping requirements or type of transformation you have to support, it might be necessary to apply more than one mapping program to a single input before you can get the required message structure as the output of the operation mapping. The operation mapping offers standard functionality to execute multiple mappings in a sequence. You do that in the operation mapping editor, in which you can configure the necessary mapping programs in the correct order of execution. You can combine different types (graphical, XSLT, Java, etc.) of mapping programs in the operation mapping editor.
No Operation Mapping between Outbound and Inbound Service Interfaces
When both the outbound and inbound service interface have the exact same XML structure (i.e., both interfaces use the same message type to describe their web service operations, and there's no mapping rules to be applied to those messages), you don't need to create an operation mapping program. In such a scenario, the AEX only plays the role as the "pass-through" integration layer between sender and receiver without changing the internal structure of the message.
Message Mapping
In message mapping, you realize the actual message mappings between two XML structures as configured in operation mapping. You build the mapping with the graphical mapping editor. In the editor, you select the messages to be mapped, the source structure, and the target structure. The graphical mapping editor offers different standard tooling and out-of-the-box functions to realize simple and complex mappings. You also have the choice to build your own custom-built Java functions using user-defined functions (UDFs) and function libraries or even to import your own Java classes (for the more adventurous).
Overview of Mapping Objects
Table 4.2 provides an overview of the mapping objects you can create in the ES Builder.




                                Mapping Object
                            

                                Description
                            





                                Operation mapping
                            

                                Associates one or more mapping programs for a pair of service interface operations. An operation mapping encapsulates the mapping programs to be executed at runtime.
                            



                                Message mapping
                            

                                Created using the graphical mapping editor. A message mapping has to be referred to by an operation mapping.
                            



                                Function library
                            

                                Enables you to use UDFs across message mappings. You can use UDFs from a function library in message mappings and in mapping templates. UDFs are custom-built Java functions created at the message mapping level to enhance the mapping program or add specific mapping functionality not available in the default mapping functions.
                            



                                Imported archive
                            

                                Contains an externally developed Java or XSLT (Java) mapping program. They are imported as archives (ZIP files) and are configured using an operation mapping.
                            



                                Mapping template
                            

                                Contains specific, reusable parts of a message mapping that can be used to create new message mappings.
                            



Table 4.2    Mapping Objects
4.2.5    Process Integration Scenario
Process integration scenarios and actions bundle and represent all relevant design objects that you use at configuration time, such as service interfaces, mappings, and communication channel templates.
A process integration scenario is a graphical representation of the process flow, showing the different interactions between the involved components in your integration scenario (called the collaborative process). It gives you a high-level overview of the integration scenario, its participants, the exchange moments, mode of communication (i.e., synchronous or asynchronous), type of communication (inbound or outbound), message types used for information exchange, and any applicable mappings. Furthermore, you can use a process integration scenario as a template for later use during configuration time from the Integration Directory. Another advantage of using process integration scenarios is that they provide a quick view from a repository perspective into the integration solution for developers and technical administrators. Figure 4.6 shows a simple example of synchronous interaction between two service interfaces modeled as a process integration scenario in ES Builder.

Figure 4.6    Process Integration Scenario in ES Builder
4.2.6    Actions
Actions represent specific functions executed by a component within the process integration scenario. When creating an action, you bind an existing outbound or inbound service interface with the action. Typically, you'll encounter the following types of actions defined in a process integration scenario:


                    Send
                

                    Receive
                

                    Create, read, update, and delete (CRUD)
                

Actions are design objects that are independent of the process integration scenario so they can be reused in different process integration scenarios.

Note
Neither integration scenarios nor actions are required when creating design objects as part of an integration scenario. Their use is always optional, but is best practice.

In the next section, we discuss data types, external definitions, message types, and fault message types, which are design objects that give structure and context to the inner part of service interfaces created in ES Builder.









4.3    Data Types and Message Types
Service interfaces consist of message types and data types, which define the information they carry from sender to receiver. Fault message types are a special variety of message type designed to help you handle interface errors triggered at the application layer. Those are exceptions that may occur on the inbound side and that are reported back to the sender or persisted in the SAP PO monitoring layer.
Service interfaces, data types, message types, fault message types, and external definitions are all commonly referred to as interface objects.
4.3.1    Data Types
Data types are used to describe the internal data structure of a message type, which in turn is used to define the structure of a service interface. Data types can be reused in different messages types inside the same SWCV as well as in other SWCVs across the ES Repository. To enable that functionality, you have to make sure that all necessary SWCV dependencies have been previously configured in the SLD.
The following data types are supported in the ES Repository:


Core and aggregated data types Core and aggregated data types are based on the Core Components Technical Specification (CCTS) and are the basis for application-specific data types accepted across several industries.
                    For example, address is considered to be an aggregate data type, and any field of an address, such as city, is considered to be a core data type.
                

Freestyle data types Freestyle data types are those you design, create, and maintain yourself with the aid of the data type editor in the ES Builder. They are based on the primitive data types and are self-descriptive (e.g., string, integer, Boolean, etc.).
                

4.3.2    External Definitions
An external definition in the ES Repository is an imported message structure that describes either an entire message or a part of it. An external definition can be imported as a WSDL, XML Schema Definition (XSD), or Document Type Definition (DTD). After a successful import, you can decide which part of the external definition you want to assign to the service interface definition (i.e., request, response, or fault).

Note
Currently, there are some limitations in terms of the XSD features supported by external definitions in SAP PO. An important one prevents making use of the XML choice element used in XSDs. The following example shows an element named "entity", which must contain either a "company" element or a "person" element:
<xs:element name="entity">  <xs:complexType>    <xs:choice>      <xs:element name="company" type="company"/>      <xs:element name="person" type="person"/>    </xs:choice>  </xs:complexType></xs:element>

4.3.3    Message Type
A message type encapsulates a data type that describes the structure of a message of a service interface at the operation level. The message type defines the root element of a message and describes an instance of a message to be exchanged. Message types describe the root element of the request, response (only for synchronous service interfaces), and fault messages of a service interface. You can reference the same message type in different service interface operations and also in different service interfaces across the ES Repository. A message type is direction agnostic; in other words, it doesn't define whether you should use it for the request or response part of your service interface. In fact, you can use the same message type for both the request and response messages.
A fault message type is a special message type that is used to carry application-specific error information about technical or functional errors that occur while processing an inbound request. The information is generated on the service provider side and is passed back to the service consumer that expects the response. Fault message types are only intended to be applied in synchronous service interfaces in principle; therefore, you can't assign fault message types to asynchronous operations of outbound service interfaces. When an ABAP or Java proxy is generated from a service interface that contains a fault message type, an exception class is also generated for the fault message type. This exception class is used to handle application errors at runtime.
A fault message type is made up of two parts: a mandatory standard data part and an optional additional data part:


Standard data (mandatory) This data part is used to return the fault message standard information for an error during runtime. All fault message types reference the data type ExchangeFaultData for this part and, indirectly, the data type ExchangeLogData. These data types are automatically created when you create the first fault message type in a namespace.
                

Additional data (optional) Use this data part to attach any additional application-specific information to the fault message. To do so, reference any data type in the same SWCV or in a sub-SWCV.
                

4.3.4    Additional Design Objects
So far, we've only concentrated on the most commonly used design objects in integration scenarios. However, the ES Repository has more features to offer, which are provided by additional design objects that support specific functionality for different purposes. Table 4.3 provides a quick overview of these remaining objects.




                            Name
                        

                            Description
                        





                            Modeling




                            Model
                        

                            Supports a model-driven approach applying a top-down development strategy. Start design time in the ES Repository by modeling the process components and their corresponding data objects first and then the service interface objects.
                        



                            Object definition
                        

                            The data objects used by the model and the process components it contains. Each business object belongs to exactly one process component.
                        



                            Interface objects




                            Imported object
                        

                            IDoc, BAPI, or RFC interface that exists on an SAP backend system and is imported into the ES Repository.
                        



                            Data type enhancement
                        

                            Provides a flexible and easy way of enhancing existing data types that are part of standard SAP business content, such as Enterprise Services provided as ABAP proxies.
                        



                            Context object
                        

                            Used as abbreviated expressions for XPath expressions to address specific payload elements. Context objects are used in routing conditions.
                        



                            UI text object
                        

                            A UI text object has a text category, with which you specify the use of the text created. You can use text objects of the Field Label category in data types.
                        



                            Adapter objects




                            Adapter metadata
                        

                            Allows you to define configuration data needed for a certain type of adapter at design time. Adapter metadata defines the part of a communication channel that is specific to the adapter type.
                        



                            Communication channel template
                        

                            Used to preconfigure a communication channel and to define a communication channel at configuration time. In this way, all communication channels can follow strict rules (and save configuration time), as configured in the template. This is extremely useful when you're using adapter modules or the Apache extensible Interaction System (Axis) framework configuration.
                        



                            Version creation
                        



                            Change list
                        

                            Used to create your own change lists in advance and organize changes made to design objects.
                        



                            Work areas
                        



                            Usage profile
                        

                            Offers personalized filters based on the user role and/or preferences. System administrators can predefine a set of design objects, SWCVs, and business modeling filters for developers to select from. All the other design object types remain hidden.
                        



Table 4.3    Additional Design Objects in ES Repository









4.4    Exercise: Working with the ES Repository and Registry
In Chapter 3, we created and configured the technical systems, business systems, products, and SWCVs. In this exercise, we'll create all the design objects necessary to support the information exchange between the backend system of Reader's Paradise and Book Fountain.
4.4.1    Exercise Description
The customer (in this case, Reader's Paradise) has asked you to build an SAP PO interface to support the automatic exchange of purchase orders between its procurement backend system and its supplier, Book Fountain. The functional requirements also indicate that before you can send the order to the supplier, you first need to convert and map the input into the supplier's message structure. Based on the specifications of the business process, you also know that the interface will be asynchronous; that is, no direct answer from the supplier side is expected. Remember, at this stage of the development process, it's less important to know which systems are going to use the design objects. Those additional details will become clear when we discuss the configuration done in the Integration Builder part of the Integration Directory.
4.4.2    Exercise Solution Approach
To achieve your goals, you'll need the following design objects:


                    All three SWCVs, imported from the SLD into the ES Builder
                

                    A repository namespace for each imported SWCV
                

                    Data and message types for the sending and receiving service interfaces
                

                    Two asynchronous service interfaces: an outbound service interface for the sender component and an inbound service interface for the receiver component
                

                    An operation mapping and a message mapping to transform the input XML structure into the output XML structure as expected by the receiver system
                


Good to Know
As a best practice, we strongly recommend introducing and applying naming conventions for SAP PO developments before you start any integration scenario. You can create your own set of naming conventions, but you can also reuse or extend existing naming conventions available from the SAP PO community on the Internet.

We'll now continue with the next steps of the exercise by initiating the design time in the ES Repository.
4.4.3    Exercise Step-by-Step Solution
The next sections will provide a step-by-step solution.
Importing Software Component Versions in the ES Repository
We'll start by importing all three SWCVs we created in the SLD into the Integration Builder. Then, we'll start adding our design objects to the different SWCVs.
The SWCVs that we'll import into the ES Builder are as follows:


SWC_READERSPARADISE


SWC_BOOKFOUNTAIN


SWC_MAPPINGS


To import the SWCVs, follow these steps:


                        Navigate to the landing page of SAP PO, and click on the Enterprise Services Builder link (see Figure 4.7). Open a web browser, and go to http://<hostname>:<port>/dir. Log in with your SAP PO credentials when prompted.
                        
Figure 4.7    SAP PO Landing Page


                        Press (Ctrl) + (N), or navigate to the top menu, and click on Object (see Figure 4.8).
                    

                        Select Import from SLD, and click on the Display button to populate the list with available SWCVs from your SLD.
                        
Figure 4.8    Create Object Screen from the ES Builder


                        From this screen, you can search for and select the SWCVs (one at a time) that you want to import into your development environment. Type the name of the SC, "SWC_READERSPARADISE", into the search bar, and click on Import.
                    

                        Select the correct entry from the list, and click on the Import button to start the import process (see Figure 4.9).
                        
Figure 4.9    Import of SWCVs


                        When you're finished, you should now see the details of the imported SWCV in the Create Object window. If that is the case, then you can proceed by clicking on Create (see Figure 4.10).
                        
Figure 4.10    Creating the SWCV from SLD


                        You should now see a new editor window open on the right side of your screen, displaying the new SWCV. Before you can press (Ctrl) + (S) or click on the Save button, you need to select the desired original language for this object from the dropdown menu. Repeat steps two to six for the remaining two SWCVs (SWC_BOOKFOUNTAIN and SWC_MAPPINGS). Then, click on Save. Note that the Namespaces panel at the bottom of the page contains no entries yet; however, we'll work on namespaces in the next part of the exercise (see Figure 4.11).
                    


Figure 4.11    Configuring and Saving SWCVs
Creating Repository Namespaces
Now that you've imported and configured the SWCVs, you're ready to start creating the necessary design objects for your file to FTP integration scenario. Follow these steps:


                        Click Object from the main menu or press (Ctrl) + (N) to create a new repository object. In this case, you'll create a repository namespace in each of the new SWCVs. Fill in the following values (see Figure 4.12):
                        

Namespace: "urn:readersparadise.com:scm:procurement:erp"
                            

Software Component Version: "SWC_READERSPARADISE" (You can find this by clicking on the Value List; select the correct one, and click on Create.)
                            



                        Click on Save (see Figure 4.13).
                        
Figure 4.12    Create the New Repository Namespace

Figure 4.13    Save the New Repository Namespace


                        Repeat the previous step for the two remaining SWCVs. The namespaces for the two other SWCVs are as follows:
                        

SWC_BOOKFOUNTAIN: urn:readersparadise.com:scm:procurement:supplier


SWC_MAPPINGS: urn:readersparadise.com:scm:procurement




After you've finished creating the new namespace for each SWCV, the contents of your SWCV should look like Figure 4.14.

Figure 4.14    SWCV with New Repository Namespace

Good to Know
At this stage of design time, you'll start building up a change list (per SWCV) that contains all creations, changes, and deletions made to saved activities performed in the ES Builder. From the moment you activate a change list, its contents will be visible and available to the rest of the developer team and the SAP PO environment.
Before activation, you have the option to reject specific changes or the entire change list. You can also see other change lists and assign them to other users. Finally, you can query and look into the contents of previously activated (i.e., closed) change lists (see Figure 4.15).

Figure 4.15    Repository Change Lists

Creating Data Types, Message Types, and Service Interfaces
You're now about to create your service interfaces, which are the arteries of every integration scenario built on top of SAP PO. First, however, we need to lay some groundwork, the theoretical explanation of how you're going to tackle this task.
When designing custom service interfaces in SAP PO, you can decide whether to apply a top-down or a bottom-up development approach. Our advice is to follow the bottom-up approach instead of top-down, for two reasons:


                        It follows the SOA design principle of contract first.
                    

                        It fits perfectly into a model-driven development style in which the application logic (e.g., service interfaces, GUIs, etc.) is based on the underlying information model rather than the opposite.
                    

In addition, when you're creating the service interfaces, all message types, data types, and external definitions will be ready and available there for you to select.
Enough theory for now; let's go back and focus on our main goal, which is the completion of the design-time objects for this exercise.
Start by creating two data types, one message type, and an outbound service interface for the sender component for the integration scenario by following these steps:


                        Click on Object from the main menu, or press (Ctrl) + (N) to create a new repository object. Click on Interface Objects and then on Data Type.
                    

                        Fill in the following values:
                        

Name: "DT_OrderItem" ("DT" is our naming convention for data types)
                            

Namespace: "urn:readersparadise.com:scm:procurement:erp"
                            

Software Component Version: "SWC_READERSPARADISE"
                            



                        Click on Create.
                    

                        Now that you've created your data type, complete the fields that will carry the order information during runtime. Enter the values shown in Figure 4.16, and save your work.
                        
Figure 4.16    Creating the Data Type for DT_OrderItem
                        Now, create the second data type for the sender component, which will contain additional header fields at the order level (not to be confused with the SOAP header) in the payload. Follow these steps:
                    

                        Click on Object from the main menu, or press (Ctrl) + (N) to create a new repository object. Click on Interface Objects and then on Data Type.
                    

                        Fill in the following values:
                        

Name: "DT_Order"
                            

Namespace: "urn:readersparadise.com:scm:procurement:erp"
                            

Software Component Version: "SWC_READERSPARADISE"
                            



                        Click on Create.


                        Complete the fields contained in this new data type structure. Note that you can now start reusing your own data types (see the OrderItems element in Figure 4.17). Choose DT_OrderItem for the definition of this new structure by selecting it from the Type dropdown menu or by selecting the Type column and pressing the (F4) key. Complete the data type as shown in Figure 4.17, and click on Save when you've finished.
                    


Figure 4.17    Creating the Data Type for DT_Order
Now you can create the message type, which in fact represents the root element of the outbound service interface. Assign your previously created data type DT_Order as your main data type for this new message type. Follow these steps:


                        Click on Object from the main menu, or press (Ctrl) + (N) to create a new repository object. Click on Interface Objects and then on Message Type.
                    

                        Fill in the following values:
                        

Name: "MT_PurchaseOrder" ("MT" is our naming convention for message types)
                            

Namespace: "urn:readersparadise.com:scm:procurement:erp"
                            

Software Component Version: "SWC_READERSPARADISE"
                            



                        Click on Create.


                        Select DT_Order for Data Type Used.
                    

                        When you finish, your message type should look like Figure 4.18. Don't forget to save your work.
                    


Figure 4.18    Creating the Message Type for MT_PurchaseOrder
Now that you've defined the message type, you can create the outbound service interface by following these steps:


                        Click on Object from the main menu, or press (Ctrl) + (N) to create a new repository object. Click on Interface Objects and then on Service Interface.
                    

                        Fill in the following values:
                        

Name: "SIOA_PurchaseOrder" ("SIOA" is our naming convention for service interface outbound asynchronous)
                            

Namespace: "urn:readersparadise.com:scm:procurement:erp"
                            

Software Component Version: "SWC_READERSPARADISE"
                            



                        Click on Create.
                    

                        The new service interface is displayed on the screen. Leave all default values for the attributes (category, interface pattern, and security profile) as is. You can change the operation name to something else if desired, but it isn't necessary for this exercise. Make sure that the Mode selected is Asynchronous, and proceed to select the Message Type MT_PurchaseOrder from the Name column dropdown menu in the Messages area at the bottom of the screen. The final product should look like the one shown in Figure 4.19. Save your work when you finish.
                    


Figure 4.19    Creating the Service Interface for SIOA_PurchaseOrder
You've now created all the necessary objects for the sender component of the integration scenario, but you still have to create the same types of design objects for the receiver component.
You'll notice that there are some differences between the data types on the sender and receiver side. That difference is represented by the contents of the data types on both sides (i.e., DT_Order [sender] and DT_item [receiver]). The definition of the internal XML structure for the purchase order message is provided by Book Fountain. Create the design objects (data type, message type, service interface, operation mapping, and message mapping) discussed ahead, using the same general instructions as explained for the sender side, but take into consideration that there are some differences in the internal message structures for the receiver service interface.
You need to create one data type, one message type, and an inbound service interface for the receiver component for the integration scenario.
To begin designing objects for the receiver component in SWC_BOOKFOUNTAIN, follow these steps:


                        Create data type DT_Item. In this case, you want to use one single data type to describe both header and line items in one structure. On the sender side, you described two separate data types for header and line items (see Figure 4.20).
                        
Figure 4.20    Creating Data Type DT_Item


                        Create message type MT_CustomerOrder using the new data type DT_Item (see Figure 4.21).
                        
Figure 4.21    Creating Message Type MT_CustomerOrder


                        Create service interface SIIA_CustomerOrder using message type MT_CustomerOrder. Make sure you change the Category attribute to Inbound, and the Mode of the interface must be Asynchronous (see Figure 4.22). Here, "SIIA" is our naming convention for service interface inbound asynchronous.
                    


Figure 4.22    Creating Service Interface SIIA_CustomerOrder
You've now finished the creation of sender and receiver design objects. The next and final step of this part of the exercise is to construct the mapping and translation of the input message into the output message. For that purpose, you'll create new mapping objects in SWC_MAPPINGS.
You need to create an operation mapping that will be in charge of mapping the inbound service interface operation into the outbound service interface operation. Imagine if you had a service interface with multiple operations instead of only one (like the one in the example); then, you could have many different operation mappings for all of them. You also need to create the message mapping that actually performs the real mapping and message translation tasks in the background.
Because we decided to use the bottom-up approach, start by creating the message mapping and then the operation mapping:


                        Click on Object from the main menu, or press (Ctrl) + (N) to create a new repository object. Click on Mapping Objects and then on Message Mapping.
                    

                        Fill in the following values:
                        

Name: "MM_SIOA_PurchaseOrder_to_SIIA_CustomerOrder" (Another option for a logical name could be, for instance, based on the message types: "MT_PurchaseOrder_to_MT_CustomerOrder"; "MM" is our naming convention for message mapping.)
                            

Namespace: "urn:readersparadise.com:scm:procurement"
                            

Software Component Version: "SWC_MAPPINGS"
                            



                        Click on Create.
                    

                        The new message mapping editor is displayed on the screen. You can now select the source and target messages from the menu; choose the Definition tab and the leftmost button, as shown in Figure 4.23. Select MT_PurchaseOrder from SWCV_READERSPARADISE and MT_CustomerOrder from SWCV_BOOKFOUNTAIN.
                        
Figure 4.23    Selecting Source and Target Message


                        Now that you've selected the correct message types, you can take care of the mapping and transformation. Perform the mapping using drag and drop from source to target. Your mapping should look like the one shown in Figure 4.24.
                    


Figure 4.24    MT_PurchaseOrder_to_MTCustomerOrder Message Mapping
Before you can finish your mapping, you need to perform a final action. As you already may have noticed, the source message contains a complex element called Address, which contains different children elements. On the target side, there is one simple type element (of type string), which carries all address details of an order separated by commas. You have to concatenate the different values contained in the source address into one single field on the target message. You'll use a standard, out-of-the-box function for this purpose. Follow these steps:


                        Drag the concat function (located at the very bottom of the mapping editor) and all necessary source and target fields to the mapping area (see Figure 4.25).
                        
Figure 4.25    Concat Function in Message Mapping


                        Note that you need to add the concat function two times because it only accepts two inputs per function. Double-click on both concat functions, and add a comma as the Delimiter String (see Figure 4.26). When finished, test your mapping by selecting the Test tab and entering some data in the source structure, and then click on the Test button in the lower left part of the screen. If you're happy with the test results of the mapping, then save your work.
                    


Figure 4.26    Delimiter String Parameter in the concat Function
You're only one step away from finishing the exercise for this chapter. Let's see how all the pieces come together when you create the operation mapping:


                        Click on Object from the main menu, or press (Ctrl) + (N) to create a new repository object. Click on Mapping Objects and then Operation Mapping.
                    

                        Fill in the following values:
                        

Name: "OM_SIOA_PurchaseOrder_to_SIIA_CustomerOrder" ("OM" is our naming convention for operation mappings.)
                            

Namespace: "urn:readersparadise.com:scm:procurement"
                            

Software Component Version: "SWC_MAPPINGS"
                            



                        Click on Create.
                    

                        The new operation mapping editor is displayed on the screen. You can now select the source and target service interfaces from the menu; choose the Definition tab and the leftmost button, as shown in Figure 4.27. Select SIOA_PurchaseOrder from SWCV_READERSPARADISE and SIIA_CustomerOrder from SWCV_BOOKFOUNTAIN.
                    

                        Select MM_SIOA_PurchaseOrder_to_SIIA_CustomerOrder as the Mapping Program. Save your work (see Figure 4.27).
                    

                        Go to the Change Lists Overview tab, and activate all change lists for the created design objects.
                    


Figure 4.27    Creating Operation Mapping for Service Interfaces









4.5    Summary
The functionality provided by the ES Repository and its subcomponents (ES Registry and ES Builder) plays a crucial role during the design, creation, and administration of service interfaces. Whether those repository objects are custom built, externally developed and imported, or standard business content delivered by SAP, you need to deal with this multifaceted component of SAP PO. Mastering its tools, knowing when to apply them, and acknowledging the consequences of your choices made during design time will definitely deliver great advantages and put you in control when gluing everything together at configuration time.
This chapter also discussed the unconditional but valuable relationship that exists between the ES Repository and its companion, the ES Registry, when publishing and discovering services. We went through the different categories and types of design objects, from the most common to the very exotic. Now, you should be able to explain all the relevant concepts about the ES Registry and to design and build ES Repository objects.
In the next chapter, you'll learn how to put all the pieces of an SAP PO interface together by exploring the tools and features provided by the Integration Directory.








5    Working with the Integration DirectoryWe shape our buildings; thereafter they shape us.                                                                                             —Winston ChurchillNow that you've learned about basic objects from the System Landscape Directory (SLD) and Enterprise Services Repository (ES Repository), we're ready to use an ingredient—the Integration Directory—to glue everything together to create a ready-to-run interface.In the next sections, we'll provide an overview of the features of the different components that make up the Integration Directory. Each component of the Integration Directory will be explained and its role outlined. The sections also provide several technical step by step guides on how to create and use the different objects.
5.1    Integration Directory Overview
The creation of most interface scenarios in SAP Process Integration (SAP PI) consists of a three-step process: creating SLD objects, creating ES Repository objects, and integrating and configuring all relevant service objects in the Integration Directory. The Integration Directory depends on objects created in the SLD, such as business systems. Furthermore, ES Repository objects—such as service interfaces (outbound and inbound) and operation mappings—are also used in the Integration Directory. The SLD and ES Repository objects are combined together in the Integration Directory to form a specific interface.
Launch the Integration Builder from the SAP Process Orchestration (SAP PO) landing page: http://<hostname>:<port>/dir. From this main page, click on Integration Builder, as shown in Figure 5.1. This will then launch a Java Web Start application.

Figure 5.1    Launching the Integration Directory from the SAP PO Landing Page
The Integration Directory contains a lot of objects. As Figure 5.2 shows, the main screen of the Integration Directory contains the following areas:


Menu The menu contains different tools and options. Here, you can create new objects and launch tools such as the ES Repository.
            

Object types The object types area includes a list of the different object types that can be created in the Integration Directory. To create an object, right-click on the relevant object type, and click New.
            

Editor area The editor area is where all the work is done. When any of the objects on the left side are opened, they are displayed in the editor area. From there, you can edit or change those objects.
            


Figure 5.2    Overview of the Integration Directory: Object Types and Categories
The object types that can be managed in the Integration Directory include party, business system, business component, integrated configuration, configuration scenario, value mapping group, Integration Flow (iFlow), and alert rule. Be aware that the party, business system, and business component are more generally referred to as collaboration profiles.
People familiar with older SAP PI versions (dual stack) might notice in Figure 5.2 that some objects are no longer present in the configuration that used to be available. This includes all objects that were linked to the standard or ABAP-based configuration, such as sender agreements, receiver agreements, and integration processes.
In the next section, we'll explore each of the included objects in detail and explain where to find them.









5.2    Collaboration Profiles
During an exchange of messages between different parties, it's important to be able to label the different entities with an identifier to facilitate the readability of the interface configured in SAP PO.
As the name states, collaboration profiles represent a set of Integration Directory artifacts used to identify and designate the parties and systems involved in an integration scenario. This is irrespective of whether they play the role of sender or receiver in the scenario, which means that the party either sends or receives a message from SAP PO. The collaboration profiles help to uniquely identify an application system or organization taking part in an integration scenario.
The communication profile is made up of artifacts comprising party, communication component (business system and business component), and communication channels. Each of those artifacts will be explored in the following sections.
5.2.1    Party
A party is generally used as an identifier for an organization. If your organization exchanges messages with external companies or business partners, consider using a party to represent the external organization. Parties therefore are mostly used in business-to-business (B2B) scenarios. They represent a higher level of abstraction and a grouping of the real applications participating in a communication. You don't need a party for your own organization; you can instead directly define the communication component without a party.
When naming the party, use a name that is meaningful and represents the actual organization that you're dealing with (e.g., Coca-Cola). You can use internationally recognized identifiers (or alternative identifiers) to guarantee that the party is uniquely identified.
As indicated in Figure 5.3, you can choose the type of unique identifier to be used from the Agency field. You can choose from among the following identifiers:


009 (EAN - International Article Numbering Association)


166 (NMFTA - National Motor Freight Traffic Association)


016 (Dun & Bradstreet Corporation)



Figure 5.3    Alternative Identifier Options for a Party in the Integration Directory
After selecting an agency identifier, the Scheme field will be automatically filled in. Then, the only remaining action is to manually enter the actual unique identifier "ID" (for Integration Directory) under the Name field. You'll need to get the identifier of the company from the relevant agency, based on the chosen agency.

Note
You can also attach communication components under a party.

5.2.2    Communication Component
A communication component represents the real application system involved in an exchange of messages. We can distinguish two main types of communication components: business systems and business components. We'll explore each of those now.
Business System
A business system is created in the SLD and is linked to a technical system in your landscape. When the real application system (of types SAP NetWeaver AS ABAP, SAP NetWeaver AS Java, standalone, or third party) exists in your landscape, it should be considered a business system.
A business system can't be created in the Integration Directory, but you can import it from the SLD by following these steps:


                        Right-click on the left panel or on Communication Components Without Party, and select Assign Business System.
                    

                        Follow the wizard, and you'll be presented with a list of all the business systems present in the SLD (but not yet imported into the Integration Directory).
                    

                        Select the business system(s) that you would like to import into the Integration Directory, and click on Finish.
                    

                        The business system(s) are created, added to a change list, and visible in the Integration Directory.
                    

When you're finished, the created business systems will have an orange circle around them to indicate that they aren't yet activated and are thus invisible to other developers.
Because the business system is defined in the SLD, the type of service interface (message) it can send or receive is controlled and defined from the SLD. While doing the configuration, if you want to be able to select a service interface from a business system, then make sure that the technical system related to the business system in question is linked to the software component (SC) under which the service interfaces are located. This notion of linking the technical system to the relevant SCs was explained in more detail in Chapter 3.
Business Component
A business component can be used to label a virtual business system, which needs to be used in an exchange of messages. The word "virtual" is used here to indicate that it doesn't need to be a physical system in your landscape. It can simply be a logical grouping unit or any other part of your landscape that you would like to label as a logical unit. It can, for instance, be handy to represent an SAP Business Process Management (SAP BPM) process.

Note
A business component doesn't exist in the SLD and can manually and locally be created in the Integration Builder. After you've manually added the business component to the Integration Builder, you need to attach service interfaces (outbound and inbound) to it, which can be used to send and receive messages.

To create a new business component in the Integration Directory, follow these steps:


                        If you want to create the business component as part of a party, then first create the party, and navigate to its communication component (as explained in Section 5.2.1). Then, proceed to step 3.
                    

                        If the business component belongs to your organization and not to an external party, then expand the arrow next to the communication component without a party, as can be seen next to the party named ABC in Figure 5.2.
                    

                        Right-click on the business component and select New.
                    

                        Specify the desired name in the Communication Component field.
                    

After successfully creating a business component, you'll need to maintain outbound service interfaces (under the Sender tab) and inbound service interfaces (under the Receiver tab). Without this step, you won't be able to configure interface flows based on the concerned service interface and newly created business component.
To add a service interface under a Sender or Receiver tab of the business component, follow these steps:


                        Open the business component.
                    

                        Open the Sender tab.
                    

                        Insert a new row, and assign the outbound service interfaces that you want the business component to be able to send.
                    

                        Open the Receiver tab.
                    

                        Insert a new row, and assign the inbound service interfaces that you want the business component to be able to receive.
                    

                        Save and activate.
                    

See Figure 5.4 for an example of what the business component looks like after you've added the needed service interfaces to the Sender and Receiver tabs.

Figure 5.4    Added Service Interfaces (Inbound and Outbound) in the Business Component
5.2.3    Communication Channel
A communication channel can be created for a business system or business component and represents a connection from or to a particular system. When creating a communication channel, you need to provide a unique (and preferably meaningful) name.
Figure 5.5 depicts the different objects in the Collaboration Profile area and how they relate to each other. You can see that business systems and business components can be created under a party (if they are external systems) or within the Communication Component Without Party area. Both business systems and components can contain an unlimited number of channels.
A communication channel has a number of attributes and properties, which we'll explore in Section 5.3.

Figure 5.5    Collaboration Profile Tree
In addition, a communication channel needs to be linked to a communication component (business system or business component). Its name needs to be unique within the communication component to which it belongs. The communication channel contains three main tabs: Parameters, Identifiers, and Modules. These tabs are discussed in the following sections.
Parameters
The Parameters tab mostly contains specific attributes that relate to the adapter used, as follows:


Adapter Type  In this attribute, you select the type of adapter that you need for this specific communication. You can make a selection from a dropdown containing a list of SAP standard adapters. Adapter types from third-party providers (or your own custom adapter) and those that are installed in your system will also be selectable from this list. This adapter list is pulled from the ES Repository in an SAP Basis software component and the http://sap.com/xi/XI/System namespace.
                        Note that the adapter type might have a different version, depending on the version of SAP PO you're running. More details on the different adapter types will be provided in Section 5.3.
                    

Direction  A direction helps to specify whether the connection is used by a sender or receiver system. You can distinguish between sender and receiver channels. Depending on the communication protocol used, a sender communication channel will behave differently from a receiver communication channel. To illustrate, a communication channel reading a file (sender channel) from a file system will contain details such as the directory in which the file is contained, the file name, and the polling interval. In contrast, a communication channel that writes a file (receiver channel) to a file system also needs the folder to write to and the file name but doesn't need a polling interval.
                        A sender channel deals with how to convert an incoming message (from an external system) from another format into a format internally used in SAP PO or SAP PI. A receiver channel deals with converting a message from the SAP PO-specific format or SAP PI-specific format into a format expected by the receiver system. This SAP PO or SAP PI internal format is also referred to as the XI message protocol, which is covered in Section 5.5.
                    

Transport Protocol  Depending on the chosen adapter type, you might be given a choice of different transport protocols. Some common transport protocol choices include HTTP 1.1 and HTTPS. The file adapter, for instance, provides Network File System (NFS) and File Transfer Protocol (FTP) as options.
                    

Message Protocol  The message protocol choices also depend on the adapter type that you selected.
                    

Adapter Engine  This attribute gives you the chance to specify under which adapter engine the channel needs to run. This is very useful if your SAP PO installation operates together with some decentralized adapter engines. You then can choose among the different adapter engines via a dropdown list. If you don't have a decentralized adapter engine, then the default adapter engine will be selected for you by default.
                    


Note
A decentralized adapter engine runs as a standalone engine and provides a totally independent runtime environment. Using a decentralized adapter engine can improve your performance, decrease processing time, and provide runtime isolation.

Identifiers
Identifiers are relevant in cases when a party is involved. As indicated in Section 5.2.1, it's possible to specify various identifiers to uniquely identify the party. When multiple identifiers are used in a party, the communication channel's Identifiers tab enables you to choose which one of the existing identifiers is to be used for this specific communication channel. You can use a dropdown list to select the appropriate agency (see Figure 5.6).

Figure 5.6    Choosing an Identifier in the Communication Channel
Module
This tab enables you to choose the different adapter modules to be executed during runtime. Each module entry in the communication channel is also referred to as a module processor. When a new communication channel is created, it comes with some default modules, depending on the chosen adapter type. The following are a few of the default modules:


CallSapAdapter Mostly present as the first module for the file, Simple Object Access Protocol (SOAP) sender, and Java Database Connectivity (JDBC) adapters.
                    

sap.com/com.sap.aii.af.soapadapter/XISOAPAdapterBean Used for the receiver SOAP adapter.
                    

sap.com/com.sap.aii.adapter.mail.app/XIMailAdapterBean Used for the mail adapter.
                    

RfcAFBean Used for the Remote Function Call (RFC) adapter.
                    


Note
Note that a SOAP adapter (with HTTP) is restricted and can't easily be extended with extra adapter modules. You'll need to use one of the Apache extensible Interaction System (Axis) transport protocol variants to extend it.

In addition to the modules just listed, SAP delivers an additional set of modules by default with an SAP PO installation. See Table 5.1 for a list of some default modules delivered with the adapter framework and their uses.




                                Module Name
                            

                                Use
                            





PayloadSwapBean


                                Swaps the payload with another payload contained as an attachment.
                            



XMLAnonymizerBean


                                Removes namespace or namespace prefix details from the payload or XML.
                            



StrictXml2PlainBean


                                Converts the XML SAP PI payload message into a plain text message.
                            



PayloadZipBean


                                Provides the functionality to zip payloads and return a ZIP file. It can also extract a payload from a zipped file.
                            



TextCodepageConversionBean


                                Converts the current code page of the SAP PI payload to another code page.
                            



DynamicConfigurationBean


                                Enables the manipulation of the dynamic configuration. You directly overwrite some adapter-specific message attributes (ASMAs) with new runtime values.
                            



XiHeaderValidationBean


                                Checks and validates the SAP Exchange Infrastructure (SAP XI) header parameters against the parameter values configured in the communication channel.
                            



Table 5.1    List of SAP Standard Modules and Their Uses
These modules can't be selected from the tab; instead, you'll need to manually enter the name of the module in the Module name field. Names of modules delivered with the adapter framework by SAP are always preceded with the prefix AF_Modules/. For example, to use XMLAnonymizerBean, you'll need to use the module name AF_Modules/XMLAnonymizerBean.
In addition, make sure to choose the Local Enterprise Bean value in the Type dropdown list. You can add as many adapter modules as you need. They will be processed in a sequential order, and the output of one will become the input of the following one.
If you intend to extend the configuration of your communication channel with a list of adapter modules (custom modules or SAP-delivered ones), then it's important to place them in the right sequence and position in the module processor. The decision of where to place your module will depend on the following factors:


                        Whether your communication channel will be supporting a synchronous or asynchronous interface
                    

                        Whether it's a sender or receiver channel
                    

                        Which message protocol is used in the channel
                    

For asynchronous processing, the adapter module is always placed at the end of the chain. For a receiver channel, it's important to first place any other module (customer or provided by SAP). In Figure 5.7, these other modules are represented by modules A, B, and C. Place the adapter module (the adapter module box with the dashed line in the figure) at the end of the chain and just before the adapter
In the case of a sender channel, start by placing all other modules, and leave the adapter module for the end—just before the messaging service.

Figure 5.7    Adapter Module Processor for an Asynchronous Sender and Receiver Channel
For synchronous processing, the same rules apply as for the asynchronous communication. The only difference is that you can place more adapter modules (customer or provided by SAP) after the adapter to handle the response message. As such, all modules before the adapter module will apply to the request message, and the ones after the adapter will affect the response message. Figure 5.8 shows different possibilities of places to position the module, depending on whether it's a sender or receiver channel.

Figure 5.8    Adapter Module Processor and Appropriate Position of Modules for Synchronous Sender and Receiver Channel
For every configured module, you can also add module parameters at the bottom, in the Module Configuration area of the screen.
See Figure 5.9 for an example of the configuration of the XMLAnonymizerBean module. The XMLAnonymizerBean is placed before the adapter module (CallSapAdapter). The module is configured as follows:


Processing Sequence:
                        

Module Name: AF_Modules/XMLAnonymizerBean


Type: Local Enterprise Bean


Module Key: "AnonymizerBean" (You can give it any module key name.)
                            



Module Configuration:
                        

Module Key: AnonymizerBean (This needs to match the one chosen in the Processing Sequence area; you can select it from the dropdown.)
                            

Parameter Name: "anonymizer.acceptNamespaces"
                            

Parameter Value: "http://rojoconsultancy.com/demo/book''
                            




Figure 5.9    Example of XMLAnonymizerBean Configuration
The following statements apply to this module:


                        In some scenarios, you might be required to change the namespace prefix to a specific value. The module is used to change the namespace's prefix of the incoming XML message to another prefix value.
                    

                        In the Parameter Value section, you need to specify the namespace and the prefix to be keep. All other namespaces and prefixes that aren't specified will be removed.
                    

                        The namespace and the prefix are separated with a space.
                    

                        If you don't want a prefix to be present in your output message, use two single quotes ('') as a prefix.
                    

                        You can specify multiple namespaces and prefixes.
                    

                        If the module is used without the anonymizer.acceptNamespaces parameter, then all the namespaces in the incoming message will be removed.
                    

All other namespaces and prefixes found in the message that aren't in the preceding list will be removed.
In the example shown in Figure 5.10, the prefix associated with the namespace http://rojoconsultancy.com/demo/book in the incoming XML message will be removed.

Figure 5.10    JNDI Browser: Overview Screen
As time passes and new versions of SAP PO are released, the number of modules delivered with the adapter framework will probably increase. You can use the Java Naming and Directory Interface (JNDI) to confirm or discover the modules that have been deployed as part of the adapter framework on your SAP PO installation. To do that, follow these steps:


                        Log in to the SAP NetWeaver Administrator via http://<hostname>:<port>/nwa, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
                    

                        Navigate to Troubleshooting • Java, and then click on the JNDI Browser link.
                    

                        On the next screen, enter "AF_Modules" in the Find field. Then, select Context Name from the dropdown of the By field. Click on the Go button.
                    

                        You'll see the results of your search. You need to collapse the AF_Modules result because the adapters delivered with the adapter framework start with the AF_Modules prefix in front of their actual names. Refer to Figure 5.10 as a reference for what the JNDI Browser: Overview screen looks like.
                    

Note that even though a comprehensive number of adapter modules are available, you might come across requirements that aren't supported with the currently existing set of modules. Luckily, you can create your own custom adapter modules. Given that the adapter engine and framework is based on the SAP NetWeaver AS Java, you'll need a basic knowledge of Java to successfully implement your own additional functionality. To facilitate your Java development, you'll need to make use of the SAP NetWeaver Developer Studio as the development tool.
Developing a custom module adapter for SAP PO is beyond the scope of this chapter, but it is possible.
5.2.4    Communication Component without a Party
The decision to choose whether to create a party or a communication component without a party depends on your answer to the following question: Is the application system in question part of your organization or an external organization?
If the application is part of your organization, then use a communication component without a party. Otherwise, use a party. You don't have to stick to this approach, but we believe it's a good way to keep things separate and to easily identify when you're dealing with external systems.
ASMAs are attributes that provide extra information about messages. This information isn't part of the message's payload, but rather is included as header data. Depending on the adapter used, SAP provides the ability to read and write these message header data/attributes. These attributes are different for each adapter type. The details of the attributes available for each adapter can be accessed in the SAP BASIS SC and the http://sap.com/xi/XI/System namespace. You can look it up in the ES Repository.
The attributes are placed under the corresponding adapter type, so to access any attribute related to the file adapter you'll need to use the http://sap.com/xi/XI/System/File namespace. For the JMS-specific adapter attributes, use the http://sap.com/xi/XI/System/JMS namespace.
Some of the attributes of the file adapter include the following:


FileName


FileEncoding


Directory


FileType


SourceFileSize


SourceFileTimeStamp


SourceFTPHost


These attributes can be accessed and manipulated from the mapping by using a user-defined function (UDF). An example of a UDF to overwrite the value in the filename attribute of the file adapter is provided in Listing 5.1.
DynamicConfiguration conf = (DynamicConfiguration) container.getTransformationParameters().   get(StreamTransformationConstants.DYNAMIC_CONFIGURATION);DynamicConfigurationKey fileName = DynamicConfigurationKey.   create("http://sap.com/xi/XI/System/File","FileName");conf.put(FileName, "foo.txt");
Listing 5.1    UDF to Overwrite the Value of the Filename Attribute of the File Adapter
To make the new overwritten filename value affect your communication (receiver), you'll need to activate the ASMA on the communication channel. Doing so will make the receiver communication channel use the new value of the filename attribute to write the file. To do this, follow these steps:


                    Open the communication channel (sender or receiver) in question.
                

                    On the Advanced tab, select the Set Adapter-Specific Message Attributes. See Figure 5.11 for a communication channel configuration example.
                


Figure 5.11    The Adapter-Specific Message Attributes Enabled in the Communication Channel
After activating the Set Adapter-Specific Message Attributes checkbox, all the attributes selected will be available in the dynamic configuration and can be read and modified. The dynamic configuration can then be used to change the name of the file to be written in a receiver communication channel.
As a result of activating the ASMA (see Figure 5.12), the dynamic configuration now contains details about the file name, file size, file type, directory, and timestamp of the file, which were picked up by the file communication channel.

Figure 5.12    Impact of Activating the ASMA on the Dynamic Configuration









5.3    Adapter Types
SAP provides a set of standard connectivity or adapter features. We can classify them in four different categories, which will be explored in the subsequent sections.
5.3.1    Technical Adapters to Enable Communication with SAP or Third-Party Systems
Some of the adapters that make up this category are included in Table 5.2. A short explanation of what they are used for is also included.




                            Adapter Name
                        

                            Short Description and Use
                        





                            File/FTP or FTPS


                            Enables the sending and receiving of file contents. For a sender communication channel, the file should not be read-only.
                        



                            JDBC


                            Enables you to connect to a database system. The adapter is also responsible for converting from the database-specific format to XML and vice versa.
                            You'll need to add the concerned database data drivers.
                        



                            JMS


                            Enables the transfer of data to and from a JMS provider. You'll also need to load and package the necessary vendor-specific JMS drivers.
                        



                            SOAP


                            Makes it possible to consume and provide web services, based on SOAP.
                        



                            HTTP_AAE


                            Transports a message payload in the HTTP body, and the SAP XI message header attributes are moved across as URL parameters. This is a specific HTTP adapter build for the Advanced Adapter Engine (AAE).
                        



                            Mail


                            Enables the sending and reading of emails. It's also possible to use the Simple Mail Transfer Protocol (SMTP) mail server capability to exchange SMS and faxes.
                        



                            Marketplace


                            Enables conversion between SAP XI and HTTP messages containing an MarketSet Markup Language (MML) message.
                        



                            Representational State Transfer (REST)
                        

                            Provides the ability to provision and to consume RESTful-based web services. The adapter was only added in 2015 but since then, it has gained significant popularity among the SAP PI developers due to its rich features and wide scope of application when integrating cloud and application programming interface (API)-based platforms. SAP wrote a helpful series of blogs in which this adapter and some common scenarios are explained step-by-step at https://blogs.sap.com/2014/12/18/pi-rest-adapter-blog-overview.




Table 5.2    List of Technical Adapter Types Available in SAP PO 7.5
5.3.2    Application Adapters to Enable Communication with an SAP System
A couple of options are available to connect to and exchange messages with an SAP backend. Table 5.3 lists the adapters that enable you to achieve the goal of communicating with an SAP application.




                            Adapter Name
                        

                            Short Description and Use
                        





                            RFC


                            Enables the processing and execution of RFCs using the Advanced Adapter Engine Extended (AEX). For a sender communication channel, the RFC adapter can be used to convert RFCs from a sender to XML messages.
                        



IDoc_AAE


                            Facilitates sending and receiving IDoc messages with an SAP applications system. This is a specific IDOC_AAE adapter build for the AAE Java-only stack.
                            The RFC adapter is based on the RFC protocol. In the background, SAP PO converts IDocs to XML messages.
                        



                            Proxy (SOAP with SAP XI 3.0)
                        

                            Depending on the SAP application server used, ABAP or Java proxies can be used to communicate with it. Messages running via the proxy method use SOAP over HTTP.
                        



                            SAP Business Connector adapter (BC adapter)
                        

                            Provides standard connectivity to SAP and non-SAP systems based on SAP XI/SAP PI predecessor's SAP BC 4.7. The SAP BC adapter supports message exchange with IDoc-XML and RFC-XML (with envelope) over HTTP(s) as transport protocol. Only Best Effort (BE) and Exactly Once (EO) Quality of Services (QoSs) are supported.
                        



Table 5.3    List of Adapter Types Available to Communicate with SAP Application Systems in SAP PO 7.5
5.3.3    SAP Industry Adapters
These are adapters responsible for supporting communication with some industry-specific standards. Table 5.4 lists the available adapters and explains the standards they cover.




                            Adapter Name
                        

                            Short Description and Use
                        





                            RosettaNet Implementation Framework (RNIF) 2.0 and 1.1 (RosettaNet)
                        

                            Supports the RNIF standard protocols versions 1.1 and 2.0.
                        



                            Chemistry Industry Data Exchange (CIDX)


                            Supports a standard for the chemical industry and enables the exchange of data between businesses in the chemical industry.
                        



Table 5.4    List of Adapter Types Available to Support Industry Standards in SAP PO 7.5
5.3.4    Third-Party-Developed Adapters
Some SAP partners have developed adapters to cover industry standards that are currently not supported by SAP's set of adapters. Some of these third-party adapter suppliers include Seeburger AG (www.seeburger.com), Informatica (www.informatica.com), and iWay software (http://www.informationbuilders.com). To get more details about the list of adapters provided by each of these companies, check their websites.









5.4    Integrated Configuration
For those familiar with the SAP PI dual stack, you surely remember the days when using the "classic" way of configuring interfaces was the only way to build interfaces. It was necessary to create a number of objects and link them together. These objects included the following:


                Sender agreements
            

                Receiver determinations
            

                Interface determinations
            

                Receiver agreements
            

You don't need to go through that pain anymore—at least if you, like us, are happy to let the technology do as much as possible.
In a single stack, the integrated configuration (ICO) provides an integrated and simpler way to configure your flows to be run on the AAE. Introduced in SAP PI 7.1 EHP 1, the ICO enables the use of the local processing capability of the AEX and provides increased performance. The higher performance of the message throughput is easily achieved by avoiding going through the ABAP stack.
The ICO provides all the features and functionalities that the classic ABAP configuration used to have. See Table 5.5 for the ICO steps and their equivalent classic configuration steps.




                        Integration Configuration
                    

                        Classic (Old) Configuration
                    





                        Inbound processing


                        Sender agreements




                        Receiver


                        Receiver determination




                        Receiver interfaces


                        Interface determination




                        Outbound processing


                        Receiver agreement




Table 5.5    Features of ICO and Their Equivalent Classic ABAP Configuration
On top of these features, ICO includes steps for assigned users and advanced settings.
In the next sections, we'll explore each of these ICO steps and features and will describe their roles.
5.4.1    Inbound Processing
In inbound processing (i.e., how messages arrive in SAP PO), you can specify details such as the following:


Communication ComponentThe sender communication component (or system) is the name of the system responsible for sending the message to SAP PO.
                

Interface/NamespaceThese are the name and namespace of the outbound service interface. Remember that the outbound service interface represents the message that enters SAP PO.
                

Communication ChannelThis is the communication channel used by SAP PO to receive the message.
                

Adapter Type/Adapter EngineThese are the type of adapter used and the adapter engine on which the integrated scenario runs. The Central Adapter Engine is used by default. Note that this section of the processing only displays the data that is already configured in the communication channel.
                

Software Component Version of Sender InterfaceIf the SC containing the service interface has multiple versions, then you can choose the version that you need.
                

Virus Scan This enables you to specify whether the incoming messages need to be scanned for viruses. The possible values include the following:
                    

Use global configuration Use this option if the virus scanning configuration is globally configured (in SAP NetWeaver Administrator). This option is selected by default.
                        

No virus scanning Use this option if you don't want to scan messages for viruses.
                        

Virus scanning by adapter Use this option if you only want a limited set of messages (interfaces) to be scanned for viruses.
                        



Schema ValidationThis enables you to specify whether or not validation of the incoming message or XML is needed. If you decide to activate the validation by adapter, then arriving messages that are intercepted via this integrated configuration will be validated against the outbound service interface used in the ICO. If the message received isn't valid, then an exception is thrown by the adapter engine.
                

Propagate PrincipalThe principal propagation mechanism enables the propagation of authentication to the receiver system by the AEX. Note that this option is only activated for adapters of type SAP XI, RFC, or SOAP.
                

Metering of Service CallsThis only works for ICOs that are based on the proxy (Java or ABAP) runtime or web service runtime. If activated, the AEX starts collecting technical information about the caller application and stores the metering data. The data to be collected is generally provided by the service consumer in the HTTP header or SOAP header of the service call. You can further configure this setting by specifying the following information:
                    

Data transfer scope Tell the system how much data to collect. You can choose minimal data transfer, basic data transfer, or enhanced data transfer.
                        

Transfer protocol Choose whether you want to store data from a transfer using an HTTP header or a SOAP header.
                        



Figure 5.13 shows the configuration possibilities in the inbound processing of the AEX.

Note
When configuring an ICO, you might not be able to find the outbound service interface that you're looking for. In such a case, the following troubleshooting steps might help you solve the problem:


                        For a business system, check the SLD to verify that the technical system linked to the business system has a relationship with the SC to which the service interface belongs. This can be checked under the Installed Software tab after selecting the SC in question.
                    

                        For a business component, open the relevant business component, and verify that the Sender tab contains the outbound service interface that you're looking for. If not, then add the outbound service interface by following the steps in Section 5.3.2.
                    

                        Check that the service interface in question exists in the ES Repository and is configured as an outbound service interface.
                    



Figure 5.13    Example Inbound Processing Configuration in the ICO
5.4.2    Receiver
This step describes the routing conditions and rules based on which SAP PO determines the receiver to which to forward the message.
When determining the receiver system, you can use one of the following approaches: simple receiver and conditions, or enhanced receiver determinations.
Simple Receiver and Conditions
This approach is simple and applies to circumstances in which the routing condition is clear and well-known, such as the following:


                        The routing condition is fixed (e.g., you always forward all incoming messages to system X).
                    

                        The data necessary to compute the routing condition can be found in the incoming message (e.g., if the value of the XML element age is less than 10, then route to system X; otherwise, route to system Y).
                    

In both cases, follow these steps:


                        Go to the Receiver tab of the ICO. Here, select the Standard radio button in the Type of Receiver Determination field.
                    

                        Choose between Operation-Specific or Not Operation-Specific. This choice will depend on whether you have different routing conditions for each operation of your outbound service interface (if so, choose Operation-Specific) or one general routing condition for all operations (if so, choose Not Operation-Specific).
                    

                        Use the condition editor to define the routing condition. Note that XPath expressions are used to specify the condition.
                    

Figure 5.14 shows an example of a routing condition that specifies to route the message to the fictive receiver system called BC_RojoA_send when the value of the CountryName field in incoming messages is France; otherwise, route the message to the BC_RojoB_Recv system.

Figure 5.14    Receiver Determination Routing Conditions in the ICO
Enhanced Receiver Determinations
In some cases, you can't predefine the receiver system during design time. This is typically the case when you're dealing with a more complex routing rule that needs to be based on the content of the input message. In such a case, you would ideally opt for a more dynamic routing condition that will be computed with the help of some external program (e.g., message mapping) during runtime. This is where enhanced receiver determinations come to the rescue. Enhanced receiver determinations can also return a whole list of receivers to which the message needs to be forwarded. The enhanced receiver determination needs an operation mapping, which returns one receiver or a list of receivers. This operation mapping needs first to be created in the ES Repository before it can be selected here. The mapping needs to use the outbound service interface as input and the target inbound service interface with ReceiverDetermination. The ReceiverDetermination service interface can be found in the ES Repository under the http://sap.com/xi/XI/System namespace and the SAP BASIS SC.
To configure enhanced receiver determinations, follow these steps:


                        Go to the Receiver tab of the ICO, and select the Extended radio button in the Type of Receiver Determination field.
                    

                        You're then prompted with a screen that requires you to specify an operation mapping. This is a special operation and message mapping, which needs to return one receiver or a list of receiver systems. See Figure 5.15 for an example of an ICO configured with an extended receiver determination.
                    


Figure 5.15    Extended Receiver Determination Configured in the ICO
You might be asking yourself this question: What will happen when the incoming message doesn't match any of the defined routing conditions? To have robust interface flows, it's important to cover such an erroneous situation. In the Receiver tab, you can also specify how to handle situations in which no receivers can be determined during runtime by selecting one of the following options:


Error Message Use this option to generate an error message when a receiver can't be found. It's then possible to retrigger the message later after you've made a fix.
                    

Ignore Use this option to generate an error if no receivers are found. The flow will then be ignored, and it's not possible to restart or resend the message afterward.
                    

Select the Following Receiver Use this option to specify a sort of catch-all error handling. This basically means that when no receivers can be determined in the runtime, it will forward the message to a default receiver. If you choose this option, you'll be required to specify the default receiver to be used.
                    


Tip
It's important to bulletproof your ICO to limit the number of errors that can be generated in runtime. One of the ways to do this is to ensure that there are routing conditions in the ICO to cover all possible incoming messages.
When deciding to use virus scanning or message validation, be aware of the overhead that might result from that choice.

We now know the system to which the message will be forwarded. The next step is to determine the service interface that the receiver system expects.
5.4.3    Receiver Interfaces
This is an obvious next step because the receiver might not necessarily be able to understand the message format (or XML) sent by the sending system. If the messages on the sender and receiver side are different, a mapping is needed to make the necessary transformations.
The Receiver Interfaces tab makes it possible to specify the mapping program (operation mapping) to be used to transform the outbound service interface (sender message) to the receiver inbound service interface (receiver message). Remember that the mapping program is created from the ES Repository. See Figure 5.16 for an example of how to configure the Receiver Interface tab in an ICO.

Figure 5.16    Example of Receiver Interface Configuration in the ICO
5.4.4    Outbound Processing
The Outbound Processing tab defines how the inbound service interface has to be sent to the receiver system. This step is quite similar to the inbound processing step, but the exact opposite. It includes the same steps as defined in Section 5.4.1. The main difference is that the outbound processing uses a receiver communication channel instead of a sender one.
In addition, the outbound processing provides the option to specify a header mapping. Header mappings provide the flexibility to map or change the following values in outbound processing: Sender Party, Sender Communication Component, Receiver Party, and Receiver Communication Component.
Header mappings are especially useful in a case of a B2B integrated configuration, whereby messages are exchanged across businesses, and people want to replace the business system names used. Depending on the type of adapter used, the details (mostly names) of the SLD business systems might be sent along with the message as part of the header data. In such a situation, it might be useful to change the business system name to a more meaningful one just before sending the message to another business partner. Doing so typically separates the business system names used internally and externally, which is a very handy feature.
The values to be used for the mapping can be fixed target values, which are values coming from parties or communication components defined in the Integration Directory. It's also possible to get values from the message payload by selecting the arrow beside the Input Help icon and choosing Extended. You'll then be presented with the expression editor, which will allow you to build or specify an XPath expression.

Note
Not all adapters provide the functionality to perform header mapping. As it stands, the following adapter types support header mapping in the AEX:


                        IDoc adapter (AAE)
                    

                        RNIF adapter 2.0
                    

                        RNIF adapter 1.1
                    

                        CIDX adapter
                    

                        HTTP adapter (AAE)
                    

                        SOAP adapter with XI 3.0 message protocol
                    

                        REST adapter
                    


Figure 5.17 shows outbound processing configuration in the ICO.

Figure 5.17    Outbound Processing Configuration in the ICO
Assigned Users
This tab facilitates the specification of service users authorized to call this service. You can add as many users as are required in the tab. Note that this is a restriction list, which lists the users that are allowed to call the service in the runtime environment. No omitted users are allowed to call the service. This feature is particularly interesting when configuring a B2B scenario. It's also possible to restrict the users allowed to call this functionality from the communication component (business system or business component). In a case in which users are also specified in the communication component, it's important to ensure that the list of users specified in the ICO is aligned with the list specified in the communication component.
If no users are specified in the Assigned Users tab, then there are no authorization checks performed to restrict access, and all users will be authorized. This is the default setting.
Advanced Settings
The Advanced Settings tab is meant to provide extra control over saving message versions and logging configuration at runtime. You can specify for which steps of the message pipelining messages need to be stored for administration or troubleshooting purposes.
This tab provides two main options for tuning the saving of message versions:


Staging  Staging allows you to save message versions at each step of the message pipeline. You can then edit the message at each stage and resend or restart the edited message. You'll need to change the Staging radio button to Use scenario-specific configuration to specify these settings for this specific ICO. You can choose from None, Save on error, and Save.
                    

Logging  You can also specify how much logging needs to be written for each step of the message runtime pipelining. You can choose from None, Log, Log on error, Log without payload, and Log on error without payload. Figure 5.18 shows what the screen looks like and the available options.
                    


Figure 5.18    Advanced Settings of the ICO: Staging and Logging

Note
You can globally configure the logging and staging of messages. In general, you want to keep the global logging activities to a minimum to save memory or database resources. That is why the Advanced Settings tab of the ICO is so useful: it enables you to (temporarily) configure and increase these logging settings for a specific ICO instead of doing so for the entire server, which is a handy feature when troubleshooting.

Some of the ICO features that we explored also represent the pipeline steps of the AEX. Pipeline steps representing the different sequential steps of processing a message in the AEX are shown in Figure 5.19, which depicts and summarizes the main pipeline steps and their execution order during runtime.

Figure 5.19    Summary of the Runtime Pipeline Steps Resulting from an ICO









5.5    The XI Message Protocol
It's important to take a look at the workings of the internal message protocol format used in the AEX. This format is often referred to as the XI message protocol. This section will explore the XI message protocol from a high-level view.
When choosing a message format to use internally, SAP needed to pick one that was using a standard and from which it could easily translate messages back and forth to other formats. The XI message protocol is based on a standard that uses HTTP, HTTPS, and XML. When messages arrive in the AEX, they are converted from whatever format they arrive in to the XI message protocol. When messages need to be sent from the AEX to an external system, they are converted from the XI message protocol to whatever other format they need to arrive in. These conversions to and from the XI message protocol are taken care of by the adapter engine.
The XI message protocol is based on the W3C SOAP Messages with Attachments standard. It's therefore made of three main components: SOAP header, body, and attachments.

Note
We're not going to detail what a SOAP message is in this chapter because it's assumed that you understand the standard. However, if you need further information about this topic, visit the W3C website (www.w3.org).

Even though the XI message protocol is based on the SOAP standard, there are some important differences:


Header In SOAP, the header element is optional, but in the XI message protocol, it's mandatory.
            

Body In SOAP, the body contains the message payload (the real XML message), but in the XI message protocol, the body only contains a reference to the actual payload.
            

Attachment In SOAP, the attachments contains attachment files, but in the XI message protocol, the message payload (the real XML message) is placed as the first attachment. Other attachment files are placed in the second attachment position.
            

Figure 5.20 provides a graphical illustration of the structure and composition of the XI message protocol.

Figure 5.20    Composition of the XI Message Protocol
The XI message format can be generated and used by both SAP ABAP (SAP backend) and Java-based systems. This message format provides a huge benefit because the same message format is used everywhere in a consistent manner.









5.6    Configuration Scenario
After you've configured different Integration Directory objects, you might need to logically group them together, for example, if the different interfaces are part of the same business process or scenario. You can think about this grouping as a folder in your file system that contains objects that logically belong together.
Typically, you'll want to include ICOs and the objects that they depend on, such as communication components and communication channels. You can then transport a configuration scenario and thus transport all objects included in it.
When you create a new configuration scenario, you can choose to create it from scratch (manually) or create it based on a model in the ES Repository.
5.6.1    Creating a Configuration Scenario from Scratch (Manually)
You can manually create a configuration scenario from the Integration Directory (see Figure 5.21) by following these steps:


                    Launch the Integration Directory from the SAP PO landing page.
                

                    Select the configuration scenario object group, right-click, and select New.
                

                    In the Type of ES Repository Model field, select the No model radio button, and then click on the Create button.
                

                    Specify the name, description, and folder (optional) for your new configuration scenario.
                

                    You'll then see a new object. Go to the Objects tab.
                

                    Click on the Add object(s) to Scenario button in the top-left menu.
                

                    Choose the category of the object that you want to add to the configuration. You're then prompted with a new screen that allows you to select the object.
                

                    Save and activate the configuration scenario.
                

Note that you can also remove the object by selecting it and clicking on the Remove Object(s) from Scenario button.

Figure 5.21    Configuration Scenario Screen in the Integration Directory
5.6.2    Creating a Configuration Scenario from a Model
If you used a model (process integration scenario) in the ES Repository to represent your scenario, then you can use it as a basis for creating a configuration scenario. To create a new configuration scenario based on a model, follow these steps:


                    Launch the Integration Directory from the SAP PO landing page.
                

                    Select the configuration scenario object group, right-click, and select New.
                

                    In the Type of ES Repository Model field, select the Process Integration Scenario radio button, and click on the Create button.
                

                    You're then presented with the option to choose a model to reference. Select the appropriate integration process from the ES Repository, and click on the Create button.
                

                    Save and activate the configuration scenario.
                










5.7    Value Mapping
By now, you've become comfortable with the notion that an enterprise service bus (ESB), such as SAP PI or the AEX, is used to enable the exchange of messages between two or more systems. The messages contain business data that the sender system wants the receiver system to become aware of.
The data to be exchanged isn't always represented in the same manner in the sender and receiver systems. System X could be using values such as male and female to represent an employee's gender, whereas system Y could be using numeric values instead, such as 1 for male and 2 for female. Typically, when a message containing employee data has to be exchanged between these two systems, a translation of those two ways of representing the same data needs to be performed. The value male from the source system will need to become 1 in the target system. This form of translation is called value mapping in SAP PI or SAP PO. SAP PO is equipped with three core ways to achieve value mapping:


                Use if/else logic (see Figure 5.22)
            

                Use the fixed values function


                Use the value mapping function
            

In addition to these three methods, you can also use SAP Business Rules Management (SAP BRM) to achieve data translation, which is discussed in Chapter 13. The next section will explore each of the previously listed value mapping methods.
5.7.1    If/Else Logic
In this method, you'll implement some conditional logic to accomplish the value translation. This can be achieved purely from a message mapping or via a UDF.
As Figure 5.22 shows, this can prove to be a cumbersome and difficult-to-read approach. It's especially not a suitable approach if you're dealing with a large amount of values to be translated.

Figure 5.22    Cumbersome Way to Achieve Value Translation with If/Else Logic
5.7.2    Fixed Values
As its name states, fixed values are intended to enable the translation of fixed values that very rarely change. Fixed values also generally contain a finite or small set of data. Fixed value mapping is maintained in the ES Repository and is often used in message mapping (see Figure 5.23).

Figure 5.23    Fixed Values Table Example in the ES Repository
To add fixed values, you'll need to be in a message mapping (in the ES Repository) and to select it from the set of SAP-provided functions, under Conversions • FixValues.
As Figure 5.23 shows, these particular fixed values contain a translation for industries. The source system contains industry data and their names, whereas the target system requires numeric values for each of the industries.
Some of the disadvantages of using the fixed value mapping include the following:


                    Maintained in the message mapping, which implies that a transport is needed with every change made
                

                    Lack of flexibility because only fixed values can be used
                

                    Can't be called outside of the message mapping in which it was created and can't be reused
                

5.7.3    Value Mapping
Value mapping can be used to translate different representations of the same data in different contexts or systems using a dynamic method (see Figure 5.24). The data is saved in the SAP NetWeaver database internal table.

Figure 5.24    Example of a Value Mapping That Converts One Value (Color) to Another Value (Number)
Value mappings are loaded in the cache during runtime, which means that value mapping is a very fast method to achieve data translation and is better suited for the job when the data to be translated is subject to frequent changes. It's better than the fixed value mapping because the data is maintained in the Integration Directory and can (in theory) be changed without the need for transport.
In value mapping, the data is categorized under agencies and identification schemes. The agency and scheme will need to be defined for the source and target system. Therefore, you can create different representations and groupings of data.
There are two main approaches to populating value mappings:


Manual approach Select the required value mapping category (in the Integration Directory), and add a new value entry or update an existing one.
                

Replication from an external source With this approach, the translation table already exists in some other source (e.g., in SAP ERP), and you want to copy or replicate the data to a value mapping. The data replication is made possible via a standard interface.
                

In SAP PO, value mapping can be used by different mapping programs. With the message mapping, for example, you can make use of standard functionality to call value mapping from your mapping by choosing Conversions • Value Mapping. You then need to configure the agencies and schemes to match the ones that you configured in the Integration Directory.









5.8    Business-to-Business Integration
For any business to succeed, it needs to keep doing business with its business partners and customers. In today's digital world, doing business involves exchanging data via interfaces or services. In some cases, these interfaces go across a company's network boundaries. Processes such as procure-to-pay and order-to-cash between different trading partners are just two examples of B2B scenarios. In most cases, the messages to be exchanged in B2B scenarios follow some standards in terms of the protocols used and the types of messages exchanged.
In the previous release of SAP PI, there were no SAP-provided B2B capabilities. We needed to rely on third-party adapters (installed on SAP PI) to provide the needed B2B functionalities. However, SAP recently introduced Electronic Document Interchange (EDI) capabilities and technical adapters to SAP PO. In the next sections, we'll give a high-level overview of SAP PO's B2B integration capabilities.
5.8.1    Business-to-Business On Premise
SAP released the B2B add-on and the secure connectivity add-on (SFTP PGP) to run on SAP PO. Note that these B2B add-ons aren't installed by default—you need to perform additional steps to make them available in your SAP PO installation. The B2B add-on includes a set of technical adapters, such as Odette FTP (OFTP), Applicability Statement 2 (AS2), and Secure FTP (SFTP), to enable exchange of EDI messages. On top of these adapters, a number of modules are also provided to facilitate the transformation of EDI formats to XML and the other way around.
To further simplify the development effort and reduce the total cost of ownership (TCO), the B2B add-on comes equipped with standard B2B mapping functions. These are EDI-specific mapping functionalities available to use in the ES Repository.
Other provided functionalities include the following:


Number range objects Automatically insert sequential continuous numbers.
                

Mapping templates Predefined mappings to transform different EDI formats.
                

Rapid-deployment solutions A set of service interfaces and mappings for industry-specific processes.
                

5.8.2    Business-to-Business Managed Services
In addition to on-premise B2B capabilities, SAP now also provides an on-demand or cloud solution. In this approach, SAP hosts the infrastructure, integration service, monitoring, and maintenance. This model brings all the benefits of using the cloud and dramatically reduces the TCO.
5.8.3    Trading Partner Management
SAP B2B Trading Partner Management (SAP B2B TPM) is a platform to support B2B EDI by maintaining information about your trading partners in a centralized manner and by simplifying the process of communicating with your trading partners.
To access SAP B2B TPM, follow these steps:


                    Make sure that your user has the SAP_PI_B2B_SUPERADMIN_J2EE role assigned.
                

                    Launch the B2B Integration Cockpit (see Figure 5.25) by going to http://<hostname>:<port>/b2bic.


                    Click on Trading Partner Management to get to the SAP B2B TPM tool.
                


Figure 5.25    The New B2B Integration Cockpit
There are a couple of other important SAP B2B TPM notions to grasp:


TPM template Represents reusable custom forms that you can create to store data for a specific business requirement.
                

TPM functional profile Used to group different SAP B2B TPM templates to reuse them across different partners.
                

Trading partner profile A one-stop shop to access different partner information and configurations, such as partner name, partner type, classification details, and so on. Information related to partner certificates, functional profiles, agreements specified for a particular trading partner, and some EDI runtime parameters also can be accessed.
                

Trading partner agreement Define rules and conditions that are evaluated during runtime to determine which EDI parameters and functional profiles need to be used.
                

UDFs Standard functionality to retrieve the runtime values of some SAP B2B TPM parameters. Some of the provided UDFs include getParty, getAgreementID, getFunctionalProfileName, getFunctionalProfileProperty, getIdentity, getSystemEnvironment, and getPartyID. For more on each of these UDFs, please check http://help.sap.com.
                

We're going to revisit the notion of adapters in the next section by touching on the often-forgotten SAP PI support for the Apache Axis framework, to further enhance the SOAP adapter. The next section will explain how the Axis framework can be leveraged and configured from the Integration Directory.









5.9    Axis Framework
The Apache Extensible Interaction System (Axis) framework used in SAP PO is based on the Apache Axis framework.

Note
Visit http://axis.apache.org/axis to read more about Axis.

With SAP PO, you can leverage the features and functionalities of the Axis framework version 1.4 in your SOAP-based or JMS-based scenarios. Compared to the standard SOAP channel, an Axis-based SOAP channel is equipped with functionalities such as the following:


                Message protocols SOAP 1.1 and SOAP 1.2
            

                Transport protocols HTTP/S, SMTP, and file
            

                Different user authentication procedures (basic, digest, NT Lan Manager, SAP assertion tickets)
            

                Different encapsulation formats (Multipurpose Internet Mail Extensions [MIME], Direct Internet Message Encapsulation [DIME], Message Transmission Optimization Mechanism [MTOM])
            

                Ability to add your own Axis handlers to the module chain by using the HandlerBean module
            

                Support for WS Security
            

                Support for WS Addressing features
            

                Ability to receive SOAP messages using JMS
            

                Posting of plain HTTP requests (REST)
            

                S-Security with Security Assertion Markup Language (SAML)
            

                Ability to extend the Axis framework functionality with your own custom Axis handlers
            

Note that there are many more functionalities than those listed here. It's important to be aware that the Axis framework isn't installed by default on your SAP PO server, so you'll need to perform additional actions to install and configure it. The installation of the Axis framework is a prerequisite for configuring and running it. We won't focus on the installation part in this chapter but will instead focus more on some of the configuration parts. However, to install the Axis framework, you need to add additional JARs and modify the description file in com.sap.aii.af.axisproviderlib.sda. The additional JARs include the following:


axis.jar


commons-discovery-0.2.jar


commons-logging-1.0.4.jar


commons-net-1.0.0-dev.jar


wsdl4j-1.5.1.jar


After adding the JARs, you'll need to redeploy com.sap.aii.af.axisproviderlib.sda to your SAP PO server.
For extended details of the Axis framework installation, refer to SAP Note 1039369. After installation, you can check and verify if the Axis framework was correctly installed by going to http://<hostname>:<port>/XIAxisAdapter/MessageServlet, where <hostname> is the hostname of your SAP PO system, and <port> is the port number.
If the installation was correctly performed, then you should get a page with a Status of OK (see Figure 5.26).

Figure 5.26    Axis Framework Installation Status Page
To illustrate the setup of an Axis-based channel, we'll consider a sender SOAP communication channel as an example. To set up a sender communication channel, follow these steps:


                Choose the SOAP adapter type in the Adapter Type field.
            

                Select Servlet (Axis) for the Transport Protocol.
            

                Make sure that Message Protocol is set to Axis.
            

                Configure the rest of fields per your requirements. They are similar to any other communication channels. You then get a channel with a Parameters tab similar to the one shown in Figure 5.27.
                
Figure 5.27    Example of a Sender Communication Channel Configured with the Servlet Axis


                Depending on your requirements, you might need to make additional changes in the Module tab, in addition to the preceding steps. See Figure 5.28 for an example of a sender communication channel configured to support WS-Security.
            

Refer to SAP Note 1039369 for more details about the Axis framework implementation.

Figure 5.28    Example of a Sender Channel Configuration Using the Axis Framework to Support WS Security and WS Addressing









5.10    Representational State Transfer Adapter
The Representational State Transfer (REST) adapter makes the standard collection of technical adapters provided by SAP PI complete. Before its existence, developers had to find support for RESTful web services using the Axis framework or third-party adapters. REST web services can be an excellent choice when integrating applications in a lightweight and flexible manner because they remove the burden and complexity imposed by traditional SOAP web services. It's out of the scope of this book to explain the complete architecture background of when to use REST or not, but we've provided an overview with some important advantages of REST.

REST Advantages
The advantages of using REST are as follows:


                    Lightweight, robust, and secure web services for enterprise integration
                

                    Approximately 75% of existing APIs use REST web services
                

                    XML or JavaScript Object Notation (JSON) as payload and over HTTP(S) as transport protocol
                

                    Consumption and provisioning of OData services without need to introduce additional components, which simplifies your system landscape
                

                    No special/expensive tools needed to edit and test; a web browser can be used
                

                    Flat learning curve (i.e., easy to learn)
                

                    Widely adopted as open source architecture style
                


The REST adapter comes in sender (see Figure 5.29) and receiver (see Figure 5.30) flavors and supports dynamic URLs, multiple (CRUD) operations per communication channel, XML and JSON data formats, and configurable character sets.

Figure 5.29    Example of a REST Sender Communication Channel

Figure 5.30    Example of a REST Receiver Communication Channel
An overview with the features of this adapter is provided in Table 5.6.




                        REST Adapter Features
                    

                        Notes
                    





                        Consumption and provisioning of REST-based web services
                    

                        Support of XML, JSON, and unstructured text message formats over HTTP(S)
                    



                        Support of BE and EO and Exactly Once in Order (EOIO) QoS
                    

                        QoS BE, EO, and EOIO
                    



                        Payload format convertor from XML to JSON and vice versa
                    

                        Conversion is done by the channel. The conversion can also be applied for the response of synchronous calls.
                    



                        Fixed and dynamic URL part that allows you to support multiple REST operations with one single communication channel
                    



                                Example fixed URL:
http://<myHost>:<myPort>/RESTAdapter/api/supplier




                                Example dynamic URL:
../RESTAdapter/api/{party}/{id}?operation={function}






                        Fixed and dynamic URL part that allows you to support multiple REST operations with one single communication channel (Cont.)
                    



                                Could result in this endpoint:
../RESTAdapter/api/vendor/abc123?operation=create
                                or
../RESTAdapter/api/vendor/abc123?operation=delete






                        Content-based and HTTP-operation based communication channel determination
                    

                        The following options can be used to determine the communication channel:
                        

                                Payload content
                            

                                HTTP operation
                            

                                Fixed and dynamic part of URL
                            





                        Secure services using client certificate authentication, basic authentication, OAuth 2.0 (SAML bearer assertion)
                    



                                OAuth: SAML bearer token authentication
                            

                                Transport Layer Security/Secure Sockets Layer (TLS/SSL) authentication (client basic and client/server certificates)
                            





                        Extract information from message payload, URL and HTTP headers
                    

                        The adapter extracts this information and stores it in custom or predefined variables that can be used later while processing the interface, for example, operation/message mappings, and so on.
                    



Table 5.6    Features of the REST Adapter
The next section will focus on how to manage alerts if problems occur in your SAP PO interfaces.









5.11    Message Alerting
SAP PO has a feature to alert concerned users and administrators when technical problems occur in the server available in its platform. Message alerting is based on defining alert rules. An alert rule in SAP PO helps configure the rules, circumstances, and conditions under which an alert needs to be created. Most of the time, these conditions define a technical error. Messages going through the integration layer of SAP PO are checked against the conditions defined in the alert rulesets. If a match is found, then an alert is generated and triggered. These triggers are sent to interested administrators, users, and applications. You might need to define multiple alert rules to enable sending different types of technical errors to different interested parties.
5.11.1    Alert Rule Overview
An alert rule contains the following main information:


                    Integration Directory objects, such as communication components, parties, ICOs, and configuration scenarios
                

                    The impacted runtime components and systems, including integration server(s) and business systems
                

                    Message statutes, enabling you to choose what type of message statuses you want your alert rule to report on
                

                    List of subscribed applications (called alert consumers) that have registered to consume the alerts of the rule
                

Figure 5.31 shows a summarized illustration of process steps involved when dealing with message alerting. SAP PO also provides an API that allows you to write external custom applications to consume the alerts generated in SAP PO.
In SAP PO, you can use either component-based message alerting or "classic" message-based alerting (available only in the ABAP stack). We'll focus on the recent component-based message alerting because it's more suited for a Java-only installation.
To support this alert mechanism, SAP PO includes an alerting infrastructure that uses the following components:


                    A central configuration in which users can create alert rules. The alert rules need to be configured for each SAP PI domain; the created alert configurations are in the Integration Directory.
                

                    A local alert engine is present in each SAP PI runtime component and AAE. The alerts triggered by the local alert engine are stored in a local alert store.
                

                    Applications interested in consuming the generated alerts are also referred to as alert consumers. Alert consumers can read alerts from the local alert store and send notifications via email, fax, or SMS. The alert store contains a substore for each registered alert consumer, so each consumer reads alerts from its own alert inbox.
                    
Figure 5.31    Process Flow and Components of Rule Alerts


It's also possible to configure SAP Solution Manager as an alert consumer, which means the alerts generated in SAP PO will be present in SAP Solution Manager. The advantage of doing this lies in SAP Solution Manager's central monitoring capabilities. SAP Solution Manager has a well-integrated solution to deal with alerts generated by SAP PO, and it can read, aggregate, and display the alerts in a web-based user interface.
An alert rule object can be accessed in the Integration Directory and points to other Integration Directory objects that are included in its configuration. For the configured alert rule to start sending alerts, it needs to be activated. After activation, a runtime version is created, and the evaluation of conditions starts.
With SAP PO, we no longer need the alert rule based on the ABAP stack that used to be in the older version of SAP PI. It's now based on a Java stack and leverages the AEX.

Note
The alert rule only concerns the SAP PI or the AEX part of SAP PO. SAP BPM processes aren't taken into account by the alert rules.

You can create as many alerts as you wish. It's important to note, however, that SAP PO has a special type of alert rule generally referred to as the default rule. It doesn't exist by default and needs to be created (we explain this in Section 5.11.2). Its creation requires taking into consideration the following special set of rules and behaviors:


                    During the creation of the default alert rule, the name DEFAULT_ALERTRULE is automatically used and is a read-only field. Note that the name needs to be exactly as shown here and is case sensitive.
                

                    The default rule doesn't have configuration objects assigned to it. It's read-only, and you can't add Integration Directory objects to it.
                

                    The default rule will automatically apply to all messages, irrespective of their statuses.
                

                    It's possible to remove consumers to the default rule and select which runtime components will be affected by it.
                

When a default rule is present in your SAP PO installation, the alert engine will use it to evaluate all messages and create alerts. See Figure 5.32 for an alert rule configuration example.
An alert rule (nondefault alert) has the same behaviors as any configuration object and can be created, updated, deleted, and activated. Any change or update to an existing rule (such as the removal of affected configuration objects) will only take effect after the changes made have been activated using a part of the change list in the Integration Directory. You might wonder what will happen to consumer applications after a rule is deleted; luckily, there is a mechanism in place to inform all consumers after the activation of the deletion.
Now that you're familiar with the basic notions of alert rules, the next few sections will explore how to perform actions such as their creation and deletion.

Figure 5.32    Process Flow of Alert Rules and Their Components
5.11.2    Creating an Alert Rule
There are two ways to create and maintain an alert rule: via the SAP NetWeaver Administrator or via the Integration Builder.
Via the SAP NetWeaver Administrator
To create a new rule via the SAP NetWeaver Administrator, follow these steps:


                        Log in to SAP NetWeaver Administrator, and navigate to the SOA tab. Select the Monitoring tab, and click on Message Alert Configuration.
                    

                        Click on the New button on the top-left side of the toolbar.
                    

                        You'll see a menu from which you can choose either Alert Rule or Default Alert Rule. Note that both Alert Rule and Default Alert Rule are rules bound to specific messages or interfaces as follows:
                        

                                The default alert rule is unique and is automatically created with the standard name DEFAULT_ALERTRULE. Furthermore, the name and description can't be changed. Also note that you can't freely assign configuration objects to the default alert rule, and it applies to all message statuses. However, you can specify runtime components and add consumers.
                            

                                When creating an alert rule, you're given carte blanche to define the name and description to suit your needs. As opposed to the default alert rule, an alert rule is meant to be more specific.
                            



                        From the General tab, give a name and description to your rule. Additionally, fill in the following fields:
                        

Enabled Set whether the alert should be enabled right away. You can disable an alert at any point by changing this value. Enabling the alert is an important step because only when it's enabled can it be activated or deployed to runtime.
                            

Payload in Alert Set to enabled or disabled depending on whether you want the payload (actual XML message) to be included in the alert or not. Enabling the payload requires (as a prerequisite) the user-defined search capability to be configured.
                            

Severity Specify the severity of the alert (Low, Medium, High, or Very High).
                            

                        Note that it's not possible to change the name or description for the default alert rule.
                    

                        In the Message Header Rules tab, click on the Add button to include the Integration Directory configuration objects in your rule. You'll see another submenu with different Integration Directory categories (Party, Integration Flow, Service Interface, Integration Flow, etc.). After selecting a particular category, you'll see a pop-up in which you can select the actual object. Note that this tab is read-only for the default alert rule.
                    

                        In the Components tab, you can select the runtime components to be affected by the alert rule.
                    

                        In the Message Statuses tab, you can select which types of errors should trigger an alert. The error statuses are grouped and categorized by components. This is an extensive list, containing categories such as Channel, Adapter Type, Runtime, Validation, Virus Scan, and so on. Make your selections per your requirements.
                    

                        Save your settings.
                    

                        After saving, you can check the consistency of your rule. The alert rule will be internally tested to check for errors. In there are errors, you'll see a message at the top of the page
                    

                        Activate the rule. After activation, the rule will be pushed to the different runtimes. The activation is an asynchronous process. After a successful activation, the rule becomes green. The status of the rule activation can be further checked in the General tab of the alert rule.
                    


Note
An alert rule must contain at least one Integration Directory configuration object.
After selecting an entry in the Message Header Rules tab, you can click on the Show Message Header Rules button to see directory objects that have been added to the rules. These are the objects that alerts will be generated on.

Be aware that all the alert rules created in SAP NetWeaver Administrator are also available from the Integration Directory.
Via the Integration Directory
To create an alert in the Integration Directory, follow these steps:


                        Launch the Integration Directory from the SAP PO landing page.
                    

                        Right-click under the Alert Rule section, and click New.
                    

                        From here, follow steps 3 to 10 as described for the SAP NetWeaver Administrator.
                    

See Figure 5.33 for an example of what an alert rule looks like in the Integration Directory.

Figure 5.33    Alert Rule View from the Integration Directory
5.11.3    Editing or Deleting a Rule
Based on your situation, you might need to change an existing rule or completely remove it. To update or delete existing alert rules from the SAP NetWeaver Administrator or the Integration Directory, follow these steps:


                    From the SAP NetWeaver Administrator, navigate to SOA • Monitoring, and click on the Message Alert Configuration link.
                

                    The screen that appears provides a list of all existing alert rules. From this list, select the desired rule, and click on the Edit or Delete button.
                

From the Integration Directory, the alert rule can be updated or deleted like any other configuration object.









5.12    Publish the Service in the Services Registry
After you've successfully created an ICO, you might need to publish it as a service in the Services Registry. As mentioned elsewhere in this book, you can think of the Services Registry as a yellow pages of services, from which a service consumer can discover existing services in your landscape and therefore be able to consume them. This is especially relevant for SOAP-based services.
As a prerequisite to publishing services, the Services Registry must be configured. However, this section won't focus on how to configure the Services Registry. For more information about how to configure and set up the Services Registry, see Chapter 18, Section 18.4.
Assuming that the Services Registry is correctly configured and running, you'll need to perform the following steps to publish your service:


                Launch the Integration Directory from the SAP PO landing page.
            

                Select and open the ICO related to the service that you would like to publish.
            

                From the top menu, select Integrated Configuration and then Publish in SR.
            

                In the pop-up screen, click on Publish.
            

After following the preceding steps, you should now be able to find your service in the Services Registry. It's also possible to publish the service from the Services Registry instead of from the Integration Directory; refer to Chapter 18, Section 18.4 for more details.









5.13    Integration Directory Programming Interface (Directory API)
The AEX is equipped with a web services API. These web services can be configured and used to create or modify objects in the Integration Directory of your SAP PO installation. The API covers nearly all aspects and functionality of the Integration Directory. These web services are based on APIs that have been implemented on the Java stack, and their Web Service Description Languages (WSDLs) can be located in the ES Repository or web service runtime.

Note
The current implementation of this API limits you from creating or changing any folders in the Integration Directory. However, you can assign configuration objects to a folder.

The consumption of the web services is limited to users with the roles SAP_XI_API_DISPLAY_J2EE and SAP_XI_API_DEVELOP_J2EE. Make sure that your service user is assigned these two roles. You can assign these roles via the SAP user management engine (UME) of your SAP PO installation, which can be accessed via http://<hostname>:<port>/useradmin.

Figure 5.34    Location of Service Interface API in the ES Repository and Included Operations
The web service APIs can be found in the ES Repository under the http://sap.com/xi/BASIS namespace and the SAP BASIS 7.50 SC. Note that the SWCV can be different, depending on your SAP PO version, but it will always be in the format SAP BASIS 7.xx. See Figure 5.34 for an example of the location of the service interface API used for the communication channels. The inbound service interface is called Communication ChannelIn and contains operations such as Create, CreateFromTemplate, Change, Read, Delete, Query, Check, OpenForEdit, and Revert. The names of these operations are fairly self-explanatory in terms of their usage.
The service interfaces located in the ES Repository are fully functioning web services. You can download their WSDLs from the SAP NetWeaver Administrator, and they are ready for you to test or call them with your choice of SOAP client. You can obviously also call them from an external application.
For the sake of simplicity, we'll use the SOAP client embedded in the SOA section of the SAP NetWeaver Administrator. To test the communication channel web service, follow these steps:


                Log in to SAP NetWeaver Administrator via the link http://<hostname>:<port>/nwa.
            

                Navigate to SOA • Application and Scenario Communication.
            

                Click on the Single Service Administration link.


                On the next screen, enter the name of the service interface of the API ("CommunicationChannelIn") in the Find search box, and click on the Go button.
            

                You'll see one entry returned from your search; select it. From the screen that then appears at the bottom, select the Configuration tab. Figure 5.35 shows how the screen setup should look.
            

                In the bottom screen, select the WDSLs tab, and click on the Test button to navigate to the Web Services Navigator Test tool.
            

                On the next screen, you need to select an operation to be called. Select the Query operation, and click on Next.
            

                On the new screen, you can specify the input parameters for the service call. Given that it's a query operation and we want the full resultset (with all communication channels), leave the request as it is, and click the Next button.
            

                On the next screen, you're prompted to log in. After inputting the correct login details, you'll get the result shown in Figure 5.36, which is a response containing 66 communication channels.
                
Figure 5.35    Search Result of the Inbound Service Interface API for the Communication Channel



Figure 5.36    Response Containing a List of Communication Channels as a Result of the API

Note
You can download the WSDL to call the web service via an external tool. In that case, click on ZIP Download as shown earlier in Figure 5.35.

For illustration purposes, we chose the communication channel API, but there are many other APIs that cover functionalities such as alert rule, change list, communication channel, communication component, communication party, configuration scenario, direct connection, ICO, receiver rule, and value mapping.









5.14    Exercise: Working with the Integration Directory
After reading this chapter, you should be familiar with the key notions and concepts of the Integration Directory. We'll build from the same exercise that was started in Chapter 3 and continued in Chapter 4. In those exercises, a bookstore called Reader's Paradise required an interface to assist in the ordering of books from its main supplier, Book Fountain.
5.14.1    Exercise Description
Following is some additional information and requirements about the type of system connectivity used on the interface's sender (Reader's Paradise) and receiver (Book Fountain) sides:


Reader's Paradise (sender system) Reader's Paradise will be using a portal to enter the orders. The portal system is capable of calling web services (SOAP), and it's the preferred connectivity for the organization.
                

Book Fountain (receiver system) Book Fountain uses an older system to receive purchase orders from its customers. The system can only be integrated via an FTP server. The FTP server details are as follows:
                    

                            Hostname: ftp.mybookfountain.com


                            Port: 21
                        

                            Username: aspecialuser
                        

                            Password: mypassword
                        

                            Folder: /orders/fromReadersParadise/inbox


                            File name: follow the naming format orders-<datetime>.xml





Note
This FTP server doesn't exist in reality; the data provided is fictional. When doing the exercise, use your own FTP server.

5.14.2    Exercise Solution Approach
In Chapter 3, you created all the SLD objects required to build the functionality. These included products, SCs, technical systems, and business systems.
In Chapter 4, you also created ES Repository-related objects. These included namespaces, data types, message types, service interfaces, message mappings, and operation mappings. All of these objects that have been created in the SLD and ES Repository form the basis and foundation to proceed with this chapter's solution. It's now time to build all needed Integration Directory objects to achieve the integration between the two companies. The next sections will provide step-by-step instructions for how to achieve the required solution.
5.14.3    Exercise Step-by-Step Solution
In the next sections, you'll explore each one of the steps needed to put together an interface configuration.
Importing Business Systems from System Landscape Directory
The first step will be to launch the Java Web Start application by going to the SAP PO landing page and clicking on the Integration Builder link. Open a web browser, and go to http://<hostname>:<port>/dir; log in with your SAP PO credentials when prompted.
To configure the sender, you need to have both the sender and receiver business systems available in the Integration Directory. The business systems need to be retrieved from the SLD by following these steps:


                        Expand the Communication Component Without Party node and the Business System node underneath it.
                    

                        Right-click on Business System, and select Assign Business System. On the new screen, click on the Continue button.
                    

                        On the next screen, select both the sender and receiver business systems (BS_READERSPARADISE and BS_BOOKFOUNTAIN), and click on Finish (see Figure 5.37).
                    

These two business systems are now available in the Integration Directory.

Figure 5.37    Import Business Systems into the Integration Directory from the SLD
Creating Communication Channels for Business Systems
The next step is to create the sender and receiver communication channels for the BS_READERSPARADISE and BS_BOOKFOUNTAIN business systems. You already know (from the exercise description earlier) that the sender communication channel type is SOAP, and the receiver channel is FTP. Follow these steps to create the channels:


                        Expand the newly imported BS_READERSPARADISE business system node. Right-click on its Communication Channel section, and select New.
                    

                        On the new screen, specify the communication channel name and description. For the name, enter "CC_SOAP_Sender_Order", and enter any description that you wish in the Description field.
                    

                        Choose SOAP for the Adapter Type.
                    

                        Select the Sender radio button, and set Quality of Service to Exactly Once because this scenario is asynchronous, and you don't expect a response. Leave the other fields set with default values.
                    

                        Click on the Save button on the menu. At the end, your communication channel should like the one in Figure 5.38.
                    


Figure 5.38    Setup of the SOAP Sender Communication Channel for the Business System BS_READERSPARADISE
Now, you'll create the receiver channel for the BS_BOOKFOUNTAIN business system. Follow these steps:


                        Expand the newly imported BS_BOOKFOUNTAIN business system node. Right-click on its Communication Channel section, and select New.
                    

                        On the next screen, specify the communication channel name and description. Enter "CC_FTP_Receiver_Order" for the name, and enter any description that you wish in the Description field.
                    

                        Choose File for the Adapter Type, and set the Transport Protocol to File Transfer Protocol (FTP).
                    

                        Select the Receiver radio button.
                    

                        Fill in values for the FTP server as indicated in Section 5.14.1.
                    

                        Click on the Save button on the menu. At the end, your communication channel should like the one presented in Figure 5.39.
                    


Figure 5.39    Setup of the FTP (File) Receiver Communication Channel for the Business System BS_BOOKFOUNTAIN
Creating an Integrated Configuration for the Scenario
Now that we have the business systems and communication channels in the Integration Directory, it's time to glue everything together using the ICO. Follow these steps:


                        Right-click on Integrated Configuration on the Object Type list, and select New.
                    

                        On the new screen that appears, fill in the following details:
                        

Sender Communication Component: "BS_READERSPARADISE"
                            

Sender Interface: SIOA_PurchaseOrder (select this using the value help)
                            

Namespace: Automatically filled in with the correct namespace of urn:readersparadise.com:scm:procurement:erp




                        Click on the Create button. You're presented with another screen, allowing you to fill in the inbound processing details.
                    

Now, you're ready to configure each step of the message exchange pipeline. We'll explore each of the steps in the next sections.
Inbound Processing
Picking up from the previous step, fill in the inbound processing by specifying the sender Communication Channel to be used. The final result should look like Figure 5.40.

Figure 5.40    Inbound Processing Setup
Receiver
There is no special routing required; all messages should be forwarded to the BS_BOOKFOUNTAIN business system. Follow these steps:


                            Select the Receiver tab.
                        

                            In the Communication Component field (at the bottom-right corner of the Receiver tab), select the receiver business system BS_BOOKFOUNTAIN. You can use the value help to make the selection. The final result should look like Figure 5.41.
                        


Figure 5.41    Receiver Setup
Receiver Interfaces
To set up the receiver interface, select the mapping to be used to make the transformation from the source structure to the receiver structure. Follow these steps:


                            Select the Receiver Interfaces tab.
                        

                            In the Operation Mapping field, select the appropriate mapping using the value help. In this case, the mapping should be called OM_SIOA_PurchaseOrder_to_SIIA_CustomerOrder; you created this mapping in Chapter 4. The final result should look like Figure 5.42.
                        


Figure 5.42    Receiver Interfaces Setup
Outbound Processing
This is the last step of the processing pipeline. You need to specify the receiver communication channel to be used in sending the message to the FTP server. Follow these steps:


                            Select the Outbound Processing tab.
                        

                            Select the receiver communication channel previously created (CC_FTP_Receiver_Order).
                        

                            Save the created ICO. The final result should look like Figure 5.43.
                        

The service is mostly ready, but there are a few more additional activation steps required before you can test your service. All of the objects that you created so far are still part of your change list and aren't yet activated. As a result, the fruit of your labor isn't yet reflected in the runtime system, and other developers can't yet use it. To activate all of your newly created objects, follow these steps:


                            In the Integration Directory, click on the Change Lists tab. On this tab, you should see a change list containing all the objects that you recently created.
                        

                            Right-click on the change list, and select Activate.
                        

After a successful activation, your objects are now present in the runtime, and the scenario is ready to be tested.

Figure 5.43    Outbound Processing Setup
Test Your Service
Now that the interface has been created, you're ready to test it. You'll need to get the WDSL from the interface that you just created and call the service with your preferred SOAP client. To get the WSDL details, follow these steps:


                        Double-click on the ICO that you created.
                    

                        From the top menu, click on Integrated Configuration, and then click Display WSDL.
                    

                        On the new screen that appears, click on WSDL-URL to Buffer. You then will see the URL of the WSDL that you can use from your SOAP client. Alternatively, you can click on the Save button to download the WSDL (see Figure 5.44).
                    


Figure 5.44    Downloading the WSDL or Getting the URL of a Particular ICO









5.15    Summary
You've now acquired the necessary knowledge to build an interface based on the Java stack of SAP PO. This chapter has exposed you to the functionalities, capabilities, and roles of the Integration Directory, which plays a crucial role in the process of building a service or interface in SAP PO. One of its primary roles is facilitating the compiling of all the necessary objects created in the SLD and ES Repository.
Some of the basic objects that we explored include the following:


                Business system (a communication component)
            

                Business component (a communication component)
            

                Communication channel
            

                Adapter types
            

                ICO
            

                Alerts
            

                Configuration scenario
            

In addition to these components, we also touched on runtime aspects of the Integration Directory and looked at the internal XI message protocol.
In the next chapter, we'll discuss iFlows and introduce you to a new dimension when configuring service interfaces in SAP PO.








6    Building an Integration FlowArchitects have made architecture too complex. We need to simplify it and use a language that everyone can understand.                                                                                                                —Toyo ItoIn Chapter 5, you learned how to configure interfaces using the Integrated Configuration (ICO), which can be built from the Integration Directory (Java Web Start or Swing client). Besides the use of the Swing client, the SAP NetWeaver Developer Studio tool (often referred to as NWDS) is gaining popularity and becoming the tool of choice for performing various development tasks within the SAP NetWeaver platform. As a result, SAP has also made it possible to develop ICO-like configurations from SAP NetWeaver Developer Studio. These configurations are known as Integration Flows (iFlows).iFlows are built on Business Process Model and Notation (BPMN)-like artifacts. This type of artifact gives a good overview of systems and components involved in end-to-end messaging and connectivity. It also presents an insight into the architecture of the process flow. Even though they are developed from SAP NetWeaver Developer Studio, an iFlow plays the same role as an ICO, and invariably iFlows provide an alternative to ICOs. The use of SAP NetWeaver Developer Studio for designing, configuring, and deploying iFlows presents a unique and simplified way of working in the SAP Process Orchestration (SAP PO) platform. Enhanced capabilities of SAP NetWeaver Developer Studio (e.g., as a unified Integrated Development Environment [IDE] tool for designing, configuring, and deploying iFlows, SAP Business Process Management [SAP BPM], SAP Business Rules Management [SAP BRM], Enterprise Java Beans [EJBs], and related projects) presents a new approach to working with composite services.SAP NetWeaver Developer Studio supports the creation of both SAP PO Enterprise Services Repository (ES Repository) and Integration Directory objects. These objects are used for end-to-end messaging via the middleware layer without the use of the Enterprise Service Builder (ES Builder) and Integration Builder Java clients (Swing GUI tools).The SAP NetWeaver Developer Studio is already used as the development tool for SAP BPM, SAP BRM, and many other SAP technologies.In this chapter, we'll delve into the SAP NetWeaver Developer Studio in greater detail to explain how to set it up to create and configure an iFlow. The explanations in this chapter are also supported with a step-by-step guide to creating ES Repository objects and to creating and configuring an iFlow.
6.1    SAP NetWeaver Developer Studio
SAP NetWeaver Developer Studio is the IDE tool for the SAP Composition Environment platform. It's an Eclipse-based tool enhanced with extensive functionalities that supports development for the SAP NetWeaver technology platform. We'll discuss using SAP NetWeaver Developer Studio with respect to working with iFlows in this chapter.
6.1.1    Installing SAP NetWeaver Developer Studio
To get started, the appropriate SAP NetWeaver Developer Studio IDE version compatible with the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java) version for deployment should be installed on your machine. A copy of the SAP NetWeaver Developer Studio software can be obtained via the SAP Service Marketplace, which is a portal that enables collaboration between SAP and its customers. It provides SAP Notes, support material for the different SAP applications, license key requests, customer messages, and much more. You can also download SAP software from the portal via https://support.sap.com.
Ideally, the SAP NetWeaver Developer Studio version and SAP NetWeaver AS Java version should be at the same level, or the SAP NetWeaver AS Java version should be at a higher level. You'll need Java Development Kit (JDK) version 1.6.0 or above as a prerequisite.

Note
Edit the configuration settings file in the SAP NetWeaver Developer Studio folder with the JDK's (javaw.exe) location—usually installed in the Program Files or Program Files (x86) of the C drive (e.g., -vm C:\Program Files\Java\JDK\6u33\bin).
Alternatively, when launching SAP NetWeaver Developer Studio, you'll be asked to browse to the correct version, but that depends on the version of SAP NetWeaver Developer Studio in use.

After making sure that the previously stated prerequisites are fulfilled, you can launch the SAP NetWeaver Developer Studio EXE application, and the Start page will be loaded.
With the software installed and the initial steps performed, SAP NetWeaver Developer Studio should be fully ready to create iFlows and related objects.
6.1.2    Setting Up SAP NetWeaver Developer Studio
SAP NetWeaver Developer Studio is a client-side tool that must be set up with server connections to create and deploy iFlows, as well as other necessary design objects and related artifacts. The essential activities to be performed include connecting the SAP Process Integration (SAP PI) tools configuration to the SAP PO server and setting up the web service connection to the ES Repository.
SAP PI Tools Configuration
The SAP PI Tools Configuration node provides the connectivity necessary with SAP NetWeaver AS Java for creating, configuring, and deploying iFlows and repository objects. When connected to SAP NetWeaver AS Java, the following four perspectives are available in which to perform the different development activities:


ES RepositoryThis perspective allows you to create repository-related objects, such as interface objects, mapping objects, and namespaces. It supports the import of software component versions (SWCVs) that have been created in the System Landscape Directory (SLD). Most functions that could be performed by the Enterprise Service Builder are supported.
                    

SAP PI Administration Two types of objects can be created from this perspective: iFlows and communication components (systems). This same perspective is used to deploy iFlows after they have been created.
                    

SAP PI Runtime This perspective provides a detailed overview of all runtime-related activities for iFlows. In addition, this perspective allows the status of each iFlow to be retrieved and monitored.
                    

SAP PI Designer This perspective makes it possible to work with the repository and directory objectives concurrently. When in this perspective, you can switch to the PI Explorer tab to create iFlows or switch to the Enterprise Service Browser tab to create repository objects.
                    

iFlows are the equivalent of the traditional ICOs created in the Integration Builder tool of SAP PI or SAP PO. When an iFlow is created and deployed, an ICO is also automatically generated in SAP PI/SAP PO as one of the directory objects because iFlows and ICOs share the same database.
Follow these steps to set up the SAP PI Tools Configuration:


                        Launch the SAP NetWeaver Developer Studio tool.
                    

                        Select Window • Preferences from the menu bar.
                    

                        Navigate to the PI Tools Configuration.
                    

                        Select Connections, and add the parameters shown in Figure 6.1.
                    

                        Test the connection by clicking on Test Connection. If the connection is successful, then click on Apply and finally on OK. With SAP NetWeaver Developer Studio connected to SAP NetWeaver AS Java, you're ready to design and configure ES Repository and Integration Directory objects.
                    


Note
To set up the connection, you'll need to select the Manual radio button. Then, fill in the Host and HTTP Port fields, in the following formats:


Host: http://<hostname>


HTTP Port: <portnumber>




Figure 6.1    Settings for PI Tools Configuration with Connection to the SAP NetWeaver AS Java
Enterprise Service Repository Connection
This is an optional step for working with iFlows. It's only needed when repository objects to be used in iFlows are created with the ES Repository using the SAP NetWeaver Design Studio instead of the Swing client. Follow these steps to set up a connection to the ES Repository:


                        Launch the SAP NetWeaver Developer Studio tool.
                    

                        Select Window • Preferences from the menu bar.
                    

                        Navigate to the Web Services option.
                    

                        Select Enterprise Service Browser.


                        Add the parameters shown in Figure 6.2.
                    


Figure 6.2    Connection Settings for the ES Repository
6.1.3    Enterprise Integration Patterns and User-Defined Templates
Integration specialists use integration patterns as design and implementation guides; these patterns help classify and develop integration solutions. Integration patterns are very popular among integration specialists and are widely used by various platforms. Different integration patterns support various business processes, and iFlows support a number of standard integration patterns by default. You can also create your own user-defined template that can be reused. The following custom enterprise integration patterns are available in SAP NetWeaver Developer Studio for creating iFlows:


Point-to-point A point-to-point channel ensures that messages are sent to one receiver only.
                

Recipient list A recipient list allows you to specify one or more recipients. This message router examines the incoming message and routes it to one or more different receiver channels specified on the recipient list.
                

Message translator A message translator converts the data structure of a component into another data structure to use in a different context.
                

Recipient list (dynamic conditions) A recipient with dynamic conditions uses a mapping program to dynamically determine a target receiver and routes the incoming messages to the identified receiver system.
                

Figure 6.3 shows the integration pattern options available in the SAP PI Designer perspective of the SAP NetWeaver Developer Studio.

Figure 6.3    Enterprise Integration Patterns for iFlow Supported by SAP NetWeaver Developer Studio









6.2    Basics of Creating and Configuring an Integration Flow
With SAP NetWeaver Developer Studio up and running and connectivity to the SAP NetWeaver AS Java established, we'll now explore how to create and configure an iFlow.
6.2.1    Creating an iFlow
To create an iFlow, follow these steps:


                    Switch to the SAP Process Integration Designer perspective.
                

                    Establish a connection with the SAP NetWeaver AS Java with logon credentials (username and password maintained in the user management engine [UME]).
                

                    Choose the PI Explorer tab.
                

                    Right-click on the Integration Flows folder in the PI Explorer view, and choose the New Integration Flow option (see Figure 6.4).
                    
Figure 6.4    Steps in Creating an iFlow


                    Depending on your requirements, choose an appropriate enterprise integration pattern or an existing user-defined template (see Figure 6.5). Here, we've selected Recipient List for demonstration purposes. Provide the required details, such as a Name and ID for your iFlow (Figure 6.5). Be aware that the ID name is automatically filled in based on the name of your iFlow. The iFlow ID must be unique and is restricted to a maximum of 32 characters.
                    
Figure 6.5    Details for Creating an iFlow


                    Skip configuring the sender or receiver details because this can be done after the iFlow is created.
                

                    Click on Finish. An iFlow will be created (see Figure 6.6). This iFlow can be further extended by performing configuration tasks, as discussed in the next section.
                


Figure 6.6    Sample Generated iFlow
6.2.2    Configuring an iFlow
For an iFlow to exchange messages between the connected business systems or communication components, a number of configuration steps have to be performed. A detailed step-by-step procedure is available in Section 6.3. For now, the essential and high-level configuration steps are as follows:


                    Create a business component (New Business Component) or import a business system from the SLD (Import Business System). The logic behind when to use a business system or business component was explored in Chapter 5. For simplicity's sake, let's locally create a business component as demonstrated in Figure 6.7.
                    
Figure 6.7    Creating a New Business Component


                    Assign sender and receiver communication components. To assign the sender business system or component, right-click on Sender 1 and choose the Assign System (F4) option, as shown in Figure 6.8. You'll need to repeat this step for every receiver system in your iFlow.
                

                    Assign a service interface by right-clicking on the Interface icon and choosing the Assign Interface (F4) option, as shown in Figure 6.9.
                

                    Repeat this step for each receiver interface in your iFlow.
                    
Figure 6.8    Assigning a Sender or Receiver System to the iFlow

Figure 6.9    Assigning a Service Interface to the iFlow


                    Configure the communication channel by right-clicking on the Channel line and selecting the Configure Channel option, as shown in Figure 6.10 1. You're then taken to a new screen from which you can specify the communication channel details, such as adapter type 2. Further communication channel attributes can be configured in the Adapter-Specific, Modules, and Identifiers tabs and are self-explanatory.
                    
Figure 6.10    Configuring the Communication Channel

Note
Be aware that in addition to the ability to configure a channel, you can also do the following:


Apply a channel template This allows the user to apply the details configured in a communication channel template to the current communication channel.
                            

Assign a referenced channel This enables the reuse of an existing communication channel in the iFlow.
                            




                    Repeat the previous step for the receiver channels.
                

                    Create rules and conditions for routing to the receivers. Right-click on the Recipient List box, as shown in Figure 6.11, and select one of the options in the context menu, depending of your requirement. Note that these conditions are based on XPath expressions.
                    
Figure 6.11    Configure Routing and Conditions


                    From the same context menu (Figure 6.11), you can also add or remove receivers, depending on your requirements.
                

                    Assign the necessary mappings between the sender and receiver systems. To insert a mapping in the iFlow, right-click on the desired Condition line, and select the Add Mapping option, as shown in Figure 6.12 1. A new Mapping icon is added to the iFlow.
                    
Figure 6.12    Adding a Mapping to the iFlow


                    You then need to assign a specific operation mapping by right-clicking on the Mapping box and selecting the Assign Mapping (F4) option 2.
                

                    Execute a consistency check to ensure that the iFlow has been correctly configured by right-clicking on the iFlow item from the PI Explorer view and selecting the Check Consistency option (see Figure 6.13). If the iFlow configuration isn't complete, then the Problems view will be populated with error details.
                

                    Activate the iFlow by right-clicking and selecting the Activate option (see Figure 6.13).
                    
Figure 6.13    Check Consistency of, Activate, and Deploy an iFlow


                    Deploy your iFlow to the SAP PO server by right-clicking and selecting the Deploy option (Figure 6.13). It's possible to monitor the deployment status via the Deployment Log view, as shown in Figure 6.14. If you encounter problems during the deployment, the error details will be accessible via this Deployment Log view. You can right-click on an entry and choose the View Deployment Trace option.
                


Figure 6.14    Deployment Log View

Note
If the iFlow hasn't been properly configured, then red markers are shown on the different components, as shown in Figure 6.15. Until all these components are configured, the red markers will continue to appear, and you won't be able to activate the iFlow.


Figure 6.15    Red Markers on Compulsory Components to be Configured
After a successful deployment, you can view the iFlow in the Integration Directory Swing user interface (UI) tool, as shown in Figure 6.16. The iFlow presented in the Interface Directory also includes the sender and receiver communication channels.

Figure 6.16    An iFlow in the Integration Directory
Also note that once deployed, the iFlow generates an ICO equivalent. SAP doesn't recommend modifying the ICO generated by the iFlow from the Integration Directory (Swing client). Any changes made to the iFlow in the Swing client won't reflect in the SAP NetWeaver Developer Studio. It's therefore better to stick to SAP NetWeaver Design Studio for any iFlow-related activities.









6.3    iFlow Example
In this section, we'll demonstrate how to build an iFlow using an example scenario. Let's assume that you need to build an iFlow to pick up a sales order information file from a folder in the local file system and deliver it to another folder (in the same file system) via SAP PO. For this scenario, the iFlow and all necessary repository objects will be created with SAP NetWeaver Developer Studio.
6.3.1    Creating Products, Software Components, Business Systems, and Technical Systems in the SLD
We want to provide a complete overview of working locally within SAP NetWeaver Developer Studio without using the Swing client. Let's start by creating the supporting SLD artifacts. This includes a new product, three software components (SCs), and two technical and business systems. To create these SLD artifacts, follow the steps ahead for your particular tasks. For all of the following tasks, begin by navigating to the SLD via http://<host>:<port>/sld.
Create Product
To create the product, follow these steps (see Figure 6.17):


                        From the landing page of the SLD, select Products from the Software Type dropdown.
                    

                        Click the New button.
                    

                        Follow the wizard, and provide the following information:
                        

Name: "ROJO_TRN_SYSTEM_1000"
                            

Vendor: "rojoconsultancy.com"
                            

Instance Name: "IN_Rojo_Trn_System_1000"
                                
Figure 6.17    Products Created in the SLD




Create Three Software Component Versions
To create the SWCVs, follow these steps (see Figure 6.18):


                        Select the Software Component Versions tab.
                    

                        Select the New... option.
                    

                        Follow the wizard, and provide the following information as the names of your SCs:
                        

ROJO_A_SYSTEMA_1000


ROJO_B_SYSTEMB_1000


ROJO_PI_SYSTEMPI_1000





Figure 6.18    Software Components Created in the SLD

Note
You'll need to create dependencies between the SCs. The SC ROJO_PI_SYSTEMPI_1000 should have dependency on ROJO_A_SYSTEMA_1000 and ROJO_A_SYSTEMB_1000.

Create Two Technical Systems
To create the technical systems, follow these steps:


                        From the SLD landing page, select the Technical Systems tab.
                    

                        Select the New Technical System option.
                    

                        Follow the wizard, and use the following attribute values for the first Technical System:
                        

System Type: Standalone


Technical System Identification: "TS_SystemA_1000"
                            

System Host Name: An appropriate company domain name (e.g., "rojoconsultancy.com")
                            



                        Repeat both previous steps for the second technical system, and use the following attribute values:
                        

System Type: Standalone


Technical System Identification: "TS_SystemB_1000"
                            

System Host Name: An appropriate company domain name (e.g., "rojoconsultancy.com")
                            



The resulting technical systems are shown in Figure 6.19.

Figure 6.19    Technical Systems Created in the SLD
Create Two Business Systems
To create the business systems, follow these steps:


                        From the SLD landing page, choose the Business Systems tab.
                    

                        Select the New Business System option.
                    

                        Follow the wizard, and use the following attribute values for the first business system:
                        

System Type: Third Party/Other


System: "TS_SystemA_1000"
                            

Name: "BS_SystemA_1000"
                            



                        Repeat both previous steps for the second business system, and use the following attribute values:
                        

System Type: Third Party/Other


System: "TS_SystemB_1000"
                            

Name: "BS_SystemB_1000"
                            



The resulting business systems are shown in Figure 6.20.

Figure 6.20    Business Systems Created in the SLD
6.3.2    Importing SLD Objects into the ES Repository in SAP NetWeaver Developer Studio
Switch back to the SAP NetWeaver Developer Studio start page launched earlier, and follow these steps to import all the necessary objects created in the SLD:


                    Switch to the Enterprise Service Browser perspective, and log on to SAP NetWeaver AS Java.
                

                    Import the SWCV from the SLD into the Enterprise Service Browser.
                

                    Right-click on the view of the Enterprise Service Browser, and select New • Software Component Version (see Figure 6.21).
                

                    Select the Import from SLD radio button. You'll be presented with a list of SWCVs from which you can choose the SC that you previously created and named ROJO_A_SYSTEMA_1000.
                

                    Repeat the previous two steps for the SCs named ROJO_B_SYSTEMB_1000 and ROJO_PI_SYSTEMPI_1000.
                


Figure 6.21    Steps to Import Software Components from the SLD
6.3.3    Create Enterprise Service Repository Objects
The next objects that need to be created for this scenario include namespaces, data types, message types, service interfaces, message mappings, and operation mappings.
To create all of these objects, click on the view of the Enterprise Repository Browser, and select the appropriate object to be created.
Create Three Namespaces
Create three namespaces in the ROJO_A_SYSTEMA_1000, ROJO_A_SYSTEMB_1000, and ROJO_PI_SYSTEMPI_1000 SCs created earlier to hold the sender system, receiver system, and common objects, respectively. Then, follow these steps:


                        Right-click on the appropriate SWCV.
                    

                        Choose the Open Namespaces option from the resulting context menu.
                    

                        Under the Namespace List, use the Add button to add a new namespace (see Figure 6.22).
                        
Figure 6.22    Creating Namespaces to Hold ES Repository Objects


                        Add the namespaces according to Table 6.1.
                        


SWCV
Namespace




ROJO_A_SYSTEMA_1000
urn:rojoconsultancy:training:systema:salesorder


ROJO_B_SYSTEMA_1000
urn:rojoconsultancy:training:systemb:salesorder


ROJO_PI_SYSTEMPI_1000
urn:rojoconsultancy:training:systempi:salesorder



Table 6.1    List of Namespaces and Corresponding Software Components


                        After the namespaces have been created, save your changes.
                    


Note
When creating or adding objects, SAP NetWeaver Developer Studio might prompt you to specify the change list underneath which the new objects will be kept for activation purposes.

Create Two Data Types
Two data types will be created, one for the sender system and one for the receiver system. Follow these steps:


                        Right-click on the urn:rojoconsultancy:training:systema:salesorder namespace in the A SWCV.
                    

                        Select New • Data Type from the dropdown (see Figure 6.23).
                    

                        Click on the Add Element button, and enter the information for the sender data type structure (DT_SalesOrder_SysA; see Figure 6.24).
                    

                        Click the Finish button, and save the object after creating the data structure.
                    

                        Repeat the preceding steps to create the receiver data type in the urn:rojoconsultancy:training:systemb:salesorder namespace contained in the B SWCV, with the DT_SalesOrder_SysB receiver data type structure (see Figure 6.25).
                    


Figure 6.23    Creating a Data Type for the Message Structure

Figure 6.24    Data Structure for System A

Figure 6.25    Data Structure for System B
Create Message Types
Create sender and receiver message types using the data types created earlier. Follow these steps:


                        Expand the urn:rojoconsultancy:training:systema:salesorder namespace under the ROJO_A_SYSTEMA_1000 SC.
                    

                        Right-click on the Message Type object node, and select the New Message Type option (Figure 6.26 1), which opens a new wizard.
                        
Figure 6.26    Creating ES Repository Objects from SAP NetWeaver Developer Studio


                        Name the message type "MT_SalesOrder_SysA", and select appropriate data types using the Browse button. Select the DT_CustomInfo_SysA data type.
                    

                        Repeat the preceding three steps to create the receiver message type in the namespace that was created earlier (urn:rojoconsultancy:training:systemb:salesorder). The new message type can be named "MT_CustomInfo_SysB".
                    

Create Two Interfaces
To create sender and receiver service interfaces in the ES Repository, follow these steps:


                        Expand the urn:rojoconsultancy:training:systema:salesorder namespace under the ROJO_A_SYSTEMA_1000 SC.
                    

                        Right-click on the Service Interfaces node and select the New Service Interface option (refer to Figure 6.26 2).
                    

                        In the new screen that appears, give the new service interface the name "SIOA_CustomInfo", and click on the Finish button.
                    

                        Select the Definition tab.
                    

                        Select the Input node, and click on the Add Input Message button.
                    

                        Use the Browse button to select the appropriate message type. In this case, you need to use the message type that was created earlier and named MT_SalesOrder_SysA. The attribute Type needs to be set to the value Asynchronous, as shown in Figure 6.27.
                        
Figure 6.27    Service Interface Definition for the Sender System


                        In the Overview tab and Advanced group, the service interface needs to have the Attribute category set to the value Outbound.
                    

                        Adjust other settings for the service interface as shown in Figure 6.27.
                    

                        Repeat the preceding steps to create the receiver service interface in the urn:rojoconsultancy:training:systemb:salesorder namespace created earlier and the SC named ROJO_B_SYSTEMB_1000. Name this new interface "SIIA_CustomInfo". Furthermore, in the Overview tab and Advanced group, the service interface needs to have the Attribute category set to the value Inbound.
                    

Create Message Mapping
A simple message mapping is created in this scenario for demonstration purposes. The source fields are mapped to the target fields in a one-to-one manner. Follow these steps:


                        Within the ROJO_PI_SYSTEMPI_1000 SC, expand the urn:rojoconsultancy:training:systempi:salesorder namespace. Use the context menu on the Message Mapping node, and select the New Message Mapping option.
                    

                        In the new screen, provide a name for the new mapping. In this case, use the name "MM_SystemA_To_SystemB_SalesOrder". Click on the Finish button.
                    

                        In the subsequent screen, under the Overview tab and Signature group, assign the appropriate message types for the source message and target message. Click on the Browse button to select the message types (Figure 6.28).
                        
Figure 6.28    Message Mapping with Source and Target Messages


                        Select the Definition tab to specify the message mapping (Figure 6.29). In this tab, you can implement the mapping or specify how to transform the source and target message types. All the fields are mapped one on one, except for the priceUnit in the Target field, which needs to be mapped using a concatenation of amount and currency in the Source fields. The mapping of the priceUnit field is shown at the bottom of Figure 6.29.
                    


Figure 6.29    Message Mapping with Concatenated Fields
Create Operation Mapping
To create an operation mapping, follow these steps:


                        Within the ROJO_PI_SYSTEMPI_1000 SC, expand the urn:rojoconsultancy:training: systempi:salesorder namespace. Right-click on the Operation Mappings node, and select the New Operation Mapping option.
                    

                        In the new screen, provide a name for the new mapping. In this case, use the name "OM_SystemA_To_SystemB_SalesOrder". Click on the Finish button.
                    

                        Under the Overview tab, select the Operation Definition group, and click on the Add button to specify the source and target service interfaces (Figure 6.30 1).
                    

                        Navigate to the Definition tab, and select the mapping program (or message mapping) to be used between the source and target messages. Double-click on the line (on the function sign) connecting the source to target message input.
                    

                        When the new window pops up, click on the Add button.
                    

                        Under the Type column, select Message Mapping.


                        Under the Name column, select the message mapping created earlier (Figure 6.30 2).
                    

You're now ready to create the different ES Repository artifacts that are required for your iFlow, so it's time to activate these objects. Note that only after a successful activation will the objects be committed and become available in the ES Repository.

Figure 6.30    Operation Mapping with Outbound and Inbound Service Interfaces
Activating ES Repository Objects
All the newly created or modified ES Repository objects (from the previous sections) are grouped under change lists. A different change list is created for each SC. Given that we've been dealing with three SWCVs, we can also expect three different change lists. Activate the change lists in each SC via the following steps (see Figure 6.31):


                        Switch to the Change List Explorer view.
                    

                        Right-click on each change list name, and select the Activate option.


                        Repeat the previous step for the other change lists.
                    


Figure 6.31    Activating Change Lists for Repository Objects
With all the change lists activated, you've finished the repository work, and all objects created can be used for configuration when creating the iFlow.
6.3.4    Create Directory Objects: Import Business Systems and Create iFlows
In this section, the objects that have been created previously in the Enterprise Service Browser perspective will be used to create the iFlow. The steps discussed ahead will be used to create, configure, and deploy an iFlow and its supporting objects.
Importing Business Systems
In this scenario, business systems that have been created will be imported from the SLD. Follow these steps to import the business systems:


                        From the SAP NetWeaver Developer Studio, switch to the SAP Process Integration Designer perspective.
                    

                        In the PI Explorer view, right-click the Systems folder, and select Import Business System (Figure 6.32).
                        
Figure 6.32    Importing Business Systems from the SLD


                        A new screen appears, in which a list of business systems from the SLD is presented. Select the desired business systems (in this case, BS_SystemA and BS_SystemB), and click on the Finish button.
                    

Creating an iFlow
The iFlow will be created for the end-to-end exchange of messages between file systems. Follow these steps:


                        Right-click on the Integration Flows folder in the PI Explorer view, and follow the wizard to create the iFlow.
                    

                        In the Name and ID fields, enter "IF_FiletoFile_SalesOrder".
                    

                        In the New Integration Flow window, click on Enterprise Integration Patterns under Categories, and then select the Point-to-Point Channel pattern (Figure 6.33).

Figure 6.33    End-to-End File Scenario with the Point-to-Point Enterprise Integration Pattern


                        Configure the Sender and Receiver systems by using the context menu on each and selecting the Assign System menu item. Choose BS_SystemA_1000 for the sending system and BS_SystemB_1000 for the receiving system.
                    

                        Assign a service interface to the sending and receiving systems by right-clicking on the Interface icon and choosing the Assign Interface (F4) option. For the sending system, select the SIOA_SalesOrder service interface that was created in Section 6.3.3.
                    

                        Configure the sender communication channel by right-clicking on the channel adapter on the sender side and selecting the adapter type (File) by using the Browse button.
                    

                        Specify the name of the channel, as shown in Figure 6.34. Further communication channel attributes can be configured in the Adapter-Specific, Modules, and Identifiers tabs and are self-explanatory.
                        
Figure 6.34    Configuring Settings for the Sender Channel


                        Some useful attributes to fill in with values include the Source Directory and File Name, under the Adapter-Specific tab (see Figure 6.35 1).
                    

                        Furthermore, because you're dealing with an asynchronous interface from the sender system, ensure that the sender communication channel has the Quality of Service (QoS) set to Asynchronous. To do so, go to the Adapter-Specific tab and then the Processing subtab. Set the QoS attribute to Exactly Once. In addition, set the polling interval to 10, and set the processing mode to Delete.
                    

                        Configure the receiver communication channel by following the same steps as for creating the sender channel (see the two previous steps, and see Figure 6.35 2 for an example setup for the receiver communication channel).
                        
Figure 6.35    Source and Target Directories in the File System


                        Configure the mapping by right-clicking on the connecting lane between the sender and the receiver, and selecting Add Mapping. The mapping artifact is added in the flow. Right-click on the mapping object, and choose the Assign Mapping option from the context menu. Select the operation mapping created earlier. The completed iFlow should look like the screen shown in Figure 6.36.
                        
Figure 6.36    Completely Configured iFlow with Different Components


                        Save and activate by right-clicking on the iFlow created in the pallet and selecting the Activate option (Figure 6.37).

Figure 6.37    Activating the Configured iFlow


                        Deploy the iFlow by right-clicking on it and selecting the Deploy option. After the iFlow deploys successfully, your console should look like the one shown in Figure 6.38 when in the Deployment Log tab.
                    


Figure 6.38    Deploying iFlows and Viewing the Deployment Log
Finally, the iFlow scenario is ready for testing.
6.3.5    Testing the iFlow Scenario
To test the scenario that you've just created, follow these steps:


                    Create an XML file with the name specified in the sender channel. In this case, the file needs to be called "SalesOrder.xml", as previously indicated in Figure 6.35 1. Note that the content of the file also needs to match the structure of the service interface called SIOA_CustomInfo, which was created in Section 6.3.3. An example file is presented in Figure 6.39.
                

                    Place this XML file in the source directory, as shown in Figure 6.35 1.
                

                    After about 10 seconds, the file should be picked up from the source directory and be created in the target directory.
                


Figure 6.39    Sample XML Message Being Sent from the Source File System
6.3.6    Monitoring the Scenario
After you've placed a test file, it's time to see how your iFlow processes the message during runtime. There are several ways to monitor the scenario. Message and channel monitoring can be performed via the traditional Monitoring Home, but for the purposes of further exploring what is possible in SAP NetWeaver Developer Studio, we'll instead use the monitoring capability available from SAP NetWeaver Developer Studio. For message monitoring, follow these steps:


                    Switch to the SAP PI Runtime perspective.
                

                    Right-click on the iFlow that you previously created and named IF_FiletoFile_SalesOrder.
                

                    In the context menu of the selected iFlow, select the Open Message Monitoring option, as shown in Figure 6.40 1.
                

                    The messages processed are displayed in the monitor. You could also use the Open Message option to verify the message content 2.
                


Figure 6.40    Opening Message Monitoring from the SAP PI Runtime Perspective









6.4    New Features of the Process Integration Designer
As part of the new features delivered in SAP PO 7.5, this section discusses the capabilities related to the SAP Process Integration Designer perspective in the SAP NetWeaver Development Studio. As already mentioned in the previous section, the SAP Process Integration Designer perspective is used to create an iFlow scenario. The new features will be discussed in the next sections.
6.4.1    Export Objects from the Integration Designer
To speed up the transport process, you can now also start the export of objects developed within the SAP Process Integration Designer perspective of SAP NetWeaver Design Studio by following these steps:


                    In the PI Explorer browser view, right-click on the object to be transported and choose Export. This object can be an iFlow, folder, receiver rule, communication party, or system.
                

                    The selected objects are now selected in the export assistant.
                

The export feature enables you to hide deleted objects in the object selection pages of the export assistant using the Hide Deleted button, as shown in Figure 6.41.

Figure 6.41    Options in the Export Assistant

Note
If the object to be exported is of type folder, all objects that are contained in the folder are automatically selected in the export assistant. Furthermore, if you only have one transport mechanism type (file or enhanced Change and Transport System [CTS+]) configured, you're prompted to first select an Object Type, which can be All Objects, Integration Flows, or Value Mappings.
If both file and CTS+ are configured, you must first select the desired transport mechanism type.

6.4.2    Automatically Deploy after Import
You can also automatically deploy iFlows right after import. To activate this feature, you must set the property com.sap.aii.ibdir.core.transport.autoDeploy=true from the service XPI Service: All Config Service in the SAP NetWeaver Administrator, as shown in Figure 6.42.

Figure 6.42    Enabling the Automatic Deployment via XPI Service

Notes
Enabling the automatic deployment feature only works if you also activate the automatic activation of import change lists in your SAP NetWeaver Design Studio, as shown in Figure 6.43.

Figure 6.43    Enabling an Automatic Deployment after Activation

6.4.3    Version History and Deployment Status
From SAP PO 7.5 SP 04, you can also check the history of the different versions of a particular iFlow. To view the Version History of an object, follow these steps:


                    In the PI Explorer view, select the desired object on the left and right click to bring up the context menu, as shown in Figure 6.44.
                    
Figure 6.44    Selecting the Version History Option


                    Next, select the version history option from the context menu as shown in Figure 6.44.
                

                    A view for the version history is displayed at the bottom of the screen as shown in Figure 6.45.
                


Figure 6.45    Version History of an Object
You can also check which one of the versions mentioned in Figure 6.44 and Figure 6.45 is deployed in the server. To do so, select Process Integration, then Check Deployment from the top menu of the SAP Process Integration Designer view. You then get details of the latest activated version as well as the deployed version, as shown in Figure 6.46.

Figure 6.46    On Overview of the Latest Activated Version and Deployed Version









6.5    Supporting Multiple Senders for Your iFlow
Imagine you have multiple sender systems sending the same XML message but using different communication mediums or protocols. One sends it using the file adapter, and the other uses a Simple Object Access Protocol (SOAP) adapter. Before SAP PO 7.5 SP 04, the only way to achieve this was to create two separate iFlows. This situation creates additional implementation/maintenance work and isn't practical. From SAP PO 7.5 SP 04, it's now possible to use multiple sender communication channels in the same iFlow. This section shows you how to accomplish this.
With this support of multiple senders in your iFlow, you can configure central message processing by creating one iFlow with a sender wildcard. Follow these high-level steps to create an iFlow with a sender wildcard:


                From the SAP NetWeaver Design Studio Designer perspective, you can now use a pattern called Recipient List (Multiple Senders), as shown in Figure 6.47.
            

                The next screen shows the patterns that automatically set a wildcard in the sender Communication Component (see Figure 6.48). Select Finish.
                
Figure 6.47    Recipient List (Multiple Senders)

Figure 6.48    Sender System Made Generic with a Wildcard Type


                From the created iFlow, you can add specific Sender Agreement and Communication Channels using the Add button in the Senders tab as shown in Figure 6.49.
                
Figure 6.49    Adding a Sender Agreement in the Senders Tab


                From the new screen that appears, specify the sender system using the Browse button (see Figure 6.50).
                
Figure 6.50    Creating a Sender Agreement


                After selecting a Sender System, select or create a communication channel to associate with it.
            

                Finally, select the Refresh button to see the list of Sender Agreements, as shown in Figure 6.51.
            


Figure 6.51    List of All Sender Agreements That Match an iFlow

Notes
A sender agreement consists of the channel assignment and the assigned users. A sender agreement is suitable for a wildcard iFlow if the sender agreement interface definition matches the iFlow sender interface or if the sender agreement uses interface wildcards. It's also possible to create a sender agreement from scratch by right-clicking on a sender business system or business component and selecting the New Sender Agreement option from the context menu.










6.6    Exercise: Building an Integration Flow
In this exercise, we provide practical insight into working with SAP NetWeaver Developer Studio to build an iFlow, as well as deploying and monitoring iFlows.
6.6.1    Exercise Description
You've been informed that Reader's Paradise's book supplier, Book Fountain, only quotes prices in USD. However, because Reader's Paradise has an internationally established chain of bookstores, you need to convert the price quoted in USD to various other currencies.
As a result, you've been asked to build an interface to enable currency conversion functionality in the various customer portals of Reader's Paradise. With the interface that you'll build, potential customers will be able convert book prices from USD to their local currency (e.g., EUR).
6.6.2    Exercise Solution Approach
You'll be using an iFlow to build this SAP PO interface. For simplicity's sake, we'll make use of a freely available currency conversion web service. The service's Web Service Description Language (WSDL) can be found at www.webservicex.net/CurrencyConvertor.asmx?WSDL.
The iFlow to be built should then connect the Reader's Paradise stores' portals via a web service (SOAP adapter), call the currency conversion service on the receiver side (WebserviceX), and return a conversion rate as the response. The scenario to be built and the system involved are presented in Figure 6.52.

Figure 6.52    iFlow Scenario for Conversion between USD and Local Currencies on the Reader's Paradise Portal
The currency conversion service requires two currency ISO codes as input and will return the conversion rate.
6.6.3    Exercise Step-by-Step Solution
To successfully complete this exercise, a step-by-step description of all the necessary actions and steps to be performed are discussed in the next sections. Start by downloading the WSDL of the external currency web service.
Download the Web Service Description Language
The web service to be consumed in this scenario for the currency conversion is a free web service provided by WebserviceX. WebserviceX serves about 6 million web transactions per day. The currency converter web service takes two inputs and returns an exchange rate as the result. The WSDL contains enumerations of different currencies with three-letter abbreviations (ISO codes).
Download the WSDL file for this scenario, provided by WebserviceX, via www. webservicex.net/CurrencyConvertor.asmx?WSDL. Save the WSDL in a directory on your local computer. The next step is to create all the required services interfaces to support the iFlow.
Create Service Interfaces in Enterprise Services Repository
You need to create two synchronous service interfaces: one for the sender systems (outbound) and one for the receiver system (inbound). Follow these steps to create these service interfaces:


                        Go to the SAP PO landing page, and click on the Enterprise Services Repository Builder link.
                    

                        Import the three SCs created during the exercise in Chapter 3:
                        

SWC_BOOKFOUNTAIN


SWC_READERSPARADISE


SWC_MAPPINGS



Note
If you worked through the Chapter 3 exercise, then you can skip this step.



                        Create three namespaces within the three SCs according to these specifications:
                        

                                "urn:readersparadise.com:currency:webservicex" for the SC SWC_BOOKFOUNTAIN


                                "urn:readersparadise.com:currency:portal" for the SC SWC_READERSPARADISE


                                "urn:readersparadise.com:currency:mapping" for the SC SWC_MAPPINGS




                        By now, you should be familiar with how to create namespaces within a SC. Figure 6.53 summarizes the steps involved.
                    

                        Activate the namespaces created.
                    


Figure 6.53    Creating a Namespace within a Software Component
Now that you have all the required namespaces, import the external WSDL. The WSDL will need to be imported as an external definition into the urn:readersparadise.com:currency:portal and urn:readersparadise.com:currency:webservicex namespaces. Follow these steps:


                        On the menu bar, select Tools • Import External Definitions (see Figure 6.54). Follow the wizard until you have successfully imported the WSDL.
                    

                        Save and activate the objects.
                        
Figure 6.54    Importing External Definitions into the Enterprise Services Repository


                        Create an outbound service interface in the namespace "urn:readersparadise.com: currency:portal" (see Figure 6.55).
                        
Figure 6.55    Service Interface Object Creation


                        Set the properties of the outbound service interface created earlier according to the details shown in Figure 6.56.
                        
Figure 6.56    Outbound Service Interface Properties


                        Create the inbound service interface with the name "SIIS_ReadersParadiseWebservicex" in the urn:readersparadise.com:currency:webservicex namespace, and set the properties as shown in Figure 6.57.
                    

                        Save and activate the objects created so far.
                    

You're now done creating objects in the Enterprise Services Repository.

Figure 6.57    Inbound Service Interface Properties

Note
For this scenario, no mappings will be created because the structures of the outbound and inbound service interfaces are exactly the same.

Create and Configure the iFlow
Before starting, you need to make sure that SAP NetWeaver Developer Studio has been configured to point to your SAP PO machine. In particular, check that SAP NetWeaver Developer Studio is configured to connect to the ES Repository and to the SAP PI Configuration Tools node (refer to Section 6.1.2 for more details).
To create an iFlow, follow these steps:


                        From SAP NetWeaver Developer Studio, switch to the SAP Process Integration Designer perspective, and log on.
                    

                        Import the two business systems (BS_READERSPARADISE and BS_ BOOKFOUNTAIN) created in the Chapter 3 exercise. Figure 6.58 shows how to start the import.
                    


Figure 6.58    Importing the Business Systems from the SLD
With the business systems now available in SAP NetWeaver Developer Studio, you can create the iFlow by following these steps:


                        Right-click on the Integration Flow node, and select the New Integration Flow option. Name the new iFlow "IF_ReadersParadiseCurrencyService".
                    

                        On the first screen of the wizard, select the options as shown in Figure 6.59.
                        
Figure 6.59    iFlow Properties Options to be Selected


                        Click on the Finish button.
                    

                        Configure the sender system by right-clicking on the sender system component and selecting the Assign Business system option.
                    

                        Choose the BS_READERSPARADISE business system.
                    

                        Right-click on the interface component, and choose Assign Interface.
                    

                        Choose SIOS_ReadersParadisePortal.
                    

                        Right-click on the channel adapter component, and select the Configure Channel option. Set the properties of the channel as shown in Figure 6.60.
                        
Figure 6.60    The iFlow's Sender Communication Channel Configuration


                        Configure the receiver system by right-clicking on the sender system component and selecting the Assign Business System option.
                    

                        Choose BS_BOOKFOUNTAIN as the business system.
                    

                        Select the interface component on the receiver, and choose the option Assign Interface.
                    

                        Choose SIIS_ReadersParadiseWebservicex.
                    

                        Right-click on the channel adapter component, and select the Configure Channel option. Set the properties of the channel as shown in Figure 6.61.
                    

                        Configure the endpoint on the receiver channel by clicking on the Adapter-Specific tab and setting the Target URL to http://www.webservicex.net/CurrencyConvertor.asmx and the Action to http://www.webserviceX.NET/ConversionRate.
                        When you're finished, the iFlow should look like Figure 6.62.
                    

                        Activate the iFlow by right-clicking on the IF_ReadersParadiseService entry (on the PI explorer view located on the left side of SAP NetWeaver Design Studio) and selecting the Activate option.
                        
Figure 6.61    The iFlow's Receiver Communication Channel Configuration

Figure 6.62    Overview of the Created and Configured iFlow


                        When asked if you want to activate, click Yes to complete the iFlow activation.
                    

                        Right-click one more time on the iFlow, and select the Deploy option to deploy it into the server. When the deployment is triggered, click Yes in the popup that appears. This will deploy the iFlow into the SAP PO server.
                    

Now that you're done with the deployment, it's time to test the iFlow.
Testing
To test the iFlow that has been deployed in the server, follow these steps:


                        Log on to the Integration Directory, and expand the Integration Flow node.
                    

                        Open the ICO created as a result of the iFlow. From the ICO, click on the Integrated Configuration menu item, and select the Display WSDL option (see Figure 6.63).
                    

                        Save the WSDL to your local machine.
                        
Figure 6.63    Displaying the iFlow WSDL


                        Simulate the Reader's Paradise portal with the SOAP UI client tool. SOAP UI is an external open source tool.
                    

                        Import the saved WSDL into the SOAP UI as a new project (see Figure 6.64).
                    


Figure 6.64    SOAP UI Client Request and Response Messages









6.7    Summary
The concept of working with iFlows has now been simplified. We explained that the first step in working with iFlows is setting up SAP NetWeaver Developer Studio, making sure to install a version compatible with SAP NetWeaver AS Java. Then, we detailed how to create and configure iFlows from the SAP PI Designer perspective.
The next chapter will focus on how to monitor and administer interfaces running in the Advanced Adapter Engine Extended (AEX).








7    Administration and Monitoring in AEXThe mind is like a parachute. It works best when it is open.                                                                                                  —The Dalai LamaAn enterprise service bus (ESB) often supports critical business processes across and beyond the enterprise. That statement certainly applies for an ESB such as SAP Process Orchestration (SAP PO), which in most cases is positioned as the integration layer between SAP and the rest of the world, providing integration services to different types of systems and processes. When installed as a Java-only stack, the Advanced Adapter Engine Extended (AEX) shares many administration and monitoring functions within the orchestration or SAP Business Process Management (SAP BPM) layer. In this chapter, we'll only concentrate on the messaging exchange part, which takes place on the AEX.
7.1    Administration
It's essential for any SAP PO administrator to have a 360-degree overview of the SAP PO landscape and be actively aware of the current status and correct functioning of every component participating in the integration scenarios. The high relevance of those areas within the context of SAP PO also becomes clear when you open the Integration Builder start page of your SAP PO environment and notice the presence of specific tools for Configuration and Monitoring (Figure 7.1). In Chapter 2, we gave you a general introduction to the available administration tools and talked about their roles and usage in SAP PO. From an administrator's perspective, that set of tools represents his daily routine and provides him with a complete toolbox filled with plenty of tools specially designed to ease his job.

Figure 7.1    AEX Administration Tools
Depending on how your support organization has introduced procedures and structured the way in which system administrators manage the administration of SAP PO's infrastructure and application landscape, you'll need to be familiar with the administration tools found in the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java) stack that we discuss in the following sections. Furthermore, you'll need to distinguish the functionality provided by each of these tools and, based on a quick analysis, decide when to look where for what. Having that ability will help you track down the source of runtime issues more quickly and troubleshoot problems in an effective way. The following sections describe the main AEX tools used for different types of administrative purposes.
7.1.1    Central Administration Tool
The central administration web-based tool allows you to access different types of system information. With the proper system administrator rights, you can also edit parameters at both general and detail levels. The tool is divided into three main tabs: Repository, Directory, and Runtime.
This tool is often used to remove locks on Integration Repository and Integration Directory design objects. You also use it to check and refresh the cache (data or runtime) at different component levels by navigating in the tree structure to the Lock and Cache Administration category (see Figure 7.2).
To access the Administration page from the Integration Builder start page, go to http://<hostname>:<port>/dir, where <hostname> is the hostname of the SAP PO system, and <port> is the port number of that same SAP PO system. For example: http://po74.rojoconsultancy.com:50030/dir.
When you're on that page, click on Administration from the top-right menu.

Figure 7.2    Central Administration Tool
7.1.2    SAP NetWeaver Administrator
The SAP NetWeaver Administrator is a web-based tool that provides different views and options for simple and advanced system administration, monitoring, debugging, troubleshooting, and diagnosing of AEX integration scenarios. It serves as an entry point for all common administrative operations for any SAP NetWeaver AS Java stack system, including SAP PO.
To access SAP NetWeaver Administrator, go to http://<hostname>:<port>/nwa, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
7.1.3    SAP NetWeaver Application Server Java
The central page of SAP NetWeaver AS Java serves as a collection of multipurpose tools, including the User Management tool and the Web Services Navigator. From there, you can also access the SAP NetWeaver Administrator and the Service Registry (SR).
To access the SAP NetWeaver AS Java start page, go to http://<hostname>:<port>, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
7.1.4    SAP Process Integration Monitoring (pimon)
Monitoring Home (pimon) is the tool that replaces the old Runtime Workbench (RWB) from previous versions of SAP Process Integration (SAP PI). This tool comes packed primarily with monitoring tools, but it also contains some helpful configuration and administration tools, which you might find good to know when working in the field. For example, you can configure rules for message prioritization and user-defined message search, which makes it possible to search specific messages based on particular attributes inside the message.
To access the Monitoring Home (pimon), go to http://<hostname>:<port>/pimon, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
7.1.5    SAP Management Console
The SAP Management Console is probably not the most well-known tool in the family of AEX administration tools. However, in some situations it can save you time and energy to use SAP Management Console when troubleshooting an issue. It provides a common framework for centralized system management. From SAP Management Console, you can monitor and execute basic administration tasks on the SAP PO system, such as starting or stopping the application server, monitoring the system operation and performance, monitoring log files, and so on. There are currently three different versions and ways to run SAP Management Console:


Web-based tool SAP Management Console runs from any web browser supporting Java, so there is no need for a local SAP NetWeaver AS Java installation.
                

Eclipse based SAP Management Console is integrated in the SAP NetWeaver Developer Studio to enable application developers to administrate and monitor their local and remote systems from their development environment without the need to use additional administration tools.
                

Standalone SAP Management Console is available as an SAP Systems Manager snap-in developed for the Microsoft Management Console (MMC), which is currently available for Windows systems only.
                

To access the SAP Management Console, go to http://<hostname>:<port>, where <hostname> is the host on which the application server of the SAP system or instance is installed, and<port> is the sapstartsrv service port of the SAP NetWeaver system. The port number is as follows: 5<instance_number>13. For instance, if the instance number is 00, then the port is 50013.
We recommend that you use the web-based SAP Management Console to manage SAP NetWeaver AS Java systems. Note that your web browser must support Java applets.
7.1.6    Config Tool
The Config Tool is used to perform advanced configuration tasks on an offline SAP NetWeaver AS Java system. You can use this tool to add server processes to an existing Java instance, edit SAP Java Virtual Machine (SAP JVM) parameters, check and configure system properties, and so on. The Config Tool can be run either via the GUI or from the console. When the Config Tool is accessed via the GUI or command console interface, it connects to the database and scans the server configuration.
Be aware that most of the changes performed using the Config Tool do require a system restart to take effect. To start the GUI Config Tool, double-click on the configtool script file in the <SAP_install_dir>/<system_name>/<instance_name>/j2ee/configtool directory. To start the command console Config Tool, double-click the consoleconfig script file in the <SAP_install_dir>/<system_name>/<instance_name>/j2ee/configtool directory.
7.1.7    Administration Using Telnet
This tool is used for console administration of an SAP NetWeaver AS Java system via telnet via a predefined set of shell commands that you need to execute on the command line.
For security reasons, telnet console access is limited to localhost, so it can't be accessed remotely.









7.2    Monitoring
The AEX offers a variety of tools for monitoring the central adapter engine, communication channels, and other integration server components. In contrast to its dual-stack (Java/ABAP) processors, the AEX delivers monitoring centralization by providing a dedicated toolset with focus on the Java stack.
You can monitor the AEX via the following tools:


                SAP NetWeaver Administrator
            

                System-wide monitoring covering all AEX components, regularly used to perform advanced monitoring
            

                SAP PI monitoring
            

                Local monitoring with a selection of AEX core components, generally used for traditional message and communication channel monitoring
            

                SAP PI central monitoring with SAP Solution Manager
            

                Central SAP PI landscape monitoring with drilldown functionality to specific SAP PI local components
            

We'll go over the most frequently used of these tools in the following sections.
7.2.1    SAP NetWeaver Administrator
From SAP NetWeaver Administrator, you can access all local monitoring tools related to the AEX, including the SAP PI local monitoring (pimon). From the SAP NetWeaver Administrator, you can also access less common types of monitoring, such as performance and availability monitoring, process monitoring, database-related monitoring (e.g., Java Persistence API [JPA] and Open SQL), and Java archiving jobs monitoring.
SAP NetWeaver Administrator can be accessed at http://<host>:<port>/nwa, where <host> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system (see Figure 7.3).

Figure 7.3    SAP NetWeaver Administrator: Monitoring Home
7.2.2    SAP Process Integration Local Monitoring
Each AEX installation has its own SAP PI local monitoring tool that you can use to monitor different system areas, including message traffic, communication channels, and data and runtime caches.
SAP PI local monitoring (pimon) can be accessed at http://<hostname>:<port>/pimon, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system (see Figure 7.4).

Figure 7.4    SAP PI Local Monitoring: pimon
Via SAP PI local monitoring, you can access the following AEX monitoring tools:


Message Monitor The main message monitoring tool for all messages processed via the AEX shows aggregated and fine-grained information about the status of messages sent and received. Manage individual messages, for example, by resending individual message versions. See Figure 7.5, Figure 7.6, and Figure 7.7 for an impression of this monitoring tool.
                

IDoc Adapter Monitor The extensive IDoc monitoring tool provides an overview of all message traffic and metadata processed via the AEX central adapter engine.
                

Channel-Independent Logs Displays execution steps (in a very simple way) of adapters that can't be assigned to a particular communication channel.
                

Cache Monitor Provides an overview of current cache objects maintained by the adapter engine and mapping runtime.
                

CPA Cache History This traditional CPA cache monitor displays an overview of cache refresh actions and their statuses.
                

Adapter Engine Status Provides detailed information about the adapter engine, including queues, message traffic (e.g., amount of asynchronous or synchronous message backlog), database locks, overview of messages processed or being processed per sender, and receiver components.
                

Performance MonitorMonitors the performance of message processing by inspecting the amount of processed data over various periods of time and the message processing time for individual adapter modules. Additional configuration is needed in the Config Tool for this functionality to work properly.
                

Background Job Processing Monitor Displays an overview of background jobs (e.g., adapter engine, adapter framework scheduler jobs, etc.) and offers the ability to manage them.
                

Figure 7.5 shows the tabular view of the message overview, including status and other relevant data. Depending on your needs, you can select a predefined hourly, daily, weekly, monthly, or yearly time range.

Figure 7.5    pimon Message Monitor: Overview
You can make a selection by clicking on one of the columns containing the message statuses on the left of the screen. The specific set of messages for that particular integration scenario will be opened on the Database tab (see Figure 7.6).

Figure 7.6    pimon Message Monitor: Message List
Take note that your log, trace, and message retention settings should be properly configured to display messages with certain statuses on the Database tab.

Note
The topic of message retention is briefly introduced in Section 7.2.4. For a complete overview of monitoring and housekeeping jobs, see Chapter 19 which explains those topics in more depth.

After the messages are displayed, you can either apply additional filters or select a particular message from the list presented on the Database tab. You can then proceed to analyze different attributes (processing context data, header information, payload, logs, etc.) of the message, or, if permitted by the message status, you can cancel or retry all messages with that particular status (see Figure 7.7).
The third and last tab (Archive) shows all messages (or their metadata) that have been previously archived.

Figure 7.7    pimon Message Monitor: Message Details
7.2.3    SAP PI Central Monitoring with SAP Solution Manager
We have a good foundation and understanding thus far of what the AEX has to offer in terms of administrative and monitoring tools. With that set of tools, you should be able to manage an AEX installation. However, when the size of your integration landscape, the amount of integration scenarios, and their complexity (e.g., interlinked business process management [BPM] processes, business-to-business [B2B] integration, etc.) starts to grow significantly, you might want to add more control, react more quickly to incidents, and gain more insights about important events flowing in and out of your AEX landscape. When you reach that stage, you need to be prepared to bring your support organization to the next level and start seriously considering introducing a new component next to your SAP PO installation.
SAP Solution Manager is a multipurpose central support and system management platform that is fully equipped to be the central backbone that manages all SAP PO and SAP backend components within your SAP system landscape. Its complete list of features goes beyond the administration and monitoring of SAP PO, which also makes this component attractive to organizations wanting to reduce the total cost of ownership (TCO) and to efficiently harmonize the tasks performed by SAP Basis specialists.
From SAP Solution Manager 7.1 on, you can enable central SAP PI monitoring. This functionality provides unified alert notifications and incident management, as well as a pivotal overview of exceptions, alerts, and statuses of SAP PI components (see Figure 7.8).

Figure 7.8    SAP PI Central Monitoring in SAP Solution Manager
In addition, SAP Solution Manager also provides options to drill down into the details of recorded exceptions in the respective SAP PI components and integrated business systems. Furthermore, component-based alerting is supported, and message alerts can be sent via email and SMS to administrators.
SAP Solution Manager has the following core capabilities for administering and monitoring AEX installations:


                    Overview monitor, including integration server, central/decentral adapter engines, and business systems (including ABAP proxies)
                

                    Central message monitoring
                

                    Root-cause analysis
                

                    Unified Alerting Infrastructure and Inbox
                

                    Notification via email and SMS
                

                    Incident management and ticketing
                

                    Central SAP PI message search (user-defined search)
                

These capabilities become essential when executing the following administrative tasks:


                    End-to-end error detection to perform root-cause analysis
                

                    Spot and troubleshoot performance bottlenecks
                

                    Support system upgrades and changes
                

                    Regular system health checks
                

                    Handover procedures
                

                    Trends analysis (see Figure 7.9)
                

The list of applicable areas of relevance for SAP Solution Manager is definitely much more extensive than the areas we've just discussed; in fact, we could write two entire books dedicated to this interesting component alone. However, within the context of AEX administration, the points addressed previously provide a good example of what you can achieve with this tool.
Whether you want to inspect the status of independent components in your SAP PO installation, check the availability of certain communication channels, or search for specific messages passing through the AEX, monitoring is the common denominator.
In the AEX, there are alternatives to help you achieve the monitoring goals mentioned previously and much more than that, as you'll discover.

Figure 7.9    SAP PI Monitoring: Aggregated Error Monitoring in SAP Solution Manager
7.2.4    Message Retention
The message retention function defines the period for which messages processed via the AEX are to be kept in the database before they are archived or deleted. The message retention only applies to messages that have a successful or canceled status.
The AEX has a global retention period of one day that is set for all message types. If required, the global retention period can be changed accordingly. This can be achieved by changing the following parameters in the SAP NetWeaver Administrator (choose Configuration • Infrastructure • Java System Properties • Services • XPI Adapter: XI): xiadapter.inbound.persistDuration.default and xiadapter.outbound. persistDuration.default.
If your organization requires messages of a specific interface to be kept for a longer period than one day, then a specific message retention period can be configured for the affected interface.
7.2.5    User-Defined Message Search
The message monitor that comes with SAP PO is a powerful and indispensable tool for any developer, whether for simple interface monitoring, operational support, or testing, messages flowing through the adapter engine are periodically searched and analyzed. However, the default search options in the message monitor have some limitations; you can only search for messages based on some predefined search criteria such as interface name, date-time, or message status as search criteria. The message monitor also provides a special search feature called user-defined message search that can be found on the database view as part of the advanced options. You can enable this feature by defining a new filter via SAP NetWeaver Administrator or via the SAP PI monitoring tool, as shown in Figure 7.10.

Figure 7.10    User-Defined Message Search
User-defined message search allows you to find messages by searching for specific key information (e.g., customer ID, vendor ID, material number, etc.) contained at the message header or payload of messages exchanged between communication components. You can define as many predefined search filters as needed, and filters can be used for both asynchronous and synchronous interfaces. This functionality is available for the ABAP and Java stack of SAP PI; however, in this book, we only cover the Java part.

Note
The IDoc adapter monitor is a specialized message monitor tool for monitoring inbound and outbound IDoc messages sent through the IDoc adapter. With the IDoc adapter monitor, it's possible to specify more parameters as search criteria at the header level data (e.g., IDoc number, IDoc type, direction, etc.), but it doesn't offer ways to search through the contents of the payload.

To configure user-message search functionality for one or more of your interfaces in SAP PO, follow these steps:


Navigate to the home page.Navigate to the Monitoring Home (pimon), and then go to http://<hostname>:<port>/pimon, where <hostname> is the hostname of the SAP NetWeaver system and <port> is the port number of the SAP NetWeaver system.
                

Create a new filter. Choose Configuration and Administration • Adapter Engine • User-Defined Message Search Configuration. Enter the parameters for the filter. Click New, and enter the Name, Description (optional), Interface, Sender Component, Receiver Component, and so on. In this configuration screen, you can also decide to immediately activate or deactivate the filter. Save your work when finished, as shown in Figure 7.11.
                    
Figure 7.11    User-Defined Message Search Filter


Add search criteria to the new filter. Select the new filter for which you're creating a search criteria, and click New on the Search Criteria tab. You can add one or more search criteria to your filter. You can choose one of the following types of search: self-defined XPath expression, Dynamic Header, or Custom Dynamic Header. Click Save when done, as shown in Figure 7.12.
                

Configure the namespace prefixes. If you've created filters of type XPath, then you must also define the corresponding namespace prefix for it to work correctly (see Figure 7.13). We recommend you always configure a namespace prefix for all filters you create, even if you haven't created an XPath filter.
                    
Figure 7.12    User-Defined Message Search Criteria

Figure 7.13    User-Defined Message Search Namespace Prefix


Perform indexing (optional). Perform an initial indexation (i.e., also include already processed messages in your search results) if necessary (see Figure 7.14). This step is optional as the system will automatically run indexation when a new filter is created. SAP PO doesn't index messages that are marked sensitive in the Enterprise Services Repository (ES Repository) as these messages contain confidential information.
                


Figure 7.14    User-Defined Message Search Indexing
Finally, after you've performed all the preceding steps, you can return to the Message Monitor screen and start using the new search filter, as follows:


                    Go to http://<hostname>:<port>/pimon, where <hostname> is the hostname of the SAP NetWeaver system, and <port> is the port number of the SAP NetWeaver system.
                

                    Select the PI Messages tab, and click the Advanced link at the right of the screen. You should now see the view shown in Figure 7.15.
                    
Figure 7.15    User-Defined Message Search Advanced Options View


                    Select User-Defined Search Criteria, and choose Add Predefined to select the filter from a populated list of available predefined filters, as shown in Figure 7.16. You can also add a custom filter on the fly if necessary.
                    
Figure 7.16    User-Defined Message Search Select Predefined Filter


                    Now that you've selected a filter, you can enter the search value you're looking for in messages. In this example, we've entered a specific ID (12345) as the value to search for (see Figure 7.17).
                

                    Click the Go button, and check the results of your search filter.
                


Figure 7.17    User-Defined Message Search Value









7.3    Troubleshooting
In SAP PO, there are different ways of troubleshooting and debugging runtime exceptions and other types of erroneous events. In this section, we'll explain how you should manage troubleshooting situations in SAP PO.
Imagine it's Friday afternoon—almost the end of a busy week—and you receive an alert message with high priority from a production system, indicating that there's an issue with an interface. When that happens, you know that your organization relies on your knowledge and ability to analyze the source of the error and ultimately remedy the incident.
An integration platform such as AEX plays a critical role in any enterprise at both the technical and business levels. That criticality arises as a result of supporting a diversity of information flows of different kinds (e.g., system to system and human to system). It also automatically means that the pressure and responsibility of guaranteeing the availability and performance of that system also increases. It's extremely important for you as the integration specialist to find your way through SAP PO's constellation of available tools, transactions, views, and URLs. SAP PO provides several types of monitoring that can be accessed using different methods. Which method is appropriate for you depends on the specific issue you need to troubleshoot and the shape and architecture of your integration landscape.
In addition to having access to the right tools and knowledge to troubleshoot any integration incident that might happen inside the AEX, you also need to have an effective strategy that you can apply when you need to solve an issue. The following list provides an overview of the types of information you should have, know, ask for, or collect in advance before trying to fix a bug or support production incidents inside the AEX:


                The name and repository namespace of the interface causing trouble. This sounds quite trivial, but sometimes this simple check can save you effort.
            

                Type of the interface (e.g., ABAP proxy, Java proxy, Remote Function Call/Business Application Programming Interface [RFC/BAPI], IDoc, web service, file, etc.) to help you create a helicopter view of the situation and get more input to feed your problem analysis.
            

                Type of communication (i.e., synchronous or asynchronous). The runtime behavior and Quality of Service (QoS) of synchronous and asynchronous interfaces is totally different and thus critical for your initial analysis.
            

                Sender and receiver(s) of the interface (i.e., who is sending what to whom).
            

                Whether all RFC destinations (ABAP stack, SAP backend) and service groups (Java stack, SAP PO) are well configured and up and running, to determine whether the issue is caused by a missing communication link with one of the involved systems.
            

                Whether the messages originated in an SAP backend system.
            

                Whether the messages were sent without errors from the ABAP stack. You can check this using Transaction SXMB_MONI (Monitor Local PI Engine on ABAP stack), Transaction WE05 (Monitor IDoc Traffic), and Transaction SM58 (Monitor Transactional RFC).
            

                Original message payload or message GUID of missing message (if applicable). You can use the payload to analyze the contents of the message, test the mapping, or try to resend it again in the case of synchronous communication.
            

                Date and time when the issue with the interface was detected. This information will help you narrow down the messages causing the problem and probably also the source of the issue.
            

                Who or what is the trigger of the outbound/inbound interface to understand the business process behind the interface.
            

                Average size of the messages, so you can assess whether the problem is caused by too large of a message entering or leaving the AEX.
            

                Average volumes to give you an idea of the number of messages normally processed on a daily basis.
            

                Whether the issue is reproducible on other AEX environments (e.g., development, test, etc.). That way, you can isolate the problem to a certain environment or system parameter.
            

                Whether you've recently successfully refreshed the SAP PO caches (both data and runtime). It's known that SAP PO caches data at different levels, mainly for performance reasons, but this approach is sometimes also responsible for unreproducible issues.
            

                Whether the interfaces were built originally for SAP PO or migrated from SAP PI (dual-stack) to SAP PO, to avoid any chance of possible incompatibilities between system versions.
            

This list can serve as the starting point for what can be promoted as the standard procedure to tackle integration incidents happening around the AEX. Let's now take a look inside the tools that will help you troubleshoot your SAP PO interfaces in an effective way.
As mentioned in Section 7.1, the SAP NetWeaver Administrator is a web-based tool that serves as a common entry point for performing different administrative and monitoring activities. One of those activities is analyzing the contents of log entries generated as a result of erroneous or unexpected situations during runtime, which we'll now show you how to do in the AEX.
7.3.1    Configuring Log and Traces
Navigate to the SAP NetWeaver Administrator, and select the Troubleshooting tab. Assuming you have the proper administrative rights in the SAP PO environment, you should now see a screen like the one shown in Figure 7.18.

Figure 7.18    Troubleshooting: Log Configuration
From the Troubleshooting tab, click on the Logs and Traces link. From there you have the following options:


Log ConfigurationConfigure or edit the severity of logs and traces via the Log Configuration screen at the component level.
                

Security Troubleshooting WizardTroubleshoot security-related issues with a wizard-based diagnostic tool.
                

Log ViewerQuery logs and gather background information about interface- and system-related exceptions at different log levels created by components running under the AEX (Figure 7.19).
                


Figure 7.19    Troubleshooting: Log Viewer
Via Log Configuration, you can set or edit the desired debug and trace levels for a particular component, such as adapters, adapter modules, standard AEX components, and so on. In Figure 7.18, the log level of different adapters was configured to log events (exceptions) that fall under the Fatal category.
You can find the standard SAP PI adapters in the following tree structure ROOT CATEGORY/Applications/ExchangeInfrastructure/AdapterFramework/Services/ADAPTER/ADMIN/.

Tip
In the Category field, type the name of the adapter (e.g., "jms", "file", etc.) for which you want to set or edit the log or trace level, and click Go when you're finished.

7.3.2    Using the Log Viewer
The error information displayed in the AEX message monitoring after an interface exception has occurred won't always be sufficient to help you get a clear understanding of the exact source of the problem. To collect additional information about the exception, you'll have to dig deeper into the error logs and find out what else has been logged for the same error.
Within SAP NetWeaver Administrator, there is a tool that facilitates exactly that job. Via the Log Viewer, an administrator can select and open different overviews that show distinct log categories. Depending on the nature of the error, you can select the relevant log category. Developer traces is the type of log you'll be using in most occasions. In that particular overview, you'll find additional details about interface and system-wide exceptions.
Figure 7.20 shows how you can select the correct view from a dropdown menu. After the correct selection has been made, the overview (see Figure 7.21) is displayed on the screen. From that same screen, you can also narrow your log search by applying specific filters (click on the Show Advanced Filter button). You can, for instance, filter based on message ID, exception contents, error severity, application, date and time, and so on. You can also apply similar filters by entering a keyword at the top of the tabular view.

Figure 7.20    Troubleshooting: Log Viewer, Open View
When you've found a suspicious entry in the overview, you can select it from the list and click on the Plus icon to expand and read its contents (see Figure 7.22).

Figure 7.21    Troubleshooting: Log Viewer, Developer Traces

Figure 7.22    Troubleshooting: Log Viewer, Error Details Expanded









7.4    Summary
In this chapter, we explored different existing tools and approaches (local and central) for managing and monitoring your SAP PI landscape from different angles. Whether you're managing a simple or complex integration landscape or performing component or messaging monitoring, the AEX offers an integrated and complete toolset to put you in control of your integration solutions running on top of the AEX.
We also looked at the role and added value provided by SAP Solution Manager when positioned as a central monitoring platform. Its main features in terms of central alerting and root-cause analysis are essential for keeping your AEX installations in good shape and for reacting fast when problems arise.
We covered all relevant AEX administration and monitoring tools, including topics such as message retention and user-defined message search. We also showed you how to perform administration tasks using the SAP NetWeaver Administrator, including monitoring message traffic, communication channels, and caches.
Finally, we explained how to deal with exceptions on the Java-only stack and how you can effectively debug and analyze those error situations by making use of the standard logging functionality provided by the AEX.
If you're still running an old-school SAP PI dual-stack system, the next chapter helps you prepare your migration strategy from a dual to a single Java stack by walking through the different options to reach that goal.








8    Migrating Interfaces from SAP PI Dual Stack to SAP POTrue genius resides in the capacity for evaluation of uncertain, hazardous, and conflicting information.                                                                                             —Winston ChurchillAfter reading the previous chapters, you now know many reasons to choose SAP Process Orchestration (SAP PO) as the ultimate enterprise service bus (ESB) for all your SAP-related integrations. If you're currently using the dual stack of SAP Process Integration (SAP PI), then you've also been provided with reasons to migrate to SAP PO.At this point in the book, you've built up the necessary knowledge to create interfaces and all the related supporting objects from scratch. So far, it has been assumed that you have to build brand-new interfaces in SAP PO, but this is obviously not always the case. You might face a situation in which your interfaces have already been built in an SAP PI dual stack, and the need arises to migrate to an SAP PO installation (or a Java-only stack). Understanding the challenges and steps involved in a migration from an older version of SAP PI (dual stack) to SAP PO is the main purpose of this chapter.Note that the chapter won't focus on how to upgrade or install an SAP PO system. Instead, it will explore the different aspects of migrating the actual interfaces and content. We'll begin by discussing the various migration strategies. Then, we'll discuss migration System Location Directory (SLD) content, Enterprise Services (ES Repository) content, and Integration Directory content.
8.1    Migration Strategies
The approaches and strategies to be used during a migration will be heavily influenced by your current infrastructure setup, requirements, and SAP PI installation version and flavor. The strategies explored here assume that the source system (that you want to migrate) is an SAP PI dual stack (ABAP and Java).
When starting the migration project, it's important to decide between the following SAP PO installation or upgrade options:


In-place upgrade With this option, most of the initial activities are performed on the source system. The following general guidelines need to be followed:
                

                        The current or existing SAP PI (dual stack) will need to be upgraded to a later dual-stack release (to version 7.31 at a minimum). Let's call this system the source system.
                    

                        All existing ABAP-based Integration Directory objects will need to be converted to their Java equivalents in the same installation (when possible). This can be done manually or by using the Migration tool provided by SAP.
                    



Side-by-side migration With this option, you'll directly install a new SAP PO target system, in which most activities will be performed. The source system is left intact. From a high-level perspective, the steps involved in this migration option include the following:
                

                        Install a new SAP PO system running next to your existing (source) SAP PI dual-stack system.
                    

                        Rethink and redesign your existing ABAP-based objects, including ABAP mappings and cross-component Business Process Management (ccBPM) processes.
                    

                        Migrate relevant SLD objects, manually or by using the transport mechanism.
                    

                        Migrate relevant ES Repository objects, manually or by using the transport mechanism.
                    

                        Migrate relevant Integration Directory objects, using the Migration tool or manually.
                    



In the next section, we'll focus on the migration steps involved when using the side-by-side migration option because it's the most commonly used. During migration, you're creating a transition time during which you'll have your old SAP PI and your new SAP PO installations running side by side (see Figure 8.1). After a successful migration, you'll then switch off the old SAP PI installation and redirect all traffic to the new SAP PO installation. This strategy and approach will dramatically reduce the needed downtime.

Figure 8.1    Side-by-Side Migration: SAP PI Dual Stack to SAP PO

Tip
Note that if you're currently not using ccBPM processes, and you're not planning to use any business processes in the future, then you might consider installing only the Advanced Adapter Engine Extended (AEX) instead of SAP PO as a target system.

Before getting into the details of the different options available for the actual content migration, we want to highlight some of the differences between the SAP PI dual stack and SAP PO, which have an impact on the choices you'll make for the migration. Table 8.1 details some of the differences between the two installation types.




                        Features
                    

                        SAP PI (Dual Stack)
                    

                        SAP PO
                    





Development tools and integrated development environment (IDE)
                    

                        Swing client and SAP NetWeaver Developer Studio
                    

                        Swing client, SAP NetWeaver Developer Studio (can now be used for nearly all development) and SAP NetWeaver development infrastructure (used for source control).
                    



                        Application server (AS)
                    

                        Both SAP NetWeaver AS ABAP and SAP NetWeaver AS Java supported
                    

                        Only SAP NetWeaver AS Java supported.
                    



                        Mapping


                        Message mapping, Java mapping, and ABAP mapping
                    

                        All the mapping possibilities are also supported, except for ABAP mapping; ABAP mapping will need to be redesigned as message mapping, Extensible Stylesheet Language Transformations (XSLT), or Java mapping.
                    



                        Business process support


                        ccBPM, which is based on the SAP NetWeaver AS ABAP
                    

                        SAP Business Process Management (SAP BPM) is provided instead. SAP BPM is purely based on SAP NetWeaver AS Java.
                    



                        Data and value mapping


                        Fixed values and value mapping
                    

                        Fixed values, value mapping, and SAP Business Rules Management (SAP BRM). The decision table of SAP BRM can also be used in some cases.
                    



                        Custom tables


                        Custom ABAP tables built in SAP PI
                    



                                Possible to create a SQL table to perform lookups.
                            

                                Consider using SAP BRM.
                            

                                SAP Composite Application Framework (SAP CAF) can also be used.
                            

                                Custom ABAP table in an SAP backend, and use Remote Function Call (RFC) lookup in your message or graphical mapping.
                            





                        Interface configuration


                        Traditional "classic" configuration (based on SAP NetWeaver AS ABAP), Integrated Configuration (ICO), and integrated flow (iFlow)
                    

                        ICO and iFlow. Traditional "classic" configuration is no longer supported due to the removal of SAP NetWeaver AS ABAP.
                    



Table 8.1    Differences in Functionalities between SAP PI Dual Stack and SAP PO
We're assuming here that you've already installed SAP PO in your landscape and that you're now ready to start the content migration. Consider Table 8.1 for a mapping of the alternative Java-only objects for the existing ABAP-based objects. For example, from the table, you can establish that ABAP mappings will need to be re-created as message, Java, or XSLT mappings.
During the content migration, you need to follow a strategy that allows you to migrate existing components to their equivalent in the new system, starting with the least-dependent component group. The next section will explore the migration of each of these component groups.









8.2    Migrating System Landscape Directory Content
Assuming that you have a separate/local SLD in the target system, you'll need to perform an export of objects in the source system and import them into the target system. Although you can back up the entire SLD with all included objects and restore it in the target system, we want to propose the approach of selecting the individual needed objects and exporting them. This ensures that you don't pick unused objects and therefore avoid polluting your new SAP PO system with unnecessary data.
Even better, you can use the transport mechanism to move the selected objects from your source to the target system instead of using the manual export or import. Be reminded, however, that using the transport mechanism will mean that you'll need to first enable the transport mechanism for the newly installed SAP PO system. Let's look at how to manually export and import. We won't touch on the transport mechanism here because this is business as usual, and you should already be familiar with it.
Different object types need to be exported from the SLD. Because of the dependencies between the different objects, the objects need to be exported in the following chronological order: products, software components (SCs), technical systems, and business systems. You need to export the following object types from the source SLD and import them into the target SLD system.
8.2.1    Products
To export the products objects from the source SAP PI's SLD, follow these steps:


                    From the SLD landing page, click on the Products link.
                

                    Select the products that you want to migrate. Note that you can select multiple products at the same time.
                

                    Click on the Export button.
                

                    When prompted, select a location on your local file system where the file needs to be saved and name the file. The export will be saved as a TPZ file.
                

You're now ready to import the exported products into the target SAP PO's SLD system. To do so, follow these steps:


                    Log in to the target SAP PO's SLD, and click on the Administration link (top-right corner).
                

                    From there, click on the Import button, and select the product's TPZ file that you previously exported.
                

                    After the import process has finished running, look at the logs to check that all went well or to resolve issues, depending on errors mentioned in the logs. Alternatively, go to the product list to verify that the products you imported are now present.
                

8.2.2    Software Components
To export the SC objects from the source SLD, follow these steps:


                    From the SLD landing page, click on the Software Component link.
                

                    Select the SCs that you want to migrate. Note that you can select multiple SCs at the same time.
                

                    Click on the Export button.
                

                    When prompted, select a location on your local file system (where the file needs to be saved), and name the file. The export will be saved as a TPZ file.
                

You're now ready to import the exported SCs into the target SAP PO's SLD system. To do so, follow these steps:


                    Log on to the target SAP PO's SLD, and click on the Administration link.
                

                    From there, click on the Import button, and select the SC's TPZ file that you previously exported.
                

                    After the import process finishes running, look at the logs to check that all went well or to resolve open issues, depending on errors mentioned in the logs. Alternatively, go to the SC list to verify that the components that you imported are now present.
                

8.2.3    Technical System
To export the technical system objects from the source SAP PI's SLD, follow these steps:


                    From the SLD landing page, click on the Technical Systems link.
                

                    Select the technical systems that you want to migrate. Note that you can select multiple technical systems at the same time.
                

                    Click on the Export button.
                

                    When prompted, select a location on the file system (where the file needs to be saved), and name the file. The export will be saved as a TPZ file.
                

You're now ready to import the exported technical systems into the target SAP PO's SLD system. To do so, follow these steps:


                    Log on to the target SAP PO's SLD, and click on the Administration link.
                

                    From there, click on the Import button, and select the technical system's TPZ file that you previously exported.
                

                    After the import process finishes running, look at the logs to check that all went well or to resolve open issues, depending on errors mentioned in the logs. Alternatively, go to the technical system list to verify that the technical systems that you imported are now present.
                

8.2.4    Business System
To export the business system objects from the source SAP PI's SLD, follow these steps:


                    From the SLD landing page, click on the Business Systems link.
                

                    Select the business systems that you want to migrate. Note that you can select multiple business systems at the same time.
                

                    Click on the Export button.
                

                    When prompted, select a location on the file system (where the file needs to be saved), and name the file. The export will be saved as a TPZ file.
                

It's time to import the exported business systems into the target SAP PO's SLD system. To do so, follow these steps:


                    Log on to the target SAP PO's SLD, and click on the Administration link.
                

                    From there, click on the Import button, and select the business system's TPZ file that you previously exported.
                

                    After the import process finishes running, look at the logs to check that all went well or to resolve open issues, depending on errors mentioned in the logs. Alternatively, go to the business system list to verify that the business systems that you imported are now present.
                

Note that you can also use the standard transport mechanism to migrate these objects instead of using the manual export and import features. After performing all the preceding steps and resolving open issues resulting from the imports, congratulate yourself because the migration of the SLD is done!









8.3    Migrating Enterprise Services Repository Content
When migrating the ES Repository, a number of objects need to be moved. You can move the objects one by one, but we personally prefer moving all SCs or namespaces at once because it's faster and helps avoid mistakes made by leaving out dependent objects while cherry-picking. After the SCs or namespaces have been successfully migrated to the target SAP PO system, you can remove objects that you don't need or objects that aren't supported by SAP PO. These are mostly ABAP-based objects, such as ccBPM. We'll detail the steps of exporting the ES Repository objects from the source SAP PI system and importing them into the target system in the next sections.
8.3.1    Exporting Objects
To export the ES Repository objects, follow these steps:


                    From the SAP PI landing page of the source system, launch the ES Repository.
                

                    In the ES Repository, right-click on the SC or namespace that you want to export, and then click on the Export button.
                

                    Specify a location on your local file system in which to save the TPZ file. Don't forget to properly name the TPZ file.
                

If you want to export multiple SCs, then repeat steps 1 to 3 for each SC.
8.3.2    Importing Objects
To import the data that you just exported from the previous steps, follow these steps:


                    From the target SAP PO landing page, launch the ES Repository.
                

                    Click on Tools in the menu, and select Import Configuration Objects.
                

                    From the pop-up menu that appears, select Client, and choose the TPZ file from your local file system.
                

                    Click on Import.
                

                    Repeat steps 1 to 3 multiple times to export more SCs or namespaces if necessary.
                


Note
You can import SCs without problems and without creating any inconsistencies because they already exist in the target SLD. Because the software component versions (SWCVs) and IDs match the ones in the SLD, it almost looks like you imported the SCs from the SLD. Be advised that you can also use the standard transport mechanism to migrate these objects instead of using the manual export and import features.

You should now have the ES Repository of your target system populated with all the required SCs. If you implemented ccBPM processes in your SAP PI system, then now is the time to remove them. This step in needed because the ccBPM component is no longer supported in SAP PO. You'll need to reimplement your ccBPM processes in SAP BPM. See Chapter 16 for more details and considerations for migrating your ccBPM processes to equivalent SAP BPM processes.









8.4    Migrating Integration Directory Content
Because the SLD and ES Repository objects have already been migrated to the target SAP PO system, you now have all the required dependencies that you need to start migrating the configuration objects. To migrate configuration objects, you can use a manual method or use the Migration tool. Given that SAP PO is based on Java only, only ICOs and iFlows are supported as configuration objects. Therefore, all classic configuration objects will need to be migrated to ICOs or iFlows.
8.4.1    Manually
You can use the old-school method and manually move all required interfaces, which can be a useful approach if you don't have the transport mechanism in place or decide not to use the Migration tool. Consider the following details:


                    All configurations using an integration process (ccBPM) as a communication component will need to be redesigned. Note that SAP PO doesn't use ccBPM.
                

                    All configurations using the old "classic" method will need to be recreated as ICOs or iFlows, depending on your preference.
                

                    For each of the existing classic configurations, you need to determine the following:
                    

                            Sender system
                        

                            Sender interface used
                        

                            Sender communication channel
                        

                            Routing conditions
                        

                            Receiver system
                        

                            Operation mapping to be used (if any)
                        

                            Receiver interface
                        

                            Receiver communication channel
                        

                    These details can be gathered based on existing classic configuration objects, including the sender agreement, receiver determination, interface determination, and receiver agreement. The collected information can then be used to manually create the ICO or iFlow in the target system.
                

                    All ICOs will need to be moved as is with the export and import functionality. The communication channels might need to be reworked because the version of the adapter engine might be different. It's also possible that the adapter type in use isn't available in SAP PO. See Table 8.2 for examples of adapter types that have been renamed.
                





                            ABAP-Based Adapter Types
                        

                            Java-Based Adapter Types
                        





                            IDoc
                        

                            IDoc AAE
                        



                            HTTP
                        

                            HTTP AAE
                        



                            XI
                        

                            SOAP adapter in combination with XI 3.0 message protocol
                        



                            WS
                        

                            Not yet supported
                        



Table 8.2    Conversion of ABAP and Java Adapter Types
8.4.2    Using the Migration Tool
The Integration Directory Migration tool is a standard application that supports automating the migration of Integration Directory content. The Integration Directory content in question includes communication channels, communication components, and traditional (classic) integration configurations. This tool is a standard application built by SAP and delivered as part of SAP PI or SAP PO. It makes use of the Directory application programming interface (API) and can be found under Configuration and Monitoring. You only need the Migration tool to be present in the target system—more specifically, in your SAP PO machine. The tool is available from SAP PI 7.30 SP 9 and SAP PO 7.31 SP 7 and newer versions.
Consider the following details when using the Integration Directory Migration tool:


                    The tool converts classical scenario configurations and related objects to ICOs. iFlows aren't used.
                

                    Use of the tool assumes that all dependent ES Repository and SLD objects have already been migrated using a manual approach or the transport mechanism.
                

                    The tool uses the sender agreement as the base from which configuration objects will be migrated. If your scenario doesn't use a sender agreement, then it will be skipped. It also uses the receiver determination for scenarios that are based on a sender IDoc and proxy. This is because in the "classic" scenarios, sender agreements weren't needed for IDoc and proxy scenarios.
                

                    The tool ensures the consistency of a configuration scenario. As a result, when migrating a scenario, it will automatically create the related communication channel and communication component (party, business system, and business component).
                

                    The tool provides facilities to rename configuration objects during the migration process.
                

                    You can select one or multiple classic scenarios to be migrated at once.
                

                    Support for bulk migration of communication components and updates of their properties are also provided.
                

The Integration Directory Migration tool can be directly accessed and launched via http://<hostname>:<port>/webdynpro/resources/sap.com/tc~pi~tools~dirmig~wd/DirectoryCockpit.
The Integration Directory Migration Tool landing page is shown in Figure 8.2. Communication channels are completely copied across, including their module properties. Only the password isn't copied. Communication channels using ABAP-based adapter types are turned into their Java-only equivalents. See Table 8.2 for the specifics of conversions between ABAP-based and Java-based adapter types.
Note that <hostname> and <port> represent the hostname and port number, respectively, of your SAP PO target system. The tool is equipped with three main features:


Scenario Migration  Facilitates the migration of scenarios from one system into ICO scenarios on another system.
                

Configuration Facilitates the maintenance of additional systems in your landscape in the tool. You can also maintain renaming rules for Integration Directory objects.
                

Channel Migration  Facilitates the mass migration of communication channels from one system to another.
                


Figure 8.2    Landing Page of the Integration Directory Migration Tool
Given that the Migration tool uses the Directory API in the background, you'll need roles required to execute Directory API calls in both the source and target systems. See Table 8.3 for a list of some roles that you'll need in both systems and their descriptions.




                            Role Name
                        

                            Description
                        





SAP_XI_API_DISPLAY_J2EE


                            Gives the user authorization to perform directory operations, including Query, Read, Check, GetState, CheckContent, GetCacheState, and GetObjectIdentifier.
                        



SAP_XI_API_DEVELOP_J2EE


                            Gives the user authorization to perform directory operations, including Change, Create, OpenForEdit, Revert, Delete, CreateFromTemplate, Activate, and Revert.
                        



Table 8.3    Roles Required for Using the Configuration API and Integration Directory Migration Tool
Scenario Migration
To perform a migration using the Migration tool, follow these steps:


                        Launch the tool via http://<hostname>:<port>/webdynpro/resources/sap.com/tc~pi~tools~dirmig~wd/DirectoryCockpit. You can also launch it by going to the landing page of SAP PO (http://<hostname>:<port>/dir) and navigating to the Configuration and Monitoring link. You then need to select the Configuration and Administration tab and click on the Migration Tool link.
                    

                        Click on the Scenario Migration link.
                    

                        In the System Selection step, fill in the following details:
                        

Select Source System Select the source system from the dropdown list, and maintain the login details. The list of systems to select from is retrieved from the SLD. Note that if the source system that you're looking for isn't present in the dropdown list, you can always add it by choosing the Add/Change Systems button.
                            

Select Target System The target system is preselected for you. It's always the system where the tool is located. You just need to enter your user login details (see Figure 8.3). Click on the Next button.
                            


Figure 8.3    System Selection Screen of the Integration Directory Migration Tool


                        On the next screen, you can select the scenarios that you want to migrate in the Scenario Selection step. You can select from among the following scenario types:
                        

Sender Agreement Useful for selecting scenarios with a sender agreement.
                            

Configuration Scenario Name This is an alternative option to the sender agreement selection method. The option is mostly used for ABAP-based interfaces that don't contain a sender agreement.
                            

Receiver Determination Use this option whenever your scenario doesn't have a sender agreement. This is mostly relevant for the IDoc and SAP XI adapter types.
                            



                        Click on the Search button, which allows you to get results containing the classic scenario from the source system. After selecting the scenarios that you want to migrate, click on the Next button. See Figure 8.4 for an example screen.
                    

                        The next step in the wizard is called Scenario Matcher. This step automatically identifies all objects upon which the selected scenarios depend, performs checks to verify that all preconditions for the migration are matched and passed, and provides a detailed overview of passed and failed scenarios. An example of a passed check appears in Figure 8.5 (when the check fails, a detailed error is provided). When you're done with this step, click on the Next button.
                        
Figure 8.4    Selecting Classic Scenarios from the Source System to be Migrated to an SAP PO Target System

Figure 8.5    Example of a Scenario That Passed the Matcher Check


                        You now have an overview of the ICO to be created in the target system. This Preview and Renaming step gives you a preview of the end result in the target system (see Figure 8.6). In addition, you can adapt the communication channels' properties (such as the adapter engine) or influence the names of the objects to be created. You can rename objects using the renaming rules. When you're satisfied with the preview, click on the Next button.
                        
Figure 8.6    Overview of the ICO to be Created in the Target System


                        In the Object Creation step, the tool suggests a change list to be created in the target system (into which the new object to be created will be added). Click on the Create button to create a change list object (see Figure 8.7). After that, you're ready to click on the Next button.
                        
Figure 8.7    Screen Enabling the Creation of a Change List in the Target System to Include the ICO-Related Objects


                        You get an overview of the steps performed in the target system and their statuses. If some steps failed, then you view their details in this screen.
                    

                        You're now ready to log in to the target SAP PO system and activate the change lists created as a result of the migration. You might be required to readjust some communication parameters with details such as passwords.
                    


Note
If objects to be migrated already exist (with the same name) in the target, then they aren't created; the implication is that the existing objects aren't overwritten. You can use the renaming rules to name your new objects differently to avoid this conflict.


Tips and Tricks
Always make sure that your user has both the SAP_XI_API_DISPLAY_J2EE and SAP_XI_API_DEVELOP_J2EE roles in the source and target systems.
If this isn't the case, then you'll see the following error: Insufficient authorization to read from source system. Details: Your user needs additional authorizations.

Channel Migration
This tool enables the mass migration of communication channels from one system to another. Note that attributes (such as passwords) aren't migrated.
This tool can also be used to change the metadata and properties of communication channels in the target system. You can change one attribute for multiple channels at the same time. A good example of this is to change the adapter engine to be used, in a case in which the landscape has decentral adapter engines. Values of adapter module properties can also be modified.
The steps involved to perform such a communication channel mass migration are as follows:


                        From the main page of the tool, click on the Channel Migration link.
                    

                        Select the source and target systems, and then enter login credentials. Note that the target system is selected by default.
                    

                        Search for the desired communication channels using the name, component, or party. Note that you can further narrow your search criteria by choosing whether the channel is on the sender or receiver side. You can also use regular expressions for your search keywords. Click on the Search button.
                    

                        From the search results, select the relevant communication channels. Details of the channels are displayed under Module Properties. You can also select a specific property's checkbox and edit it (see Figure 8.8). When you're finished, click Next.
                    

                        At the top of the screen, click on the Create button to start the creation process on the target system. Be aware that a change list will also be created to contain the migrated channels.
                    

                        You'll get an overview of all performed steps and their statuses. The statuses can be OK, Warning, or Error. You have to activate the channels in the target system.
                    


Figure 8.8    Example of the Channel Selection Step When Changing Adapter Properties

Note
Migrated communication channels aren't always ready to be activated; some of them might still need to be adjusted, especially because attributes such as password and adapter engine need to be maintained.

Configuration
The configuration feature can be used to add additional systems from your landscape via the Migration tool. In addition, you can maintain renaming rules for Integration Directory objects.
The Migration tool looks up the SLD that it's connected to and retrieves all Integration Directory systems. If the source system that you're interested in isn't visible in the view, then you can manually add it, as shown in Figure 8.9. To add a new system, you'll need to do the following:


                        From the Migration tool main page, click on the Configuration link. Then, select the Systems tab.
                    

                        Click on the Create System button.
                    

                        Maintain the system name and URL, and click on the Save button (see the example in Figure 8.9).
                    

                        You can also modify or delete an existing system by selecting it from the table.
                    

You're now ready to use any of the systems in this list as your source system.

Figure 8.9    Maintaining Integration Directory Systems in the Migration Tool
You may also want to rename the directory objects to be migrated. The Migration tool provides the feature of creating a reusable renaming rule from a central place. This same rule can then be reused for different scenarios and configuration objects.
To create a new renaming rule, follow these steps:


                        From the Migration tool main page, click on Configuration. Then, select the Renaming Rules tab.
                    

                        Click on the Create Rule button.
                    

                        You're then presented with a new area, in which you can specify details of the renaming rule (see Figure 8.10). Note that you have a choice between adding a suffix to the object name or replacing an existing part of the name. The provided suffix is added when the Rule Type dropdown menu is set to Add Suffix. You can alternatively replace an existing part of the name by setting the value of the Rule Type dropdown menu to Value Map.
                    

                        When you're done, click on the Save button.
                    

You're now ready to reuse this rule during the migration process.

Figure 8.10    Renaming Rule Creation Example

Renaming Rules
When using the renaming rules feature, take the following details into consideration:


                            You can influence the name of objects such as party, communication component, and communication channel.
                        

                            If your routing rule is content based and uses a constant, then you can replace it.
                        

                            Business systems can be renamed to match the business system defined in your target system's SLD.
                        


Remember that not all objects can be migrated. Per the current version of the Migration tool, the following object migrations aren't supported:


                        Receiver rules
                    

                        ABAP-based scenarios (with ccBPM or ABAP mappings)
                    










8.5    Summary
The previous chapters in the book have demonstrated the need to migrate to SAP PO. This chapter empowers you to achieve such a migration by exploring the different aspects that come into consideration when migrating an existing SAP PI dual-stack system to an SAP PO system. We've shown that you need to migrate the SLD, ES Repository, and Integration Directory objects in order. Both the manual export or import and the normal transport mechanism can be used during the migration of the different components. SAP released an Integration Directory Migration tool, which facilitates the fast and quick migration of Integration Directory content. It's important to be aware that some ABAP-based objects, such as ccBPM processes, ABAP mappings, and receiver rules, can't be directly migrated and will have to be redesigned into their Java-based equivalent objects. The chapter also lists alternative Java-based objects for those ABAP objects that can't be directly migrated.
The next chapter introduces the concepts of the SAP BPM platform and of the Business Process Model and Notation (BPMN 2.0).








Part IIIBusiness Process Management and Composition







9    Introduction to SAP BPM and BPMN 2.0If you can't explain it simply, you don't understand it well enough.                                                                                                   —Albert EinsteinThis chapter introduces the fundamental concepts of business process management (BPM) in general and specifically the use of SAP Business Process Management (SAP BPM) and Business Process Model and Notation (BPMN 2.0) as core parts of SAP Process Orchestration (SAP PO). With BPM, organizations are able to react and adapt rapidly to changes in their operating environment. BPM enables companies to manage the entire lifecycle (see Figure 9.1) of their business processes, which involves graphically designing, modeling, executing, monitoring, and continuously improving those business processes. That holistic process is supported by sophisticated BPM software that uses easy-to-make and understand flow charts and diagrams, based on open standards and globally supported by the biggest software vendors.
Figure 9.1    BPM Lifecycle
BPM Lifecycle
The BPM lifecycle is an iterative process applicable for any business process and consists of the following steps:


Design This first step involves the analysis of existing business processes (as is) and design of the new (to be) processes, including the mapping to application functionality and information architectures. If the business process is totally new, then you start from scratch designing the business process based on the functional requirements.
            

Model The model step comprises the translation of the high-level process model (Unified Modeling Language [UML] or BPMN 2.0 describing the process at an abstract level) to the more detailed and executable process flow model modeled in BPMN 2.0.
            

Execute At this stage, the process is executed by the BPM software platform in charge of interpreting the BPMN 2.0 source code into an orchestrated software program.
            

Monitor This stage encompasses the monitoring of running business processes on the BPM platform. The monitoring of processes depends on how the business wants to collect and analyze the process data (i.e., real time, near real time, or based on historical data). Real-time monitoring is also called business activity monitoring (BAM).
            

Improve This step is intended to be a continuous process on its own and uses the design and monitoring steps as input.
            

First, we'll get started by discussing the motivation behind using BPM, and then we'll explain this process as well as BPMN in more detail.
9.1    Managing Business Processes
Think about everything we do as part of a process that can be mapped out, from ordering a cup of coffee at your favorite coffee shop (see Figure 9.2) to checking in at the airport for your next business or holiday trip. While performing those activities, you're a participant of a business process, triggering different kinds of events and providing input and context for specific process instances.

Figure 9.2    Coffee Ordering Process
In fact, in our daily lives, we're continuously surrounded by business processes. Whether you approach this philosophical thought from a private or business perspective, you end up with the same unambiguous conclusion that most actions we undertake in our daily lives belong to a particular process step in a business process.
Having said that, it doesn't come as a surprise that companies around the world, no matter their size and the industries they serve, also have to deal with a large number of business processes in different types and levels of complexity. The demand to gain more control, flexibility, and agility in business processes comes mainly from the business and is directly driven by different phenomena, such as globalization, legal and regulatory compliance acts, big data, linked data, and social media, to mention just a few. In addition, don't forget about the cost efficiency and operational excellence aspects related to the adoption of BPM as a management and IT discipline.
Now that we've briefly introduced the hidden forces behind the need for BPM in most organizations, it's time to bring clarity to what type of BPM approach your organization is applying or planning to apply. As you might already know, BPM isn't something new; in fact, it was around nearly four decades ago.
BPM has two different meanings, depending on the context and to whom you're talking. It's important to know the differences between them:


BPM as a management discipline Involves managing the end-to-end processes (rather than the tasks) that organizations perform to create value for their customers and other stakeholders. It helps companies standardize and continuously optimize operational processes to reduce costs, improve quality, and increase agility. Good examples of BPM applied as an instrument to implement management strategies are methodologies such as Six Sigma, Kaizen, and lean.
            

BPM as a technology When BPM is used as an IT enabler, it is also sometimes referred to as a business process management suite (BPMS), which is a suite that combines different tools to design, model, build, deploy, run, manage, monitor, and improve business processes and their running environment during the entire lifecycle. SAP BPM covers the functionality of a BPMS and qualifies as such.
            

Now that you understand what SAP BPM is, we'll explain how it supports BPM functionality and how it's positioned in the organization. After that, you'll learn how to use BPMN 2.0 to design and model your business processes.









9.2    SAP Business Process Management
SAP BPM provides a complete suite of BPM development and administrative tools to help organizations design, model, execute, monitor, manage, and analyze business processes using one platform. It allows organizations to create new processes based on their existing software and applications, as well as by creating new types of processes that combine different sources of information, technologies, and platforms.
You can improve and enhance existing business processes by reusing existing components or automating certain parts of the process, such as system-to-system and human-to-system information interchange and the execution of complex and general (repetitive) business rules. In fact, we advise our customers who are interested in implementing SAP BPM to start with relatively small BPM initiatives, proactively engage the process stakeholders, demonstrate quick wins, and visualize results to the business before embarking on a full-blown SAP BPM adoption.
Before we proceed with the rest of this chapter, we'll highlight and explain the purpose and role of SAP BPM within an organization.

Business Process Visibility with SAP BPM
Organizations gain control and overall visibility across their business processes when implemented with SAP BPM. The following list provides an overview of known common aspects of business processes in which stakeholders are interested:


                    Who in the organization is responsible for performing a task? This can be a person, a business unit, an external entity, or a system.
                

                    What type of information is flowing through the process? This can be an order, an order confirmation, and so on.
                

                    Which process step is currently being executed?
                

                    When was a certain process step (manual or automatic) executed, who executed it, how long did it take to execute, and what was the result?
                


As you can see, when wisely implemented, SAP BPM increases the level of control and end-to-end visibility in business processes. It also significantly contributes to improving overall process efficiency, which automatically leads to other business benefits, such as lower cost-to-serve, higher customer satisfaction, and customer retention. The next section will provide some context regarding SAP BPM, including differentiating SAP BPM and SAP Business Workflow.
9.2.1    SAP BPM versus SAP Business Workflow
Often, especially in discussions with traditional SAP consultants, SAP BPM is unfairly compared with other workflow application, such as SAP Business Workflow. This faulty comparison is due to a lack of understanding of the area of application of both tools. Let's take a look at how they are different from each other.
SAP Business Workflow is an ABAP-based workflow engine that enables you to design, customize, and execute business processes within SAP backend systems—that is, inside one SAP system (see Figure 9.3)—rather than across SAP systems, as SAP BPM allows. SAP Business Workflow processes are often delivered as a business content functionality part of SAP solutions, but SAP BPM processes are rarely delivered as business content as a part of standard SAP solutions. You can also enhance or create your own SAP workflows by using the same tools provided by SAP. Inside SAP business suites, such as SAP Customer Relationship Management (SAP CRM), SAP Supplier Relationship Management (SAP SRM), and SAP ERP, we traditionally encounter SAP Business Workflow (both out of the box and enhanced) supporting approval processes, order processes, processes related to customer interaction, and so on. In contrast, with SAP BPM, most business processes are created either by reusing existing functionality combined with new process components or by creating new services and process functionality.

Figure 9.3    Scope of SAP Business Workflow
A second key difference between SAP BPM and SAP Business Workflow is in their underlying technology. As we know, SAP BPM runs on Java, whereas SAP Business Workflow is an ABAP-based workflow engine, which means it can only run on the ABAP stack. Although you can integrate SAP Business Workflow with other SAP and non-SAP systems using different interface technologies, such as IDoc and ABAP proxies, it was never intended to be used for that purpose.
It's worth mentioning here that SAP Business Workflow focuses primarily on human-centric processes, in which a substantial number of the tasks are performed in a routine and predictable fashion. SAP BPM supports both types of process orchestration: human-centric and system-centric:


System-centric processes The main focus of this type of process is on the integration of information sources, generally between two or more services in an orchestrated fashion. Process logic is applied to the service requests or responses to coordinate the flow of data from the start to the end of the process.
                

Human-centric processes Human-centric processes are business processes in which most process activities are predominately performed as manual activities by humans. The process only provides guidance about the steps to follow and gives an overview of the overall process status. An example of a manual process activity part of an HR recruitment process could be to check the LinkedIn profile of a candidate before inviting him for a job interview.
                


SAP BPM Isn't a Reporting Tool
Another common misunderstanding that we hear about SAP BPM is that it's an alternative to known SAP reporting tools. Just to be clear, SAP BPM isn't a reporting tool, and it isn't intended as a replacement for SAP Business Warehouse (SAP BW) or SAP BusinessObjects Business Intelligence (SAP BusinessObjects BI). Instead, it's complementary to business intelligence tools because it leverages new sources of information that can be used in SAP BW or SAP BusinessObjects BI to deliver more accurate and detailed reports and analysis containing different key performance indicators (KPIs) set to business processes. It's good to note that SAP BPM delivers standard out-of-the-box data extractors for SAP BW.

9.2.2    BPM before SAP BPM
Before SAP BPM made its entrance almost six years ago as part of SAP Composition Environment 7.1, SAP Process Integration (SAP PI) developers didn't have many alternatives to choose from in the SAP NetWeaver stack for orchestrating system-centric and human-centric business processes (or a combination of both). Due to the limited BPM functionality available at that time, tight project deadlines and IT budget pressure pushed teams to deliver a solution within the planning and deadlines. Many projects ended up implementing BPM-like solutions that used existing SAP technologies. Some examples of such solutions included cross-component Business Process Management (ccBPM) for system-centric process orchestration, SAP Business Workflow for human-centric and ad hoc task processing, and ABAP custom programming and Z tables for support of business rules on the backend systems.
That was far from an ideal situation, and the pseudo-BPM approach introduced many disadvantages, including the following:


                    A considerable amount of custom-built logic was introduced on the backend systems.
                

                    Businesses became even more dependent on IT due to the use of technology-driven instead of process-driven techniques.
                

                    Low flexibility occurred as a result of hard-coded rules programmed in the software instead of configured business rules.
                

                    The "made to fit" approach resulted in even more difficult to maintain and extend business processes because of the "one-purpose, one result" vision.
                

                    This approach provided limited to zero visibility in the process context, result of process steps, and overall process status during and after execution of the process.
                

SAP BPM provides the functionality needed when implementing system-centric and human-centric processes in an SAP-rich landscape. That doesn't mean you can't use it for orchestrating non-SAP processes, but you'll get more advantage from its overall functionality and tools when used in an SAP-centric landscape. For instance, when modeling new processes in SAP BPM, you can directly access the Enterprise Services Repository (ES Repository) and search for existing services (created by you or by delivered by SAP as business content) that match needed specific functionality by a particular process implemented with SAP BPM.
When applied consistently and seriously adopted by the organization (i.e., not only by IT), SAP BPM closes the gap between business and IT by delivering a platform that enables direct interaction among all process stakeholders, including business, IT, partners, and suppliers. From the start of a BPM project, you already notice the difference from traditional IT projects. As a business, you become aware of how your business processes really look when they are executed; whether that execution is a manual task performed by a customer representative or an automated step executed between two systems, it all becomes clear. For the IT folks, a new world opens as they see for the first time in their lives how their services and mappings are used to create value in real business processes.
We don't claim that SAP BPM is the next "killer app" of SAP, but it does play an important role in facilitating the evolution of organizations wanting to become more agile and support their business by a process-driven instead of traditional IT project-driven approach. It also eliminates the burden introduced by the disadvantages presented in the preceding list by providing a logical level of abstraction for the execution and management of process logic (i.e., service orchestration, task generation, business rules execution, process monitoring, etc.) right where it belongs—at the process layer.
Figure 9.4 illustrates how SAP BPM can orchestrate processes across different systems and enterprise boundaries.

Figure 9.4    Scope of SAP Business Process Management across the Landscape
Traditionally, solutions implemented with SAP BPM tend to reuse existing (functional and technical) capabilities on the application layer. It's also common to encounter SAP BPM as a replacement of legacy applications that in the past supported some types of activities related to workflow or business rules. SAP BPM applications are by nature process-centric and exist to support and enrich end-to-end business processes. They might involve both manual and automatic tasks, and they can extend beyond enterprise borders.

Note
Here's a list of a few SAP PO/SAP BPM-supported scenarios:


                        Industry-specific or company-specific business processes that aren't covered by standard (SAP) applications
                    

                        Process integration scenarios that involve the interaction of humans, systems, and external parties
                    

                        Processes that require approval and decision steps, such as HR-related processes (recruitment, employee onboarding, etc.), and financial requests, such as credit or insurance policy applications
                    

                        Enabling and automating procurement processes such as requisition and purchase order authorization rules, but also three-way matching in financial processes
                    

                        Business processes with real-time requirements, real-time cockpits or KPI reports, and events-based decision rules
                    

                        Integrated processes with both manual and automatically executed activities via services
                    

                        End-to-end scenarios that contain considerable amounts of information exchange, orchestration, and collaboration
                    

                        Applications that require support for the maintenance and execution of easy-to-maintain (reusable) business rules
                    


9.2.3    SAP BPM Main Components
As explained in Chapter 1, SAP BPM is delivered as part of SAP PO, which is a BPM and application integration suite consisting of the following three core components running under the same Java stack:


SAP Process Integration (SAP PI) Delivers enterprise service bus (ESB) capabilities by means of the Advanced Adapter Engine Extended (AEX) together with its different application and technical adapters, ensuring any-to-any connectivity for SAP and non-SAP systems.
                

SAP Business Process Management (SAP BPM)  Provides a complete set of tools for the design, development, execution, monitoring, and management layers for creating human-centric and system-centric business processes.
                

SAP Business Rules Management (SAP BRM) Used for the definition, execution, and management of business rules to be used inside SAP BPM processes or as independent callable web services from other applications.
                

Depending on the specific requirements of your system landscape, additional components and functionality can be enabled as part of the installation of SAP PO. For example, you can enable support for SAP Composition Environment features, such as Visual Composer or Web Dynpro.
Figure 9.5 depicts how these three components are accommodated within the SAP PO single stack, also known as Java-only architecture.

Figure 9.5    SAP BPM Positioned inside SAP PO
The single-stack architecture of SAP PO with one single SID has a positive impact on performance and the reduction of overhead during message processing across the different SAP PO components. It also means that the hardware requirements for a single-stack installation are less demanding than for its dual-stack (ABAP/Java) predecessors.









9.3    Business Process Model and Notation 2.0
What You Model Is What You Execute (WYMISWYE) isn't just another marketing slogan introduced by the Object Management Group (OMG) to promote their standard, but instead it's one of the important advantages that the BPMN 2.0 standard has to offer.
BPMN is an open-source and widely adopted multivendor standard for process modeling and execution. It's also an essential enabler of business and IT alignment that provides a common language for all disciplines involved in the modeling, execution, and managing of business processes.

Note
Although BPMN 2.0 is primarily meant for modeling and documenting business processes, some software vendors such as SAP offer the possibility to convert static BPMN diagrams into executable versions of those BPMN diagrams.

When you're modeling a business process diagram (BPD) with BPMN 2.0, you're graphically describing (in a generic way and with the aid of standard shapes and modeling conventions) how the information flows inside a business process from one point to another. In the diagram, we normally model details about how that information enters the process (i.e., whether it's the result of automatic or manual activities or perhaps the outcome of other types of activities, such as time or messaging events).
Depending on the types of processes you're modeling, in many occasions, you'll also have to deal with decision moments while executing the process to help you decide which process paths to follow—for example, go right, go left, loop through a list of items, or carry on straight forward in the process flow. Let's see how that looks in a real-life example.
Consider the situation in which the process has to decide whether an approval is needed from a manager or not (see Figure 9.6). In that case, we model that condition in the process as a decision step, which is represented in BPMN 2.0 as a diamond shape and is called a gateway. We'll talk more about gateways later in this chapter. Note that the gateway only takes care of the evaluation of the logic (i.e., true or false); the real business logic behind the decision step is normally implemented as a condition expression using standard functions (Java or XPath) or your own designed business rules.
BPMN 2.0 is a generic standard that defines a set of different flow elements to help process owners, business analysts, and IT professionals understand, analyze, design, and execute business processes in a common way, according to their specific (functional and technical) requirements, and at different levels of detail.

Figure 9.6    Approval Decision Step Modeled as a Gateway
For a complete, detailed overview of the BPMN 2.0 elements in a poster format, go to www.bpmb.de/index.php/BPMNPoster, which is maintained by the Berliner BPM-Offensive and is available as a free download.
SAP BPM (version 7.5) supports roughly 90% of all flow elements declared in the BPMN 2.0 library. SAP NetWeaver Developer Studio is the integrated development environment (IDE) in which you'll find all the tools you need to model, develop, and deploy your business processes according to the BPMN 2.0 specification. In there, you'll find the BPMN flow elements grouped as a palette in different categories and subcategories. You can see the groups and main categories in Figure 9.7, which we describe in more detail in the following sections.

Figure 9.7    BPMN 2.0 Palette in SAP BPM via SAP NetWeaver Developer Studio
9.3.1    Swimlanes
Swimlanes are a standard mechanism used in BPMN 2.0 to group process steps into separate visual containers. A swimlane represents a functional entity or responsibility in the process and can be modeled either vertically or horizontally depending on the orientation of the entire BPD. There are two types of swimlanes supported in BPMN 2.0: pool and lane.
Pool
The pool object represents a process participant and serves as the container for a single process (see Figure 9.8). There can be one or more pools per process flow. Although it's not mandatory, it's recommended to model your processes using a pool, which encapsulates all of the different process steps.

Figure 9.8    BPMN 2.0 Swimlanes: Pool
Pools can also be used to model business-to-business (B2B) interactions and other similar types of intercompany exchanges of information—for instance, between partners and suppliers. When modeling the process in BPMN 2.0, you can choose to model the contents of a pool as either a black box or white box.
Here are some characteristics of a pool that you should be aware of:


                        A pool represents a process actor, which can be a person or a system.
                    

                        A pool contains a single BPMN process.
                    

                        It's not mandatory to use a pool when modeling a process, but it's a best practice to do so.
                    

                        A process diagram can contain more than one pool.
                    

                        As a best practice, you should label the pool with the name of the process it contains.
                    

                        You can model black-box and white-box pools in your process diagram. A white-box pool is a pool in which the process steps are all known and visible. A black-box is the opposite; that is, it's modeled empty and it normally represents an external entity. A black-box pool is labeled with the name of the process participant it represents. This type of diagram (process choreography) is BPMN 2.0 compliant, but it's currently not supported by SAP BPM; that is, you can model it, but it's not translated into an executable process (see Figure 9.9).
                    

                        You can model a pool and its contents horizontally or vertically.
                    


Figure 9.9    White-Box Pool (Top) and Black-Box Pool (Bottom)
Lane
A lane usually represents user roles, organizational units, or systems that perform activities in the process and is used to arrange and group related process steps within a pool. You can have one or more lanes in one pool.
In Figure 9.10, two lanes have been modeled inside the same pool. The lane at the top represents an employee updating his LinkedIn profile as part of the corporate onboarding rules of his new company. The lane at the bottom represents an HR system from which an automated activity receives the update posted by the new employee and takes care of sending it to LinkedIn. After that, the process stops.

Figure 9.10    BPMN 2.0 Swimlanes HR and Employee Lanes
The following list details some important lane characteristics:


                        You can have more than one lane subdivision in one pool.
                    

                        A lane represents a process actor, which can be a user role, an organizational unit, or a system.
                    

                        Information flow from one lane to another in the same pool is modeled using the sequence flow.
                    

                        Information flow from one lane to another in a different pool is done via the message flow (refer to Figure 9.9).
                    

                        You can model a lane and its contents horizontally or vertically.
                    

9.3.2    Artifacts
The BPMN 2.0 standard defines artifacts as process objects that can be used in a BPD to provide additional information about the process context or its specific activities. You can link them to other process objects, such as events and tasks, by using associations. Furthermore, you can also create and import your own set of artifacts. The specification defines the correct syntax and conventions so that the diagram remains valid. In SAP BPM, two types of artifacts are supported: the data object and the annotation.
Data Object
A data object in BPMN represents the context of a process—that is, the information flowing from start to end through the different steps of a modeled process in SAP BPM. A data object can represent an IDoc, a request from a web service of an ABAP proxy, or any other data container interacting with a process. When you create a data object, it needs to be associated with a data type to map its contents with a process activity in your process model. In SAP BPM, data objects have an abstract character because you can use them to define inbound and outbound data structures, as shown in the next subsection.
Data objects have the following characteristics:


                        Represents the context of the business process
                    

                        Feeds the process with information produced by its participants
                    

                        Serves as a data container for storing input and output data you want to use during process execution or for reporting purposes
                    

                        Links to existing data types (XML schemas)
                    


Good to Know
Only data objects with designated simple types (types enumerated) are automatically initialized with the following values:


Boolean = false


Int = 0


Short = 0



Annotation
An annotation is an artifact that allows you to provide useful or additional explanatory information about specific parts of the process model. For example, you can add an extra note about the contents of a start event in a process (see Figure 9.11).
Annotations only provide additional information about individual elements; they don't have an impact on the behavior of the process.

Figure 9.11    SAP BPM Artifacts: Annotation
You can connect an annotation to one or more process elements to provide more insight about a certain step in the process by using an association connector (see Figure 9.12).

Figure 9.12    SAP BPM Artifacts Example
9.3.3    Flow Objects
When modeling a graphical representation for describing a business process, you use a set of standard flow elements declared in the BPMN 2.0 standard. There are three types of flow objects: events (start, intermediate, and end), activities (task and subprocess), and gateways (various types). Figure 9.13 shows some of the flow objects commonly used in process diagrams.
You can connect them to each other using sequence, data, and message flow connectors. The following sections discuss each type of flow object.

Figure 9.13    SAP BPM Flow Objects: Events, Activities, and Gateways
Events
Running processes are exposed to different types of internal and external events, which might influence the internal behavior and outputs during the course of the process. Events are something that occur while the process is being executed. You should model them only if their presence has an impact on the process execution. With events, you specify how a process is started or ended or that the process is temporarily delayed and is waiting for a certain event (time or message driven) before proceeding. Figure 9.14 depicts the distinct types of events currently supported by SAP BPM.

Figure 9.14    SAP BPM Events
From left to right we find the following event types:


Start events Start events can be seen as trigger messages that are sent to a process. Incoming start events activate the start of a process. These kinds of events are represented by a single circle.
                    

Intermediate events Intermediate events, on the other hand, can enter the process at any point while the process is still running. An intermediate event may or may not be triggered during process execution. They carry information that enriches the process with information that wasn't available at the start of the process or with a response as an answer to a previous request generated by an automatic activity.
                        It's important point to consider the correlation aspect when working with these types of events. As you can imagine, the process engine running the process must be able to identify and match the incoming intermediate event (e.g., represented by a message) against an existing process instance. If the process engine fails in that attempt, then the intermediate event will be stored until it's canceled or a matching parent process instance is eventually found.
                        An intermediate event is symbolized by a double circle shape.
                    

End events End events can also trigger messages as a response to a previously synchronous instantiated process. As the name of the event suggests, it's the last step in a process flow, and it indicates the end of the process.
                        For all events that represent a message doing something in the process (start event, intermediate event, and end event), they must be associated and configured to their corresponding service interfaces. You can include more than one end event as part of your process, that is, one to mark the normal end of the process and others that are more specialized in ending the process in case of exceptions or cancellations.
                    

Boundary events Boundary events are special types of events that are triggered from outside the process or when something doesn't go according to the "happy flow" of the process while performing a human or automatic activity. When an exception is thrown by an activity, the process flow stops the normal process execution and follows an alternative path, as defined by the outgoing sequence flow of that particular boundary event. The boundary event and an end event are both represented with a thick-lined circle.
                        With a boundary event, you can define how to deal (i.e., catch the exception) with exceptional situations when they arise at runtime in the process flow. Boundary events are a must have when using automated activities in your business processes. They allow you to perform exception handling after an application or technical exception has occurred. You can configure a boundary event to automatically handle exceptions thrown by automatic activities. You can do this by binding boundary events to fault message types defined in your web services definition.
                        Typical examples of application exceptions are functional errors and wrong input or output inside business rules. Technical exceptions, on other hand, are timeouts, authentication issues, network-related issues, and so on. For those of you with a software programming background in Java or C#, you can compare it with a try/catch exception block.
                        A boundary event has a single outbound sequence flow and is connected to the boundary of an activity. The outbound sequence flow of a boundary event indicates how the process should continue or recover after an exception has been detected. In Figure 9.15, an escalation event is triggered if the employee doesn't complete his task by the set deadline. The outgoing sequence flow of this boundary event goes into a notification task, which sends a reminder email to the employee. In a real-life scenario, we recommend that you add a condition (e.g., a max of three reminders, and then exit the loop) that prevents an endless loop situation like the one in this example.
                    


Figure 9.15    Escalation Event Triggered from Human Task in SAP BPM
You should take note of the following event characteristics:


                        Events are the things that you expect to happen at process runtime.
                    

                        Events exist in four main groups: start, end, intermediate, and boundary.
                    

                        Start, end, and intermediate message events are linked to service interfaces at design time.
                    

                        There is no guarantee that an intermediate event will or will not occur in the process.
                    

                        Boundary events are used to handle exceptions thrown by process activities during runtime.
                    

Activities
Activities are the actions performed by the participants of a business process. You recognize them in a process flow as rectangles with rounded corners, with their corresponding descriptive icons in the top-left corner and their names describing the actions they represent.
There are three main types of activities (see Figure 9.16):


Automated An automated activity is a type of flow object in the process that defines an activity performed by a system, typically a business rule or service interface. In the background, an automated activity may reference an external web service, a business rule, or an SAP service interface via the AEX. An automated activity can be configured using different types of properties at design time, such as name, looping settings, referenced service interface, input and output mapping, and boundary events. This activity includes the following subcategories:
                        

Mapping Transforms complex data structures in the process context into other target structures.
                            

Notification Notifies users via email.
                            

Reporting Collects and stores data from the process context for reporting purposes.
                            



Human A human activity in a process flow is a task generated by the process and performed by a human via a GUI on a portal or mobile device. The task is sent to the user's universal work list (UWL), from where it can be selected by the task owner. After the task owner has accepted and finished the task, the process is updated with the results of the task execution, usually as input provided by the user via a form.
                        Currently, SAP BPM supports the following different types of frontend approaches for human tasks by default:
                        

Online GUI technology Web Dynpro Java, Web Dynpro ABAP, Visual Composer, and SAPUI5 (a modern, HTML5-based frontend technology).
                            

Offline GUI technology Adobe Forms is a special type of form in PDF format that can be shared and filled out by a user. The user can complete the Adobe form either online or offline and send it back to the process when online. The process engine receives the form and extracts the data saved in the form as XML input data for further processing.
                            



Subprocess  This special type of process supports the execution of specific or more detailed tasks. Subprocesses are specialized processes, generally used to model more granular process steps or process logic inside another process. Depending on the type of functionality offered by the subprocess, you can reuse them in different processes. They are represented by a square with a plus sign at the bottom center of the shape (see Figure 9.16). You should take note of the following activity characteristics:
                        

                                Activities represent the different steps executed as part of a business process.
                            

                                They are classified in three categories: automated, human, and subprocess.
                            

                                Automated activities are performed by a system, usually web services or business rules.
                            

                                Human activities are generated as tasks by the system and assigned to process users (humans).
                            

                                The input and output of activities are provided by means of other process activities or data objects in the process context.
                            

                                They can trigger boundary events as the result of exceptions or predefined (time or message) events.
                            

                        Subprocess includes the following subcategories:
                        

Referenced This activity makes a call to an independent process.
                            

Embedded Special type of subprocess activity that contains another process, dependent on the parent process.
                            




Figure 9.16    SAP BPM Activities
Gateways
Imagine you're at the airport in front of an immigration officer's desk, waiting to show him your passport so that he can check it and approve your transit through his gate. His job is to check every passenger trying to cross the border and decide whether that person can pass the border or not. The role of a gateway is very similar to the job of the immigration officer: it regulates the flow of information in a business process.
A gateway has the ability to determine the path of the process flow based on predefined conditions set and modeled by you at design time. A conditional gateway evaluates the parameters provided as input and decides which outgoing sequence flow to follow. A sequence flow can be split, made to run in parallel, or merged. It's also possible to make the process flow dependent on the first event that occurred, applying the event-based choice. Gateways are represented as diamond shapes in a process diagram (see Figure 9.17).

Figure 9.17    SAP BPM Gateways
Here are a few characteristics of gateways:


                        They represent the decisions or evaluation points in a process flow.
                    

                        There are condition-based or data-based, flow behavior-based, and event-based gateways.
                    

                        You use the exclusive choice gateway to perform evaluations based on data from the process context.
                    

                        Parallel split gateways are always used in conjunction with the parallel join gateways in one flow.
                    

                        Event-based gateways are used for points in the process in which the chosen outgoing gate isn't based on data but on events.
                    

SAP BPM supports five different types of gateways, excluding the undefined type. These gateway types are as follows:


Exclusive choice Many times, you need to check a condition in a process (e.g., is the order amount greater than 1,000 USD, is the number of requested holiday days more than 10). The exclusive gateway helps you model those questions in the process flow by controlling the sequence flow based on data to choose which outgoing gate will receive the sequence flow. Each gate, including the default gate, has its own condition, based on a true/false (Boolean) expression. A gateway must always have a default gate—that is, the outgoing gate that is used when no condition is met (see Figure 9.18).
                    


Figure 9.18    Exclusive Choice Gateway Example


Event-based choice This gateway controls the sequence flow by selecting an outgoing gate based on events that occur at that point in the process. As opposed to the exclusive choice gateway, in which the outgoing gate is selected based on a logical evaluation of an expression, the event-based choice gateway determines the outgoing gate based on an individual event—for instance, the arrival of an intermediate message or the activation of an intermediate timer. You use this type of gateway to deal with different types of events arriving at a specific point in the process flow, with no guarantee of which event will occur first.
                        The event-based choice gateway is always followed by an intermediate event that either waits for the arrival of a message or waits for a certain time to pass before continuing the process flow or loop (see Figure 9.19).
                    


Figure 9.19    Event-Based Choice Gateway Example


Parallel split With the parallel split gateway, you can create a parallel flow. It isn't mandatory to use it for modeling a parallel flow, but it generally makes the process flow more readable and less complex. Each gate of the parallel split gateway must have an associated sequence flow. Unlike the exclusive choice, here you can't define any conditions for this gateway or the sequence flows, which means that it passes on sequence flows unconditionally to all outgoing gates in parallel. You must merge them later using a parallel join (see Figure 9.20).
                    

Parallel join This gateway merges parallel sequence flows previously split by a parallel split gateway (see Figure 9.20).
                    


Figure 9.20    Parallel Split and Parallel Join Gateway Example


Uncontrolled merge This gateway is derived from the exclusive gateway and is used as a merge for alternative sequence flows.
                    

9.3.4    Connections
Activities, gateways, and artifacts don't have much value on their own if they can't be connected with each other. They need to be connected together to become a business process flow. The flow elements or connectors that connect the flow objects with each other are called connecting objects. Which connection type you have to choose depends on the flow objects you're connecting.
There are four types of connections (see Figure 9.21):


                    Sequence flow
                

                    Message flow
                

                    Data flow
                

                    Association
                


Figure 9.21    Connection Elements in SAP BPM
Sequence Flow
A sequence flow connects flow objects such as events, activities, and gateways. It defines the order of performance of the flow objects. Each sequence flow connection has only one source and only one target. During the performance of the process, a token leaves the source flow object, traverses down the sequence flow, and enters the target flow object.
Depending on its source object, a sequence flow can have a conditional expression attribute. The conditions are associated with an exclusive choice gateway. The condition expression must be evaluated before a token can be generated and leave the source object to traverse the flow.
Message Flow
A message flow is used to show the flow of messages between two participants that are prepared to send and receive them. According to BPMN, in SAP BPM, two separate pools in the diagram represent two participants in the sense of different business entities.
The activities and events are connected within a lane and across the lane boundary with a sequence flow.
Data Flow
A data flow connection defines where data objects are used in your business process model. You need the data from data objects to define the data changes within an event or an activity. Data mappings show how data used as input and output by the activities and the events in your process is transformed. The data objects represent the process context.
Association
An association connects additional information, such as a note, to individual elements in the process model, such as flow objects, swimlanes, and data objects. Such notes are represented by annotations.
Note the following characteristics of the four types of connections:


                        You use connections to connect flow objects to each other in a process flow.
                    

                        The sequence flow and the association are the most commonly used connections in most process diagrams for information exchange from one process step to another in the same pool.
                    

                        Message flows are used to connect message-based interactions between two different pools.
                    

                        You use associations to connect annotations and data objects with other flow objects.
                    










9.4    Summary
The introduction of SAP BPM as part of SAP PO has delivered long-awaited BPM features and tools to SAP customers and the developers' community around the world. The functionality provided by SAP BPM makes it possible to support vertical and horizontal business processes that span inside and outside the organization boundaries.
We kicked off this chapter with an overview of the key drivers and business benefits for BPM in the enterprise. We also looked back in time and discussed other workflow-based technologies. You also saw the differences between SAP BPM and other traditional workflow technologies, such as SAP Business Workflow or SAP PI's ccBPM.
After that, we also talked about the limitations and disadvantages imposed by non-BPM platforms to integration solutions that require orchestration functionality. We introduced BPMN 2.0 as a universal process modeling standard for business and IT people. You also received a detailed introduction to the different BPMN 2.0 flow elements as currently supported by SAP BPM. We described how and when to apply such elements in a BPD.
You now have a good baseline to start modeling and developing real-life SAP BPM integration scenarios in the next chapters of this book. In Chapter 10, we'll show you how to develop, configure, deploy, and test your first SAP BPM process flow. Let's go with the flow!








10    Creating Your First SAP BPM ProcessAn organization's ability to learn, and translate that learning into action rapidly, is the ultimate competitive advantage.                                                                                                          —Jack WelchIn this chapter, you'll learn how to build, configure, and deploy a process using SAP Business Process Management (SAP BPM) from the ground up. The previous chapter introduced you to the Business Process Model and Notation (BPMN) and how to use it to depict and model your process. This chapter will go a step further and focus more on the implementation side of SAP BPM. By the end of this chapter, you should have a firm understanding of how to build human-centric and system-centric processes from scratch.We'll begin by discussing the role of SAP BPM within SAP Process Orchestration (SAP PO) and walk through setting up your development environment. Then, we'll show you how to implement an SAP BPM process and take a look at flow objects. In the second half of the chapter, we'll provide the steps for building and deploying your process, discuss some advanced mapping techniques, and show how to implement error handing. Finally, we'll show how to combine SAP BPM and the Advanced Adapter Engine Extended (AEX) and provide you with a practical exercise to test your skills.Let's get started with the development environment that you'll be using.
10.1    SAP BPM Positioning and Development Environment
SAP PO includes both the Advanced Adapter Engine Extended (AEX) and SAP BPM. These two products together form a dream team. For any team to operate optimally, the roles of each player need to be clear and well defined. Furthermore, each player's role needs to be well integrated with the other team players to cover the full spectrum of activities to be performed by the team.
10.1.1    Positioning
Let's define up-front the positioning and role of SAP BPM within SAP PO. Figure 10.1 depicts the positioning of both AEX and SAP BPM.

Figure 10.1    Positioning of the AEX and SAP BPM
The positioning of the AEX and SAP BPM are as follows:


AEX The AEX is placed between SAP BPM and the backend applications. The backend applications layer represents any SAP or legacy application providing a particular business content and functionality to an organization. These applications can be connected to or integrated using a diverse range of connectivity adapters that are provided by AEX.
                    The AEX layer links all of the message traffic and the exchange of data between applications. It plays the role of enterprise service bus (ESB) and performs tasks such as routing and message transformation. The AEX exposes the backend application's functionalities as services or interfaces. The services exposed by the AEX are presented in widely accepted communication standards and protocols and are ready to be consumed by other applications. We extensively covered the subject of the AEX in the first nine chapters of the book.
                

SAP BPM SAP BPM provides a complete suite of BPM development and administrative tools to help organizations design, model, execute, monitor, manage, and analyze business processes using one platform. It allows organizations to create new processes based on existing applications and functionality, as well as new types of processes that combine different types of sources of information, technologies, and platforms, which is why the SAP BPM layer can be placed on top of the AEX layer. From the SAP BPM layer, it's now possible to build different human-centric or system-centric processes that can use individual services exposed by the AEX.
                    The SAP BPM layer can consume the AEX services and orchestrate them. SAP BPM can call the first service in the AEX and use its response as the input of the next service call. This approach lets SAP BPM leverage and reuse the services already provided by SAP Process Integration (SAP PI) and therefore saves costs. This positioning lets the SAP BPM layer focus on the composition and bundling of services together to provide new functionalities and leaves the integration-related work (connecting, routing, and mapping) to the AEX, which means that direct connection to backend applications from the BPM layer should be avoided (when possible). It's better to consume functionality provided by the backend applications via the AEX.
                    This positioning choice and approach uses each component for the role that it performs best; by so doing, it creates the foundation for a robust architecture.
                

10.1.2    Setting Up Your Development Environment
To perform your development activities, you'll need to install the SAP NetWeaver Developer Studio, which is the Integrated Development Environment (IDE) to be used to develop SAP BPM. SAP NetWeaver Developer Studio can be downloaded from the SAP Marketplace, or go to http://wiki.scn.sap.com/wiki/display/Java/NWDS+Download+links.

Tip
It's important to download an SAP NetWeaver Developer Studio version that matches the version of your SAP PO installation. Be aware that if there is a mismatch between SAP NetWeaver Developer Studio and the server version, then you'll be able to build your process in design time but may face issues during deployment time.
As of release SAP NetWeaver 7.5, the new SAP NetWeaver Developer Studio can be downloaded from https://launchpad.support.sap.com/#/softwarecenter, by choosing By Alphabetical Index (A-Z) • • • SAP NetWeaver • SAP NetWeaver 7.5. Then, click on the blue Support Packages and Patches button at the top-right corner, and select Developer Studio • NW Developer Studio 7.50.
You can also find this information at https://wiki.scn.sap.com/wiki/display/Java/NWDS+Download+Links.

Given that SAP NetWeaver Developer Studio is a local development client, after installing it on your local computer, it will need to be configured to point to SAP PO's server. For an SAP BPM implementation, the most important settings to be configured in SAP NetWeaver Developer Studio are the SAP NetWeaver AS Java and the Enterprise Services Repository (ES Repository) connection.
In the next sections, we'll describe how to determine your SAP NetWeaver version to download the correct SAP NetWeaver Developer Studio version. We'll also explore how to configure each one of these settings.
Finding Your SAP Process Orchestration Version
To find the version of your SAP PO installation, follow these steps:


                        Go to http://<hostname>:<port>/nwa/sysinfo, where <hostname> is the hostname of your SAP PO installation, and <port> is the port number of your installation. The port number (if unchanged from the default) will be 5XX00, where XX is the SAP system number.
                    

                        On the resulting screen, select the Components Info tab.
                    

                        Here, a table is presented with the list of all existing software components (SCs). You'll need to filter for the SERVERCORE or J2EE-FRMW component and sap.com vendor. The SAP NetWeaver version can be found in the Version column. Looking at the installation presented in Figure 10.2, notice that the version is 1000.7.31.8.6.20131030153700. The most important part of this is 7.31.8, which means that we're running SAP NetWeaver or SAP PO release 7.31, SP 8.
                    


Figure 10.2    Finding your SAP PO Version from the System Information and Components Info Page
SAP NetWeaver AS Java
This configuration helps to point SAP NetWeaver Developer Studio to the SAP PO server where the modeled and developed SAP BPM processes will need to be deployed. Follow these steps to configure it in SAP NetWeaver Developer Studio:


                        After launching SAP NetWeaver Developer Studio, choose Window • Preferences.
                    

                        From the pop-up screen, select SAP AS Java on the left side, and then click on Add on the right side.
                    

                        You're then prompted with a new window in which you need to provide the Instance Host Name and Instance Number of the SAP PO server (see Figure 10.3).
                    

                        Click OK. You'll then see your newly added SAP PO server in the SAP NetWeaver AS Java list. Be aware that you can add multiple SAP PO servers in this list. You can further set the server that you're currently using as the default system.
                    

You're now finished with this part of the settings configuration, so let's proceed with the configuration of the ES Repository connection.

Figure 10.3    Configuration of SAP NetWeaver AS Java in the SAP NetWeaver Developer Studio
Enterprise Services Repository Connection
This is an optional setting and is only necessary when the SAP BPM process to be developed requires objects from the ES Repository to be imported in SAP NetWeaver Developer Studio. Follow these steps to set up the connection to the ES Repository:


                        From the top menu of SAP NetWeaver Developer Studio, choose Window • Preferences.
                    

                        Navigate to the Web Services section (on the left side of the screen), and expand the node (see Figure 10.4).
                    

                        Choose Enterprise Service Browser.


                        Add the parameters shown in Figure 10.4.
                    


Figure 10.4    Connection Settings to the Enterprise Services Repository









10.2    Creating and Modeling an SAP BPM Process
This section covers different aspects that come into consideration when creating an SAP BPM process including the concept of perspective in SAP NetWeaver Development Studio, creating a project, and the BPMN model.
10.2.1    Demonstration Scenario
The best way to demonstrate how to implement an SAP BPM process is to use a business process example. Let's start by describing our fictitious process requirements and the steps involved in completing them.
In our scenario, let's assume that the process expert of your organization approaches you (the SAP BPM expert) to implement the HR department's process for a company car for new employees. The process has already been drawn for you using the flowchart diagram represented in Figure 10.5.

Figure 10.5    Flow Diagram to Represent the Hiring Process
As represented in the chart, the process to be implemented is made up of the following steps:


                    The HR personnel captures the data of the new employee in the company's portal.
                

                    Based on how far away from the office the employee lives, a company car should be requested. In cases in which the employee lives 50 miles or more away from the office, he has the right to a company car.
                

                    For employees with the right to a company car, approval from the manager is needed.
                

                    If the manager approves the request, a car is ordered. A car can be ordered by calling a web service of the car lease company SpotLeaseCars.
                

                    If the manager rejects the request, then an email is sent to the HR personnel.
                

                    At the end of the process, all of the employee's data needs to be saved in SAP ERP HCM.
                

Now, it's time to draw the process in BPMN 2.0 using the SAP NetWeaver Developer Studio tool. After reading Chapter 9, you should be able to easily produce a BPMN representation for yourself on paper. See a potential BPMN representation of the process in Figure 10.6. Notice that in our process, we've identified four roles: HR_Personnel, SpotLeaseCars, Manager, and SAP_HR.

Figure 10.6    BPMN Representation of the Employee Scenario
Remember that this scenario will be used as a reference in the next sections, when we explore the different concepts of SAP BPM.
10.2.2    Building an SAP BPM Process: Overview
Before diving deep into the implementation, let's review the main tasks to be performed from a high-level perspective:


                    Switch to the right perspective in SAP NetWeaver Developer Studio.
                

                    Create a new project in SAP NetWeaver Developer Studio.
                

                    Model your process in BPMN, or reuse an existing model.
                

                    Create or import relevant message structures (data types, message types, or services interfaces).
                

                    Build mapping where relevant.
                

                    If the process contains a human task, then assign the human tasks, and generate or build the required user interfaces (UIs).
                

                    Build and deploy your process.
                

                    Configure the deployed process in SAP NetWeaver Administrator.
                

                    Run or use your process.
                

In the next sections, we'll explore each of these high-level steps in more detail.
10.2.3    SAP NetWeaver Developer Studio Perspective Concept
Because SAP NetWeaver Developer Studio has been built on top of Eclipse (a well-known Java IDE), it has the same main functionalities and general features. To perform SAP BPM-related activities, you'll need to be in the right perspective in SAP NetWeaver Developer Studio.
A perspective is a visual container for a set of views and editors, generally put together to help the developer easily implement a specific type of DC. In other words, with a perspective, the developer has access to all the functionalities required for his development activities. To perform SAP BPM-related activities, three perspectives can be used for specific situations, as described in Table 10.1.




                            Perspective Name
                        

                            Description and Role
                        





Composite Designer


                            Used for the development of composite applications. The scope of what can be built in this perspective goes beyond just SAP BPM. You can also build web-based applications, business rules, and much more. From this perspective, you can jump to the Process Development perspective—discussed in the next table row. This perspective is mostly used by developers.
                        



Process Development


                            Used to develop a runnable SAP BPM process from scratch or from an existing BPMN—possibly built using the Process Modeling perspective. In this perspective, all development activities, such as building and deploying SAP BPM processes, can be performed. The processes and models built from this perspective are marked with the status Released to Build. This perspective is generally used by developers.
                        



Process Modeling


                            This perspective is used most often by process experts to model their processes in BPMN. It's important to note that the BPMN models created from this perspective are marked with the status Draft and thus can't be compiled or deployed to the SAP PI server. After the process expert has finished modeling the BPMN from here, it's sent to the developer to be used as the starting point of his development—using the Composite Designer or Process Development perspective.
                        



Table 10.1    SAP BPM-Related Perspectives in SAP NetWeaver Developer Studio
To change or switch perspectives in SAP NetWeaver Developer Studio, follow these steps:


                    On the top-right side of the screen, click on the Open Perspective icon. Then, select Other (see Figure 10.7 1).
                

                    You'll then see the Open Perspective screen, giving you the choice to select any of the existing perspectives in SAP NetWeaver Developer Studio. As stated earlier, depending on what you plan to achieve, you can choose from among the Composite Designer, Process Development, and Process Modeling perspectives. Figure 10.7 2 shows some perspective selection possibilities for SAP NetWeaver Developer Studio. 
                    
Figure 10.7    How to Select a Different Perspective in SAP NetWeaver Developer Studio
                    Based on our demonstration scenario, you need to create a composite application that will include an SAP BPM process and Web Dynpro (to support the human tasks). Therefore, select the Composite Designer perspective, and click OK.
                

                    SAP NetWeaver Developer Studio will switch to the Composite Designer perspective. You're now ready to start your development activities.
                

10.2.4    Create a Project in SAP NetWeaver Developer Studio
Given that we're creating a composite application—which will include a BPM process and Web Dynpro—we'll now be creating a software product. The software product will include software components (SCs) that, in turn, will be made of several development components (DCs). Each DC will contain an application.
To create a product, follow these steps:


                    Right-click anywhere in the Composite Explorer, and select New Product (see Figure 10.8 1).
                    
Figure 10.8    Creating a Product for the Composite Application


                    In the pop-up screen, fill in the product details 2. Of course, you can use your own name and vendor name. Click on the Next button.
                

                    On the next screen, you're asked to select the SCs that will be included in your product. Depending on how you want to organize your application, you could use an existing SC or create a new one. In this case, choose to create a brand-new SC by clicking on the New Software Component button near the bottom of the screen (see Figure 10.9 1).
                    
Figure 10.9    First Two Steps of the Software Component Creation


                    The New Software Component screen appears, in which the attributes of the SC can be filled in. Leave the default values and fill in the name of the SC (Figure 10.9 2). Notice that the vendor name is automatically copied from the product; you can change it if you wish. Then, click on Next.
                

                    On the next screen (Figure 10.10 1), a list of SC dependencies are presented. The list of selected dependencies will determine the types of DCs that are allowed to be created in this SC, so it's important to pay special attention to this step. By default, all existing dependencies are selected. In this case, leave the default values as they are. Click on Next.
                

                    On the next screen (Figure 10.10 2), you can specify the SC version, and you can specify the desired value in Release, Support Package, and Patch Level. These numbers can help provide visibility and traceability for applied patches and the software lifecycle in general. You can leave the default values for now, and click on Finish.
                    
Figure 10.10    Software Dependencies Selection and Software Component Version Specification


                    Now that the creation of the new SC is finished, you're brought back to the original New Product screen, as shown in Figure 10.11 1. The newly created SC is automatically selected. You can also create additional SCs from here if you so desire. For now, stick with this new SC. Click on Next.
                

                    On the next screen, you can select the technologies that you'll need in your product. For every technology that you select, a DC will be created. See Chapter 18, Section 18.1, for more details on the DC concept. For those familiar with other Java IDEs, you can think of a DC as a development project. Click on Finish. Figure 10.11 2 depicts this action. For an explanation of what each technology choice can be used for, see Table 10.2.
                    
Figure 10.11    Selection of Technology Types to be Supported by the Product




                                    Name
                                

                                    Description
                                





                                    Process
                                



                                    Process modeling


                                    To be selected for creating an SAP BPM DC.
                                



                                    User Interface
                                



                                    Visual Composer


                                    Intended for the use of Visual Composer as the technology to develop your UIs or screens. From the context of SAP BPM, it can be used to develop web pages to support human tasks and be linked to the universal worklist (UWL). This is a lightweight alternative to Web Dynpro. Note that Visual Composer is an SAP proprietary technology.
                                



                                    Web Dynpro


                                    Used for the development of Web Dynpro components as the technology to develop your UIs or screens. From the context of SAP BPM, it can be used to develop web pages to support human tasks and be linked to the UWL. Web Dynpro is a fully fleshed out UI technology alternative to Visual Composer. Note that Web Dynpro is an SAP proprietary technology.
                                



                                    JSP/Servlet


                                    Used to develop a UI using Java Server Pages (JSP) or servlet. JSP and servlet are fully fleshed out UI technologies and aren't SAP proprietary technologies.
                                



                                    Business Logic
                                



                                    Composite Application Framework (CAF)


                                    Used to support composite application development.
                                



                                    Dictionary


                                    Used to create simple types, data structures, and tables that will be created in the database on SAP PO's server after deployment. SAP NetWeaver Developer Studio has a Dictionary perspective that provides all necessary views to enable the development of a dictionary DC.
                                



                                    Service composition


                                    Used to develop components capable of orchestrating data based on different service interfaces. This orchestration facilitates the provision of a single composite service. The Service Composer perspective eases these development activities.
                                



                                    Rules Composer


                                    Used when you intend to develop business rules based on SAP BRM.
                                



Table 10.2    Technology Selections When Creating a Product


                    A new screen in SAP NetWeaver Developer Studio opens with an overview of all the DCs that have been created as a part of your product. The DCs are grouped into their respective categories. You're now ready to start developing the different DCs. An example of the results for the composite application creation is presented in Figure 10.12.
                


Figure 10.12    Composite Designer Perspective after the Creation of a Product and Its Different Technologies
10.2.5    Creating a Process for Your BPMN
Now that all the required DCs for the development have been created, it's time to start the SAP BPM development activities. The first step is to create a process from which you'll be drawing your BPMN model. To create an SAP BPM process, follow these steps:


                    On the left side of the perspective, right-click on the Process category and choose New Process (see Figure 10.13 1).
                

                    You'll see a pop-up screen, in which you need to specify a few attributes. Table 10.3 describes each of these attributes; fill in the details accordingly. The final result is presented in Figure 10.13 2.
                

                    After filling in all the attribute's details, click on the Next button.
                    



                                    Attribute Name
                                

                                    Description
                                





Name (process)
                                

                                    The name of your SAP BPM process.
                                



Orientation


                                    This attribute specifies how you intend to draw your BMPN model. You have a choice between Top to Bottom and Left to Right:
                                    Top to Bottom You'll be drawing or reading your model from the top to the bottom. The first step of the process will be placed on the top of the screen, and the last step will be placed at the bottom of the screen.Left to Right The first step of the process will be placed on the far left side of the screen, and the last step will be placed on the right of the screen.
                                    This is purely a matter of personal preference. Depending on the side of the process to be modeled, one option might be better than the other.
                                



New Pool


                                    The pool object represents a process participant, and it also serves as a container for a single process. There can be one or more pools per process flow. Although it's not mandatory to use a pool, it's recommended to model your processes using a pool that encapsulates all the different process steps. Only one process is active at any given time (also referred to as the default pool).
                                



Name (pool)
                                

                                    If you decide to use a pool in your process, then you can specify a different name than the one generated by SAP NetWeaver Developer Studio.
                                



Lanes


                                    In a BPMN model, it's good practice to specify the different roles involved in the business process. You can list all roles here, separated by commas. An example entry might look like this: Manager, Employee, SAP-ECC.
                                



Project


                                    This is the project under which the SAP BPM processes need to be implemented. Because you right- clicked on the correct category during the creation, the right project is automatically selected for you. However, you have the option to change it or to create a new project. Be aware that these projects actually refer to DCs of the process type, which were created earlier during the product creation step.
                                



Table 10.3    Attributes Required to Create an SAP BPM Process

Figure 10.13    Creating a New SAP BPM Process and Maintaining Its Attributes


                    In this step, you have the option to create a new process event, which signals or triggers to start or end a process. We'll explore triggers in Section 10.4.1. For now, keep the default value. By default, an empty signal is created, which means that you'll need to manually start the process. This default trigger is called DefaultService_Empty. Click on the Final button (see Figure 10.14 1).
                

                    Finally, you're presented with the Overview screen in the Composite Designer perspective. A process has been added to your product 2.
                


Figure 10.14    New Process Event and Overview of the Product after the Creation of a Process
10.2.6    Creating a BPMN Model
After reading Chapter 9, you should have a good understanding of BPMN and should be equipped with the basic concepts needed to start modeling your process. Refer to Chapter 9 if you need a refresher before proceeding.
Follow these steps to create a BPMN:


                    Double-click on the Hiring_Employee block under the Process category. You'll see another screen with a basic process, including a pool containing all of the roles required by the process in the form of lanes. Furthermore, the process also has a dummy (or default) start and end event for the process.
                

                    Let's now modify this default process by modeling the BPMN to suit our needs. Right-click on the connection line between the start and end event. Select Delete to remove it (see Figure 10.15).
                    
Figure 10.15    Removing the Connection Line between the Start and End Event Activities


                    Mouse over the Start Event Activity icon on the BPMN (as shown in Figure 10.16), and you'll see menu options around the start event. These menu options are also sometimes referred to as speed buttons. The speed buttons are used to rapidly gain access to the BPMN objects and to speed up the modeling of the process. You can also delete the object by selecting the Delete icon at the top of the screen. Alternatively, you can add any BPMN objects from the palette on the right side of the Composite Designer perspective.
                

                    Select the Human activity from the speed buttons around the start activity (see the red circle in Figure 10.16). A Human activity represents the task to be performed by a human. In our scenario, the Human activity will represent the task of the HR personnel capturing the new employee's data.
                    
Figure 10.16    BPMN Element Added from the Speed Buttons or Palette


                    The selected Human activity is placed in the process and automatically linked to the start event with a connection line. You're then able to grab the new BPMN element and drag it to the right lane. The Human activity that was just added to the process needs to be placed under the HR_Personnel lane. You also can select the Human activity and maintain its properties. The Properties window automatically appears at the bottom of the perspective. Under the Name attribute, rename it to Enter Employee Data (see Figure 10.17).
                

                    Select the Human activity again, and use the speed buttons to place a gateway on the process. Make sure to select the Exclusive gateway. Give a new name to the newly added gateway.
                

                    Select the exclusive gateway step on the BPMN, and use the speed buttons to add another Human activity for the manager's approval.
                

                    Repeat the same steps to place more BPMN elements until the entire BPMN process is complete. The final result BPMN process is presented in Figure 10.18. Note that the Notification activity is used for sending an email to the HR personnel.
                    
Figure 10.17    Using the Properties of the Human Activity to Name It



Figure 10.18    Completed BPMN Representation of the Process, as Drawn in SAP NetWeaver Developer Studio
We've now completed our BPMN process, but you might have noticed that in the process we've drawn, there are some errors; note the red crosses on the left side of some of the BPMN elements. The red marks are a quick way to spot the problem areas in your BPMN.
If you mouse over the red crosses, then you'll see the details of the errors at hand. You can alternatively select the Problems tab at the bottom of the perspective, as shown in Figure 10.19.

Figure 10.19    Finding the Details of the Errors for the SAP BPM Process

Note
You can navigate your SAP BPM process and project tree by expanding Process, [LocalDevelopment] pr_hireemployee/pr/pm (the DC name), Process Modeling, and Processes in the Composite Explorer view (left panel) of the Composite Designer perspective. You then need to double-click on the process that you want to view (see Figure 10.20).

The tree structure of an SAP BPM process DC is made of many folders, as depicted in Figure 10.20. Table 10.4 explains the purpose of each folder.

Figure 10.20    Structure of the SAP BPM Process Project Tree




                            Folder Name
                        

                            Description
                        





Process


                            Contains your process. Notice that you can create multiple processes in the same project.
                        



Tasks


                            Contains tasks related to human activities.
                        



Event Triggers


                            Holds the triggers that can start a process or be used to trigger an intermediary event in a process. More details about intermediary events will be provided later in Section 10.4.1. This folder also contains escalations.
                        



Reporting Data Sources


                            Holds data sources used for reporting purposes in SAP BPM.
                        



Rule Sets


                            Contains a flow ruleset or a ruleSet. Be aware that you can embed a rule in the SAP BPM project instead of having a separate rule project.
                        



Functions


                            Holds expression functions, mapping functions, and new Enterprise Java Bean (EJB) functions. These are custom functions that can be developed to enhance existing functionality. More details about creating functions will be provided later in Section 10.6.4.
                        



Data Types


                            Holds XML Schema Definitions (XSDs) that have been created or imported from other sources, such as the ES Repository or an external file.
                        



Service Interfaces


                            Holds Web Service Description Language (WSDL) processes that have been created as part of the process or imported from other sources, such as the ES Repository or an external file. It can also hold Remote Function Call (RFC) structures.
                        



Table 10.4    Folders/Components Contained in a Process DC and Their Roles









10.3    Configuring the BPMN Model
In the previous sections, we modeled our process using BPMN. Now, it's time to configure the different BPMN elements. To configure the process, we'll create and add other supporting elements. In this section, we'll explore these supporting elements and explain some concepts that play a role in such a configuration.
10.3.1    Data Objects
Data objects are artifacts used to store process-related data. In a typical process, data is modified and changed at different steps of the process. Different statuses need to be maintained as the process is executed. A data object is linked to a data structure or data type. These data types can be simple or complex and are supported by an XSD. The XSD needs to be defined according to the business object structure. SAP BPM provides the option to directly create an XSD in SAP NetWeaver Developer Studio. The XSD can alternatively be imported from an external source, such as the ES Repository or the local file system. In most cases, it's common to import a WSDL from a service interface maintained in the ES Repository.
Given that data objects depend on data types, we'll need to create the required XSD and, where relevant, import the WSDL. Most times, when your process needs to call an external web service, it becomes necessary to import the relevant WSDL from the ES Repository. This basically means that the web service is first imported into the ES Repository because SAP PI/AEX needs to act as the broker or ESB. Therefore, the web service calls from SAP BPM processes will transit via the AEX.
10.3.2    Creating Data Structures
Based on our demonstration scenario, we need to create an XSD to hold the data to be captured by the HR personnel. These two standards are used to define the structures required for holding data. More details can be found from the W3C at www.w3.org.
To create an XSD in SAP NetWeaver Developer Studio, follow these steps:


                    On the left panel of your perspective, expand the pr_hireemployee/pr/pm DC, and then expand Process Modeling.
                

                    Right-click on Data Types, and select New XSD. The XSD Editor will be launched automatically, allowing you to start creating the new structure. Name your XSD "EmployeeData.xsd", and then click on Finish.


                    Select the Design tab in the bottom-left corner, as indicated in Figure 10.21. Right-click on the Elements section, and select Add Element from the dropdown menu.
                    
Figure 10.21    Adding a Type in the Data Type Editor in SAP NetWeaver Developer Studio


                    You need to maintain the properties of the new XSD element by renaming it to "EmployeeData". This new element needs to point to a complex data type that represents the total structure of the employee. Because the complex data type doesn't yet exist, leave the data type set to string for now.
                

                    If you see a pop-up asking you to accept the changes, click on the Accept button.
                

                    Create a data type by right-clicking on the Types section and selecting the Add Complex Type option. Name the new data type "EmployeeDataType".
                

                    If you see a pop-up asking you to accept the changes, click on the Accept button.
                

                    Double-click on the newly created EmployeeDataType to maintain its elements. It opens a new view, in which you can add new elements by using the context menu. Name each element and give each a type. Note that you can use the dropdown to select the correct data type (Simple or Complex).
                

                    Now that the EmployeeDataType has been created, go to the main view of the XSD Editor, and assign EmployeeDataType as the data type of the EmployeeData element.
                

                    Save all changes. You're now ready to use the XSD.
                

Note that when choosing a data type, you can choose data types that have been predefined by SAP. You'll see, however, that the initial dropdown list only includes the following subsets: boolean, date, dateTime, double, float, HexBinary, int, string, and time. If you want to explore an extended list of provided data types, then you need to select the Browse option from the dropdown, as indicated in Figure 10.22. You can also create a new data type of your own via the New option.

Figure 10.22    Available Core Data Types
10.3.3    Importing XSD and WSDL
Given that we need to call two web services in our demonstration scenario, we need to import their corresponding WSDLs into our project. To import a WSDL, follow these steps:


                    From the SAP NetWeaver Developer Studio menu, select File • Import.
                

                    In the screen that appears, select XSD under the WSDL node, and click on Next.
                

                    You can choose one of the following options from which to import the WSDL file:
                    

File System Choose this if your WSDL is available on your local file system. You'll then need to browse to the WSDL file and select Import.
                        

Remote Location Choose this when the WSDL is provided by an external system, and you have the WSDL link or URL. In this situation, enter the URL of the WSDL, and select Import.
                        

Enterprise Service Repository Choose this if you want to import the WSDL via a service interface that exists in your ES Repository. You'll then need to enter your credentials for the SAP PO system. The next step will be to navigate to the service interface in question and click on Next.
                        

                    For simplicity's sake, let's assume that you already have the XSD saved in your local file system.
                

                    Click on Finish. The imported WSDL and all its related XSDs are now available in your project under the Data Types folder.
                

These steps need to be repeated for each web service call step in your process—to order the car at the lease company (SpotLeaseCars) and to save the data in the SAP ERP HCM system.
10.3.4    Process Pool Properties
After the BPMN has been modeled, and the necessary XSDs have been created or imported, it's time to move to the next step, configuring the pool associated with the process. The pool needs to be configured to specify its attributes. To configure the pool, make sure to select it in the BPMN diagram. After selecting a pool, its properties will be displayed at the bottom of the screen, as shown in Figure 10.23.

Figure 10.23    Pool Properties Displayed in the Properties Tab
Table 10.5 lists the attributes contained in the properties and explains their roles.




                            Attribute Name
                        

                            Description
                        





General




Name


                            Name of the process. It's defined while creating a new process, so it's not an editable field.
                        



Description


                            A free text field in which you can write any text to describe the process.
                        



Make this pool active


                            Selects the current pool and makes it active. This checkbox is checked by default.
                        



Enable principle propagation


                            This option needs to be checked; the details of principals or users participating in the process are securely propagated and used further in the process.
                        



Administrators




Principals


                            The Administrators category is used to define a process's pool administrator, which can perform administrative tasks on the process, such as canceling, suspending, or resuming. 
                        



Principals (Cont.)
                        

                            A minimum of one administrator is mandatory in the process. While defining an administrator, you can choose between selecting an administrator directly from the user management engine (UME) of the SAP PO server or using an expression. The administrator subject is covered in more detail in the next section.
                        



Expression


                            When using an expression to define the pool administrator, you can make use of default functions provided by SAP to select the correct users or administrators during runtime. Use the getPrincipal function to specify the administrator.
                        



User Texts




Variables


                            Provides the feature of defining variables to hold content that can later be used in the Parameterized Texts field. A variable has a data type and can be assigned a value by using an expression.
                        



Parameterized Texts


                            You can use this to define a text that will be shown to the user in the portal or UWL. The relevant text includes a subject and description. You can make the text dynamic by embedding variables or parameters in your text. You'll need to use braces ({}) to refer to a variable.
                        



Table 10.5    A Pool's Attributes and Their Roles
Administrator via Principals
When maintaining the attributes of the Administrator tab, you can define the administrators of a pool via the notion of principals. A principal represents any user, user role, or user group responsible for some aspects of the process. As explained in Table 10.5, you can directly choose the principals who can act as responsible administrators of your process from the UME of your SAP PO server.
It's important to make sure that the connection to the SAP NetWeaver AS Java server is configured. The steps required to connect SAP NetWeaver Developer Studio to the SAP NetWeaver AS Java server were described in Section 10.1.2. It's also required that the user used to connect to the SAP NetWeaver AS Java has the MY_SPML_FULL_ACCESS_ROLE role assigned. Otherwise, the server will throw an exception when attempting to look up principals.
To choose the desired administrator, follow these steps:


                        Click on the Choose button on the right (see Figure 10.24 1).
                    

                        From the pop-up screen, you can select principals based on roles, users, or groups 2. You can then enter the desired keyword and click on the Search button. SAP NetWeaver Developer Studio must be able to connect to SAP NetWeaver AS Java for this step to work.
                        
Figure 10.24    Steps Involved in Configuring UME Principals as Administrators for the Pool


                        A new pop-up appears, requesting login details.
                    

                        After the set of results is returned, you can select the desired results and move them to the right side of the screen by clicking on the Add or Add All button.
                    

                        Click on the OK button when you've finished your selection.
                    


Note
You can select multiple users (principals) as administrators for your pool. Any of the selected principals can act as administrators for the pool.
When searching the desired principals to be configured as the administrators of the pool, you might see the error You are not authorized to search principals from UME. To fix this error, you'll need to add the MY_SP ML_FULL_ACCESS_ROLE role to the profile of the user used to connect to the UME. Alternatively, you can apply SAP Note 1647157.

It goes without saying that specifying a principal as a specific user might not always be a good approach. This is because you're required to know the names of the users in advance—that is, during the development time. This approach doesn't provide much flexibility. If you hard-code the name of a specific user in a task, then only this specific person can perform the task in question. What if the user is absent? Be aware that changing this attribute's value requires a transport—not very handy if your process is in production and you need to change it.
A better approach is to use roles or groups. In that way, you only need to add users to the appropriate role or group, and they will automatically be able to administer the process. Assigning a role to a user or adding the user to a group can be directly performed in the UME of the required environment (e.g., production) and doesn't require objects to be transported. As a result, this approach has less risk and offers more flexibility.
Administrator via an Expression
As mentioned in Table 10.5, you can use an expression instead of a principal, which can be an easy and flexible way to access the principals without having to connect to the server. Figure 10.25 shows an example of an expression that assigns all users with the ouradministrators role as administrators of the process.

Figure 10.25    Defining the Pool Administrator
Some expressions you can use are listed in Table 10.6.




                                Expression
                            

                                Description
                            





getPrincipalByUniqueName


                                The function expects two input parameters of type string. The format looks like this: getPrincipalByUniqueName(string uniqueName, string identityType). The parameter identityType represents a principal type. Possible values are "user", "group", and "role". The parameter uniqueName represents the actual unique name of the user, group, or role in your SAP NetWeaver AS Java UME. The function looks up the principal in the UME of the SAP NetWeaver AS Java during runtime.
                                Example: getPrincipalByUniqueName("John", "user")




getPrincipal


                                The function only expects one input parameter of type string. This input represents the principal ID without specifying whether the principal is of type user, role, or group. In cases in which users, groups, or roles in your UME have the same name, you might end up with unexpected results. It's important to be aware of this fact and to take it into consideration.
                                This function works in a different way than the function getPrincipalByUniqueName, which is more specific. In addition, note that the getPrincipal function expects a UME "technical name" as a value.
                                Example: getPrincipal("John")




getPrincipals


                                This function takes as an input an array of type string. The function then returns a list of principals. All of the returned principals will therefore be able to administer the process.
                                Example: getPrincipals(("USER.PRIVATE_DATASOURCE.un:John", "USER.PRIVATE_DATASOURCE.un:Roberto"))




Table 10.6    Expressions Used to Retrieve Principals
The expressions listed in Table 10.6 can be found under  Rules and Functions • Principal, as shown in Figure 10.26.

Figure 10.26    Selecting Principal Expressions from the Rules and Functions
Remember that when using the getPrincipal or getPrincipals expression, you're required to use the technical name or unique ID field of the principal, as indicated in the UME. Figure 10.27 shows an example of how to find this information. The following is an example of a unique ID for each principal type:


USER.PRIVATE_DATASOURCE.un:john


ROLE.UME_ROLE_PERSISTENCE.un:Administrator


GRUP.PRIVATE_DATASOURCE.un:NWDI.Developers



Figure 10.27    Finding the Unique ID for a Principal in the UME
10.3.5    BPMN Flow Objects
We explored BPMN flow objects in Chapter 9. In the next sections of this chapter, we'll dive into the technical aspects and configurations of these BPMN objects within the context of SAP BPM.
Properties
All flow objects of an SAP BPM process have property attributes that are used to configure their behaviors. Depending of the type of flow object in use, the attributes to be maintained might differ. By selecting any BPMN flow object, a Properties view is loaded that contains its attributes. Every BPMN object contains a General tab. This tab in the Properties view contains descriptive information fields, such as for the Name and Documentation of the start event (see Figure 10.28).

Figure 10.28    Flow Object Details in the General Tab
Format Lanes
Any BPMN model can be formatted to rearrange its layout to make it more readable. A model can be easily formatted by bringing up the context menu on its pool or lane and selecting the Format Lane option, as shown in Figure 10.29.

Figure 10.29    Formatting a BPMN Model to Rearrange Its Layout and Increase Readability









10.4    Flow Objects
Chapter 9 touched on flow objects purely from a modeling perspective. This section will dive deeper into each type of flow object from a technical perspective. This section will describe how to configure these objects and will explore the different available configuration options and how they can impact the behavior of these flow objects.
10.4.1    Events
An event indicates that something occurred during the running of the process. Next, we'll be exploring some specific events. As discussed in Chapter 9, we can distinguish the following main types of events:


                    Start event
                

                    End event
                

                    Intermediary event
                

                    Boundary event
                

The technical aspects and configuration details of each of these event types will be discussed in the next sections.
Start Event
The start event is the first object found in the beginning of the process and has no incoming connections or sequence flows. In the next sections, we'll describe the start event properties.
Event Trigger
In most cases, a start event is linked to a trigger or signal. After a trigger is received, the SAP BPM engine evaluates whether it matches the process definition. If there's a match, then a new instance of the process is created, and the process is started. In some scenarios, it's not required to specify an event to start a process. In an embedded subprocess, for instance, it's not mandatory to have a start event's trigger.
To specify whether or not a start event has a trigger, follow these steps:


                            Select the start event from your process.
                        

                            The Properties view is then displayed in the bottom of the screen.
                        

                            Select the Event Trigger tab, and select the relevant radio button, either Message or None (see Figure 10.30).
                            
Figure 10.30    Default Trigger Configuration of a Process


If the Message radio button is selected, then an appropriate message trigger needs to be specified. By default, the following message triggers are available:


DefaultService_Empty This message trigger is assigned by default to the start process. It's advised to use this message trigger when you intend to manually start the process via SAP NetWeaver Administrator. As the name suggests, DefaultService_Empty expects an empty message. It's a synchronous message, so you can expect an empty message back to indicate the process has started.
                        

DefaultService_EmptyAsync This message trigger is mostly identical to the previous one, except for the fact that it's asynchronous; no reply message can be expected.
                        

Alternatively, you can decide to start the process upon receipt of a web service call. In that case, you'll need to create a new message trigger that points to the message structure of the WSDL of the message in question.
If you created a message trigger, then it becomes possible to select the newly created trigger from the dropdown box. Refer to Section 10.4.1 to learn how to create a trigger.
Output Mapping
Because the start event is the first element of the process, we don't have an input mapping, only an outbound mapping. The input mapping is indirectly represented by the message trigger. In the outbound mapping, you can transform the initial message that started the process to any of the other data objects.
Start Condition
A start condition provides a mechanism to further specify under which condition the process can be started. Instead of accepting all incoming messages that match the trigger, we also want the incoming message to pass an extra condition. Considering the demonstration scenario about employees, assume that we only want employee data with a start date later than January 1, 2015, to start a process. In such a scenario, we can consider specifying the start condition.
Note that, by default, the start condition is always the Boolean value true, which basically means that there is no correlation and that any message matching the trigger structure can start the process.
End Event
As the name of the event suggests, the end event is the last step in a process flow, and it indicates the end of the process. It contains no outgoing connections or sequence flows.
Event Trigger
The end event can also trigger messages as a response to a previously synchronous instantiated process. In that case, a trigger based on a WSDL will need to be assigned to the end event. In cases in which the process needs to return a response, the same (synchronous) trigger used in the start event can be reused for the end event.
Other supported trigger types for the end event are described in Table 10.7.




                                    Trigger Type
                                

                                    Description
                                





Message


                                    Enables the process to return a message if the trigger used for the start event was synchronous.
                                



Error


                                    Facilitates the throwing of an error.
                                



Escalation


                                    Used to signal a business error. This type of error generally needs to be handled in your process.
                                



None


                                    In some cases, like an embedded subprocess, an end event doesn't need to have a trigger.
                                



Table 10.7    Trigger Types for the End Event
In the event trigger, you can maintain the Terminating property. If this checkbox is selected, then the end event will terminate any other running activities in the process—like any parallel flow. By default, this checkbox is unchecked.
Input Mapping
Because we're dealing with the last object in the process, we only have an input mapping and no output mapping. If the end event is of the type Message and needs to return a message, this mapping can be used to populate the appropriate response message.
Intermediary Event
Intermediary events were introduced in SAP Composite Environment 7.2. An intermediary event puts the process in a wait phase until a specific signal or event has been triggered toward the process. This type of event is generally placed in the middle of the process—between the start and end events. The process goes into an idle or sleep mode until a specific trigger is received.
We can distinguish different types of intermediary events:


                        Message
                    

                        Timer
                    

                        None
                    

We'll now explore each of these event types.
Message
An intermediate message event signals the process that a particular message is received. This type of event exists as a process step (in the BPMN model of the process) and generally represents the fact that one of the surrounding applications wants to signal an existing instance of a process about some event that occurs. The running process is generally in an idle mode and waiting for such an external trigger to resume running. When a matching intermediate message or trigger is received, the process instance proceeds to the next process step. Figure 10.31 shows what an intermediary message object looks like.

Figure 10.31    Trigger Types of an Intermediary Message Event Step
Scenarios in which the intermediate message event can be used include the following:


                            A message collect pattern (collection or aggregation of messages matching a particular message type and correlation).
                        

                            Communications or conversations between two running processes.
                        

                            Communications or conversations between a running process instance and another application in the environment. This application should also be represented in the BPMN model as one of the pool's lanes.
                        

The intermediate message event is an asynchronous message and generally involves the use of correlation as a way to match the incoming message with the correct running process instances. If multiple process instances are matched, then this leads to the broadcast. The process of receiving this asynchronous message as an intermediary message happens in two asynchronous and independent transactions that don't necessarily happen at the same time. The two transactions are as follows:


Matching This is the first step in which the arriving asynchronous message is received by the process server. The process server then compares the arriving message with the correlations of all existing and running process instances. If there is a match with one or multiple processes, then the message is put into a queue for it to be delivered to the matching process instances. This is where the next transaction (delivery) comes into play. If there are no matches found, then the message stays in the queue.
                        

Delivery In this transaction, the messages that were previously matched are delivered to the corresponding process instances. The intermediary steps of these process instances are therefore executed.
                        

When a trigger is of type Message, you're required to set or select the corresponding message trigger. Figure 10.31 depicts an example of an intermediary message event with the message trigger called MsgF2FDELI008AcknowledgeSalesOrderOut.
The message trigger represents the asynchronous service interface or web service to act as the trigger for the intermediate message event. You can read more on message triggers in Section 10.4.1.
In addition to the message trigger, it might be necessary to define the correlation conditions to be used. The correlation needs to evaluate to true or false (as a Boolean) where true represents a match, and false represents a mismatch. By default, the correlation condition is set to true, which means that the correlation will always match; in other words, the correlation is disabled by default.
You can also create a condition that evaluates fields in the incoming message and process context data (e.g., data objects). The expression to be built can be simple or complex.
Table 10.8 contains some examples of correlation conditions and their descriptions.




                                    Correlation Condition


                                    Description
                                





true


                                    Having a Boolean set to true by default means that all messages matching the trigger will be accepted by the intermediary message event. It basically means that there is no correlation needed. Be aware that if you change the Boolean to false, then the intermediary event will never be triggered.
                                



string-equal(AcknowledgeSalesOrder/OrderNumber, DO_OrderNr)


                                    This condition will compare the OrderNumber field from the incoming message to the DO_OrderNr data object, which already exists as part of the running process instance. If those two numbers match, then the condition evaluates to true, and the intermediary event will be executed. This type of setup is generally used to support a collect pattern.
                                



Table 10.8    Correlation Conditions

Note
The correlation condition is by default set to the Boolean value true. This value means that the correlation is disabled, and any message matching the message trigger will be consumed by the intermediary message event.

Timer
The intermediate timer event provides the mechanism to make a particular running process instance stop and wait until a certain period of time has elapsed or passed. Figure 10.32 shows what an intermediary timer object looks like. In SAP NetWeaver Developer Studio, you can't configure a trigger while configuring an intermediate timer event step. Instead, a Timer Configuration tab needs to be configured, as shown in Figure 10.32. You can use one of the following options:


A time offset The amount of seconds, minutes, days, months, or years that the process need to wait before it can resume. The time offset starts from the time the intermediate timer event step is reached.
                        

An expression By using the expression editor, you can define the trigger time. Here, you want the expression to evaluate to the time that the process needs to resume. Be aware that the expression is evaluated in milliseconds.
                        


Figure 10.32    Example of Timer Configuration Using a Time Offset of Five Minutes
SAP provides a lot of useful functions for configuring an intermediate timer event via an expression. See the rules and functions in the Durations, Dates and Times node, as shown in Figure 10.33.

Figure 10.33    Rules and Functions for Use when Configuring a Timer Event Using an Expression
None
The None intermediary trigger type has no real use in the runtime. It's mostly used as a temporary step while modeling the process and when the exact details of the trigger to be aren't yet known. The None intermediary trigger type will need to be changed later to a message or timer.
Boundary Event
A boundary event is a special type of event that throws an exception in a process. This type of event is always attached to another activity. When an exception occurs in an activity (to which the boundary event is attached), the boundary event is triggered, and the exception is caught. In the case of a boundary event attached to an automated activity, the service interface or WSDL used must have a fault message attached to it.
A boundary event redirects control to the steps defined in the outgoing sequence flow from the boundary event (see Figure 10.34).

Figure 10.34    Example Configuration of a Boundary Event Attached to an Automated Activity
In the process depicted in Figure 10.34, when an exception occurs in the automated step, the boundary event catches the exception and transfers the process control to a human activity. In our demonstration scenario, when an error occurs while ordering a car at the lease company, the exception is caught by the boundary event. The exception is then handled by another human task (called Handle Exception).
In addition, note that the activity has a Boundary Events tab, from which you can configure the boundary events. To configure the boundary events, follow these steps:


                        Select the activity (here using an automated activity) for which the boundary events need to be configured. In the case of an automated activity, the event trigger must contain fault messages. For every fault type, you can add a boundary event.
                    

                        In the Properties view, select the Boundary Events tab, and add the fault messages for which you want to configure the boundary event by clicking on the Add button.
                    

                        In the pop-up screen that appears, select the desired fault message. Click on OK. The boundary event will appear on top of the activity, and the outgoing sequence flow can be configured to handle the exception.
                    


Note
You can attach multiple boundary events around an activity—one boundary event per message fault type. Each boundary event has its own outgoing sequence flow, enabling the SAP BPM process to handle multiple exception types. Having multiple boundary events has the advantage of giving you more control for handling different exceptions in different manners.

Message Trigger
A message trigger represents an event of receiving a specific message in the SAP BPM engine. Message triggers are reusable entities, are normally used to start processes, and are referenced by different types of events. To create a new message trigger, you need to have a WSDL (that you imported or created) in your project as a prerequisite. To create a message trigger, follow these steps:


                        From your project structure (in the Project Explorer view of SAP NetWeaver Developer Studio), click on the SAP BPM DC node named [LocalDevelopment] pr_hireemployee/pr/pm to expand it. Then, click on Process Modeling to expand it further.


                        Click on the Event Triggers node to expand again.
                    

                        Right-click on the Messages node, and select the New Message menu item (see Figure 10.35).
                        
Figure 10.35    First Steps of Creating a Message Trigger


                        A wizard starts in which you need to fill in the name and documentation of the message trigger. Note that as you specify the trigger name, the endpoint and link to the WSDL link are modified (see Figure 10.36 1). This is the WSDL, which can be used to externally trigger or call the SAP BPM process. Then, click on Next.
                    

                        Select the service interface and operation to be used as a message trigger of the process. In this case, select the EmployeeData WSDL that you created in Section 10.3. Click on Finish 2.
                    

After the message trigger is created, it can be referenced by events such as start events, end events, or intermediary message events.

Figure 10.36    Steps to Create a New Message Trigger
10.4.2    Tasks
A task is an action that needs to be performed by a human. From a technical perspective, a task enables us to point to a particular UI technology to be used for the user to perform the human action represented by the task and the human activity. A task can be used in a human activity object, which will be explored in Section 10.4.3. A task is reusable and can, in principle, be used in multiple human activities.
A task has a number of attributes (or task settings) to be maintained Table 10.9 lists the attributes, specifies their categories, and describes their roles.




                            Option Name
                        

                            Category
                        

                            Description
                        





Name


                            Overview
                        

                            The name given to the task. Use a descriptive name.
                        



Documentation


                            Overview
                        

                            Some description or documentation about the purpose of this task. As the name states, it's purely for your own documentation purposes.
                        



Sharing


                            Overview
                        

                            Specifies whether the task owner is allowed to invite other users to contribute to and give input about the task. However, the owner remains the responsible person for the task and has the responsibility to complete it.
                            Any user in the UME can become a contributor to the task but needs to be invited. A contributor is allowed to add notes and attachments to a task and to monitor a particular task.
                        



Notification


                            Overview
                        

                            A task provides the features of sending an email notification to a task's owner when a task has been assigned to the user.
                            The email contains the usual attributes, such as a subject and a body, which can be dynamically customized to include the details relevant to the task. In the notification, a link to the task to be claimed is included.
                        



Component


                            Overview
                        

                            The component attribute needs to be linked to the component containing a UI for the task. Common UI components include online technologies (Web Dynpro Java, Web Dynpro ABAP, Visual Composer), offline technologies (Adobe Forms), and custom technologies.
                            Custom technologies can be used if you prefer to use any non-SAP technology that can be deployed in SAP NetWeaver AS Java and that is capable of using the API provided by SAP BPM to read and write the data of a task.
                        



Priority


                            Overview
                        

                            Specifies the priority of the task. The possible values are Very High, High, Medium, and Low. By default, the value is set to Medium.
                        



Custom Attributes


                            Attributes and Actions
                        

                            Custom attributes enable you to specify business context data in the tasks. By adding business-related custom attributes to tasks, it helps give the user more context about that task. For instance, you could add the user ID of the person who started the process to which this task relates.
                            This in turn provides relevant business input to the task so that the appropriate steps can be taken or decisions made. A custom attribute has a name (must be unique), label, data type, and expression. Using the expression editor, a value can be assigned to the attribute from the task input.
                        



Custom Actions


                            Attributes and Actions
                        

                            Facilitates the definition of your own tasks beyond the standard SAP tasks. Without opening a task, you're able to perform your own defined actions on a task. Custom actions can also be accessed via the SAP BPM API. By default, the following actions are available: View, Claim, Release, and Complete.
                        



Excluded Owners


                            Roles
                        

                            Excluded owners are users that aren't allowed to complete a particular task. This is a very useful feature because it enables the exclusion of some users from performing a task. A typical scenario in which such a mechanism can be used is in processes involving requesters and approvers. You want to prevent the user who played the role of requester from being the approver of his own request.
                        



Administrators


                            Roles
                        

                            Administrators are users who are allowed to administer, process, or complete a task. If there is more than one user allowed to execute a particular task, then the actual owner of the task is the user who eventually completes the task.
                            Administrators are also able to view, monitor, and manage processes and tasks and to start and debug SAP BPM processes. For a user to be able to properly assume an administrator's role, he needs a set of administration UME roles and groups assigned to his user profile.
                        



Variables


                            User Texts
                        

                            For every task that is created, you can specify the text to be contained in the subject and description of the task in a static manner.
                            This is the message or text that the task owner sees in his UWL, a tool that simplifies task management for business users. From the UWL, users can access alerts, notifications, approvals, and their tasks.
                            Variables allow you to improve this functionality by catering to the creation of dynamic custom text that can be used in the task's text and name. A variable has a name (must be unique), data type, and expression. Using the expression editor, you can assign a value to the variable based on any context data or available functions.
                        



Parameterized Texts


                            User Texts
                        

                            Specifies the text or message to be sent to the responsible user via an email notification. This text will also be displayed in the user's inbox. The text can be made dynamic by adding variables. Variables can be added to the text using brackets { }.
                        



Activation Time


                            Time Constraints
                        

                            Specifies the time from which the potential owners can see the task. By default, the task is visible as soon as it's created, so you don't need to set this field if you don't have a special requirement. This information can be expressed by using an expression.
                        



Start Deadline


                            Time Constraints
                        

                            Specifies the time before which the task must have been started by one of the potential owners. If the time is reached without the task being started, then an exception can be raised. You'll need to select the checkbox to raise the exception if this behavior is desired. The start deadline can be expressed by using an expression.
                        



Completion Deadline


                            Time Constraints
                        

                            Specifies the time before which the task must have been completed by one of the potential owners. If the time is reached without the task being completed, then an exception can be raised. You'll need to select the checkbox to raise the exception if this behavior is desired. The completion deadline can be expressed by using an expression.
                        



Expiration Time


                            Time Constraints
                        

                            Specifies the time after which the task is no longer valid or expires. After this time, tasks can no longer be claimed or completed by a user. The task moves into a Canceled status. This information can be expressed by using an expression.
                        



Table 10.9    Task Properties' Options, Categories, and the Roles They Play
To create a new task, follow these steps:


                    From the Project Explorer view in SAP NetWeaver Developer Studio, select your project, and collapse all the nodes until you get to the Tasks node.
                

                    Right-click on the Tasks node, and select New Task (see Figure 10.37 1).
                

                    You'll see a pop-up screen, in which you need to specify the name of the new task and its documentation (optional). You can also decide to generate a UI component at this step by selecting the Generate UI component checkbox. If you decide to generate a UI component, then proceed to Step 4; otherwise, click on Next 2.
                    
Figure 10.37    First Steps of Creating a New SAP BPM Task


                    You're asked to select the process for which the UI component will be created. This is especially relevant if you have more than one process in your current project (see Figure 10.38 1).
                

                    On the next screen, select Web Dynpro for the UI technology 2. You can also select other UI technologies from the UI Technology dropdown field.
                    
Figure 10.38    Selecting the Process and UI Technology to be Used for the SAP BPM Task


                    Note that SAP NetWeaver Developer Studio automatically selects the Web Dynpro DC that was created as part of the composite application. You also have the choice of creating a brand-new Web Dynpro DC, but in this case, leave the default values (see Figure 10.38 2). Click on Next.


                    You're now provided with some UI component details. The required details will go into the Name, Completion Event, and Error Event fields. These details are prefilled in by default with names constructed based on the task's name, and you can choose to leave the default values here. Click on Next (see Figure 10.39 1).
                

                    It's now time to select process context attributes and data (e.g., data objects) to be used and displayed in the new UI component. You can choose all the attributes that are relevant for you by selecting their checkboxes 2.
                    
Figure 10.39    Details of the New UI Component SAP BPM Task


                    After you're done, click on Finish.


You're now presented with a task screen showing the name of the UI DCs that you just created. They are populated in the component attributes, as shown in Figure 10.40. In addition, note that you can send the notification by email by selecting the Notification checkbox.

Figure 10.40    Final Look at the Task Object after Linking It to a Web Dynpro Java DC
After successfully creating a task, the only remaining action is to use it in a human activity. More details about the human activities are presented in Section 10.4.3.
When creating a task, you might want to add some business data in the task's subject or description to give it more context. This is referred to as parameterized text. To create parameterized text, follow these steps:


                    Open the task for which you want to create parameterized text.
                

                    Click on the User Texts tab.
                

                    Click on the Add button to the right of the Variable section, and name the variable. Select string for the Type (see Figure 10.41 1).
                

                    Select the variable you just created, and click on the Edit button. You're then presented with an expression editor, in which you can select where the variable should get its value from. In this case, we'll need to concatenate Firstname and Lastname to Fullname, which is present in the UI component 2. Be aware that you can define as many variables as you need to achieve your goal.
                    
Figure 10.41    Creation of a Variable and Assigning It a Value via Functions and Data Objects


                    Now that the variable is ready, it's time to create the parameterized text for the subject and description. Enter any desired text, and include the desired variable surrounded by brackets { }. The Subject field in Figure 10.42 shows an example of such a dynamic text implementation.
                


Figure 10.42    Example of a Subject Using a Variable to Make Text Dynamic
10.4.3    Activities
As the name indicates, an activity is an object in your BPMN that represents an activity or action to be performed automatically by the system (system-centric) or by a human (human-centric). In addition to automated or human activities, many more activities are supported within SAP BPM. The following activities are supported:


                    Activity
                

                    Human
                

                    Automated
                

                    Mapping
                

                    Embedded subprocess
                

                    Referenced subprocess
                

                    Notification
                

Next, we'll explore each of these activities and give more technical details about their roles and how they can be configured.
Activity
This is a placeholder that represents work and actions to be performed. It's mostly used during modeling and should be later changed to a human, automated, referenced subprocess, or embedded subprocess activity.
Human Activity
A human activity is used in a BPMN to model an action or task to be performed by a human. Other BPM platforms refer to this activity as a user task. In general, a human activity is performed via a UI. A human activity can be claimed and completed by an SAP NetWeaver UME user.
SAP NetWeaver provides a wonderful functionality that allows you to automatically generate a UI based on a diverse range of SAP-supported UI technologies. A human activity has a number of property attributes that will be explored in the next sections.
General
This tab in the property view contains descriptive information, such as name and documentation.
Looping
This section enables the human activity to be repeated multiple times. This is sometimes referred to as the multi-instance loops of activities. It uses the Parallel For Each loop option and creates multiple instances of the human task in parallel.
To be able to specify the number of activity instances to be created in parallel, you'll need to point to a context object (data object) in the process containing a collection. You can alternatively use an expression that produces a list. The number of items contained in the list will determine the number of human activity instances that will be executed in parallel. Figure 10.43 shows an example configuration of the looping using a human activity.

Figure 10.43    Example of a Human Activity Configured with Looping
The looping or Parallel For Each option can be configured for most activities, including human, automated, reporting, mapping, embedded subprocess, and referenced subprocess activities.
Be aware that if you configured looping for an activity, then two new context objects (data objects) are created (see Table 10.10).




                                    Local Data Object Name
                                

                                    Description
                                





currentCollectionItem


                                    Holds the item list of elements that have to be used to create each loop instance
                                



numberOfCompletedIterations


                                    Holds the number of instances of the loop that have already been executed and completed their execution
                                



Table 10.10    Local Data Objects Used Specifically for Activities Using Looping
These data objects can be found in the input mapping and outbound mapping of the activity in question. See the next section for more details about how to create and deal with a task.

Tip
When using a loop, be aware that in runtime, the process will only proceed to the next steps when all the created parallel instances have been executed or completed (in case of a human activity).

Task
A task enables you to point to a particular UI technology to be used for the user to perform the human action represented by the task and human activity. After creating a human activity, that activity is assigned a default task called DefaultTask. You can assign another task to it as well. The topic of tasks was explored in Section 10.4.2. Assuming that you already created a task, you only need to point the human activity to the task. The task attribute included in a human task can be seen as a pointer that references an existing task.
In addition to the task settings already maintained in a task (explained in Section 10.4.2), the human task provides the flexibility to overwrite the attributes already maintained in the task. These setting values can be overwritten by selecting the checkboxes of each relevant task setting. After ticking a checkbox, further options will be displayed in the navigation, as shown in Figure 10.44.

Figure 10.44    Task Properties' Options
Most of these options were already explained in Section 10.4.2 as part of the attribute options for a task, with the exception of the Potential owners attribute. Potential owners are users who are allowed to process or complete a task. If there is more than one user allowed to execute a particular task, then the actual owner of the task is the user who eventually completes the task. Be aware that both the potential and excluded owners' concepts don't only apply to tasks. These concepts are also used for a single human activity and for individual lanes.
Being able to overwrite a task's attributes from the human task is very handy for SAP BPM developers because it gives the flexibility to reuse the same task in multiple human activities and to have them behave differently. Each one of the task instances will adopt different attributes or settings from their respective human activities. This approach encourages reusability and avoids the creation of a new task for each human activity. A human activity can easily be linked to a task by selecting the appropriate task from the dropdown, as shown in Figure 10.44.
Input Mapping
If you consider the process depicted earlier in Figure 10.43, in which a human activity is required to take a human action if the call service task fails, you might need to map some details (e.g., the full name) from the process to the human activity.
The input mapping in a human activity allows you to map values from the process context to the task. By doing so, you're populating the task with the required inputs. By default, a human activity comes with a local context object named TaskInput, which is made of two main parts:


TaskAttributes This is a mandatory element that is always present in TaskInput that is intended to contain the attributes of a task.
                        

UIRequest This element contains the values that will be presented to the user as part of the UI. By populating these attributes, you're indirectly populating what data the user will see when processing the task.
                        

The topic of mapping will be covered in Section 10.4.3. For now, what is important is the fact that values from the process context are used to populate the TaskAttributes and UIRequest local data objects for tasks (see Figure 10.45).

Figure 10.45    Example of Input Mapping of a Human Activity Used to Populate the Data to be Displayed in a Task
Output Mapping
The output mapping of a human task facilitates the mapping or copying of data from the task's UI to the process context. This mechanism allows you to copy the data that the user entered in the UI back to the process for further processing.
The outbound mapping step is only performed after the task has been completed by the task's owner and the control has been returned to the process. By default, the element named TaskOutput, which contains all the data entered by the process owner, is provided. The TaskOutput local data object contains more data than the TaskInput, which is used in the input mapping. It contains nearly all of the task's attributes. All of these task attribute values can now be retrieved because the task has been completed, and details such as who executed the task and which values were filled in by the task owner are now known. Figure 10.46 shows an example of how the process context is populated with data filled in by the user from a Java Web Dynpro UI.

Figure 10.46    Sample Outbound Mapping of a Human Activity to Populate the Process Context with Data Filled by the Process Owner
Boundary Events
We've touched on the boundary event from a general perspective. When looking at boundary events from a specific human task context, they represent situations in which the execution of a human task can fail or terminate in error. The exceptions are generally generated as a result of one of the constraints set by the task's attribute settings (e.g., start deadline, activation time, etc.) not being met.
The exceptional or erroneous situation in a human task can be categorized as follows:


Critical exceptions The task processing is canceled, and the corresponding boundary event should catch and handle the exception.
                        

Noncritical exceptions The task processing isn't canceled and carries on its processing normally from the noncritical boundary event.
                        

The possible exception types and their categories are listed in Table 10.11.




                                    Exception
                                

                                    Description
                                





CompletionDeadlineIs- CriticalException


                                    Exception thrown when the Completion Deadline attribute constraint isn't met and the Raise critical exception when deadline is reached checkbox has been selected in the task's settings.
                                



CompletionDeadlineIs-NonCriticalException


                                    Exception thrown when the Completion Deadline attribute constraint isn't met and the Raise critical exception when deadline is reached checkbox hasn't been selected in the task's settings.
                                



HandleExceptionErrorEvent


                                    Exception thrown in any other case not listed in this table.
                                



StartDeadlineIsCritical-Exception


                                    Exception thrown when the Start Deadline attribute constraint isn't met and the Raise critical exception when deadline is reached checkbox has been selected in the task's settings.
                                



StartDeadlineIsNon-CriticalException


                                    Exception thrown when the Start Deadline attribute constraint isn't met and the Raise critical exception when deadline is reached checkbox hasn't been selected in the task's settings.
                                



Table 10.11    Possible Human Task Exception Events
To add boundary events from a human activity, follow these steps:


                            Make sure that the correct task settings were configured. If you're interested in raising a critical exception, then select the Raise critical exception when deadline is reached checkbox to raise the exception (Figure 10.47).
                            
Figure 10.47    Raising an Exception When a Deadline Occurs


                            Select the human activity for which the boundary event needs to be created.
                        

                            Navigate to the Properties view, and select the Boundary Events tab.
                        

                            Click on the Add button (Figure 10.48).
                        

                            You'll see a pop-up, in which you need to select the desired exception type. Click on OK.
                        


Figure 10.48    Steps Involved in Setting Up Boundary Events in a Human Activity
Automated Activity
Automated activities are steps in an SAP BPM process that need to be performed by a system without human intervention. They are often referred to as system-centric steps. From a technical perspective, an automated activity will invoke a web service or make an RFC. This can be considered the opposite of a human activity.
SAP NetWeaver Developer Studio simplifies the modeling and configuration of an automated activity in your process. You can add it to your process by using one of the following methods:


                        Use the speed buttons by mousing over any object or process step in the BPMN model.
                    

                        Drag the automated activity object from the palette on the left side of the SAP NetWeaver Developer Studio, and drop it at the appropriate location in your existing SAP BPM process.
                    

                        Drag the service interface's operation element from the WSDL that has been imported in SAP NetWeaver Developer Studio. This is a very handy method because the automated activity is automatically configured to point to the appropriate service interface. However, this method requires the service interface in question from the ES Repository to be present already and imported in the SAP NetWeaver Developer Studio project. Refer to Section 10.3 for an explanation of importing XSD and WSDL.
                    

It's now time to explore the automated activity's property attributes and their roles. The first tab, like in other activities, is the General tab. The other tabs and properties are discussed ahead.
Looping
Looping enables the automated activity to be repeated multiple times. It uses the Parallel For Each loop option and creates multiple instances of the automated activity in parallel.
To specify the number of activity instances to be created in parallel, you'll need to point to a context object (data object) in the process containing a collection. You can alternatively use an expression that produces a list. The number of items contained in the list will determine the number of automated activity instances that will be executed in parallel.
Interface
This tab enables you to choose the service interface that you want to invoke. All the service interfaces that have been imported in the current SAP NetWeaver Developer Studio project will be available for selection in the Service Interface dropdown list. You can further specify the Operation to be used in your service interface.
When importing a service interface into your project, you're required to assign a service reference to it, as discussed in Section 10.3 in regards to importing XSD and WSDL. Figure 10.49 demonstrates how the Interface tab of an automated activity can be configured.

Figure 10.49    Automated Activity: Configuration of the Interface Tab
It's important to note that, in addition to web services, you can import remote function modules from an SAP backend system.

Note
When you add a brand-new automated activity to a process, you're provided with two default service instances: SampleTimer and DefaultService.
The SampleTimer service is selected by default and comes with a predefined service group. However, you can replace it with the created or imported web service.

Input Mapping
The input mapping in an automated activity allows you to map values from the process context to the request structure of the WSDL used in the automated activity. After the web service input has been populated, the web service can be normally called, already containing values in the request message.
Output Mapping
The output mapping of an automated activity facilitates the mapping or copying of data from the service interface response structure (for a synchronous service) back to the process context. The outbound mapping step is only performed after the automated activity step has been executed and the web service call made. The execution control is then returned to the process.
Boundary Events
From the perspective of an automated activity, a boundary event catches the exception or fault thrown by the web service. To configure a boundary event, the service interface or WSDL used needs to contain fault messages.
Configuring an Automated Activity
Now that we've explored the different attributes that make up the Properties tab of an automated activity, it's time to detail the steps required to configure an automated activity:


                            Import the WSDL or service interface from the ES Repository, local file, remote location, or Service Registry. Refer to Section 10.3 for a step-by-step walkthrough. Alternatively, you can locally create the WSDL in SAP NetWeaver Developer Studio.
                        

                            Add an automated activity to the process.
                        

                            Select the automated activity, and navigate to the Properties view and Interface tab. From here, you'll need to link the automated activity to the service interface, service operation, and service reference, as shown earlier in Figure 10.49.
                        

                            Create the required mapping in Input Mapping to populate the request structure of a service interface.
                        

                            Create the required mapping in Output Mapping to copy back to the process context the response values returned by the service call, which are mostly only relevant for a synchronous service.
                        

Embedded Subprocess Activity
When modeling large, real-life processes, all steps involved in the process might not necessarily fit on one screen. To improve the reading of the process, the process can be grouped in collapsible subsections. These subsections group steps that logically belong together from a business process perspective. The embedded subprocess activities can be used to make the process more readable by grouping steps. An embedded subprocess activity is a mini process embedded in another process.
Note that a subprocess doesn't exist as a process in its own right but only exists within the context of its main (parent) process. Because of this dependency to its parent, not all SAP BPM artifacts and events are supported in an embedded subprocess.
From a technical perspective, an embedded subprocess has the following characteristics:


                        Can be used as a single combined step
                    

                        Can be visually collapsed and expanded
                    

                        Has neither lanes nor roles
                    

                        Has its own start and end events
                    

                        Has its own context objects and data and can access the context objects of its main (parent) process by default
                    

Based on its behaviors and properties, consider using an embedded subprocess in the following circumstances:


                        The process to be modeled is too large to be drawn in one sheet.
                    

                        The group of steps included in the subprocess isn't reusable for other main processes.
                    

The attributes of the properties of an embedded subprocess and their roles are described in the next sections.
From the perspective of an embedded subprocess activity, a boundary event catches the exception thrown by the subprocess. If the subprocess throws exceptions, you can add them in the boundary events and specify how to handle them.
An embedded subprocess can be added to the process from the palette in a drag-and-drop manner; see Figure 10.50 for a sample setup. Note that the embedded subprocess can be collapsed by mousing over it and selecting the Collapse icon in the top-right corner.

Figure 10.50    Sample Embedded Subprocess Activity
Referenced Subprocess Activity
Referenced subprocesses are standalone processes in their own right. Other processes can reference or call them. The following details need to be taken into consideration for a referenced subprocess:


                        A referenced subprocess is an independent process that can run on its own. It contains its own context data and objects.
                    

                        It can be called and referenced by another process.
                    

                        It has a start event and end event and has no restrictions in terms of the type of SAP BPM steps that it can use.
                    

                        By default, the subprocess can only be called by other processes that are contained in the same DC. If you need to create a reference from a process in another DC, then you'll have to create some dependencies between the different DCs and expose public parts.
                    

Based on its behaviors and properties, consider using a referenced subprocess in the following circumstances:


                        The process to be modeled is too large to be drawn in one sheet.
                    

                        The group of steps included in the subprocess can be reused by other process in the same DC.
                    

                        The subprocess can exist on its own as a main process.
                    

The attributes of the properties of a referenced subprocess and their roles are described in the next sections.
Process
This tab allows you to select the subprocess that you need to refer to. You'll need to select the Browse option from the dropdown and navigate to the desired subprocess. This requires that the subprocess already exists. If the process doesn't yet exist, you can create it by selecting the New option from the dropdown.
Looping
Looping enables the referenced subprocess activity to be repeated multiple times. It uses the Parallel For Each loop option and creates multiple instances of the subprocess in parallel.
Input Mapping
The input mapping in a referenced subprocess activity facilitates the mapping of values from the main process context to the input structure of the subprocess that you're referencing.
Output Mapping
The output mapping of a referenced subprocess facilitates the mapping of data from the subprocess structure back to the main process context. The outbound mapping step is performed after the referenced subprocess step has been executed, and the control is returned to the main process.
Boundary Events
Depending on the business scenario that you're currently modeling, you could face a situation in which the referenced subprocess throws an exception. In such a case, the thrown exception can be caught by the main process. The boundary event enables the catching and handling of an exception in a referenced subprocess.
Mapping Activity
A mapping is an SAP BPM flow object that can be used to transform or copy data from one data object to another. It can also be used to modify the value of an existing data object. Different types of simple or complex data transformations can be created between the data objects. A number of SAP BPM flow objects already include inbound and outbound mapping functionality. These inbound and outbound mappings are specific to the type of flow object being used. The mapping activity fits a more general mapping purpose.
SAP provides a number of predefined rules and functions in SAP NetWeaver Developer Studio, allowing you to easily perform your data transformation. Figure 10.51 shows a sample mapping inside a mapping activity.
In Figure 10.51, the following aspects are highlighted:


Mapping lines These lines indicates that data is copied from the element on the left side to the one on the right side. To create such mappings, simply drag the relevant node from the left side and drop it on the element on the right side. If the data types of the elements mapped don't match, then you'll see a red X on the line, indicating that you have an error. You can then mouse over the X to see more details about the error. You can also double-click on the X to be taken to the mapping editor, in which you can fix the problem.
                    

Mapping function The round icon showing the "fx" annotation indicates that there is a function applied to the transformation. You can get more details about the full mapping rule by double-clicking on the icon.
                    

The property attributes of a mapping activity and their roles are described in the next section.

Figure 10.51    Sample SAP BPM Mapping Using Predefined Functions
General
This tab in the property view contains descriptive information, such as name and documentation.
Looping
Looping enables a mapping activity to be repeated multiple times. It uses the Parallel For Each loop option and creates multiple instances of the mapping activity in parallel for each collection item.
Mapping
In this tab, you specify the action details of the mapping by linking process context objects on the left to the ones on the right. Figure 10.51 shows a sample mapping activity's configuration.
Report Activity
As the name indicates, a report activity can be used to create reports based on data present in your process. Because a process captures data about business processes, it could be useful to collect information to present to the business. This report can provide critical real-life insight into the business and therefore allow the business to react in time to adapt to the ever-changing business environment. To collect the required data for the report, you must create a reporting data source object that will gather information on the process context data on which the report should be created. A data source can be manually created or automatically generated.
To use the report activity, follow these steps:


                        Create a data object in the process. This data object needs to contain all the fields or structures that you want in your report.
                    

                        Add a report activity in your SAP BPM model by dragging it from the palette or using the speed buttons.
                    

                        Select the added report activity. From the Properties view, create a data source to be used in your report activity by selecting the New option in the dropdown menu (see Figure 10.52).
                        
Figure 10.52    Configure a Report Activity


                        A wizard will start, and you'll be asked to name the data source. Follow the wizard.
                    

                        You'll need to select the data object containing the structure that you want to have in your report (created in the first step; see Figure 10.53). Click on Finish. The report data source is automatically linked to the report activity.
                        
Figure 10.53    Creation of a Reporting Data Source


                        The fields of the data object have been added to the reporting fields list. You can add more reporting fields if you wish (Figure 10.54 1).
                    

                        Go to the input mapping of the report activity, and map the field accordingly 2.
                    

                        Optionally, you could build a UI or presentation layer to display the report data (e.g., in Visual Composer).
                    


Figure 10.54    Following Steps to Configure a Report Activity
Be aware that in addition to all the custom reporting fields shown in Figure 10.54 1, there are also some SAP-standard fields that are captured during runtime as listed in Table 10.12.




                                Field
                            

                                Data type
                            

                                Description
                            





PROCESS_ID


VARCHAR


                                The ID of the process instance
                            



OCCURRENCE_D


DATE


                                The date on which this process instance runs
                            



OCCURRENCE_T


TIME


                                The time during which this process instance runs
                            



OCCURRENCE


BIGINT


                                The time during which this process instance runs expressed in milliseconds
                            



Table 10.12    SAP Standard Fields for a Reporting Data Source
Notification Activity
It's common to need to keep some people informed about the status or execution of a business process. To facilitate this need, a notification activity can be used to send a notification via email.
The property attributes of a notification activity and their roles are described in the next sections.
General
This tab in the property view contains descriptive information, such as name and documentation.
To
This attribute specifies the person to whom the email notification needs to be sent. You can specify the notification receiver in one of two ways:


                            UME Users are users available in the SAP NetWeaver UME store. You can specify the UME principals by one of the following options:
                            

Principal You can directly select users, roles, and groups from UME. With this option, you'll need to specify static values.
                                

Expression You can use an expression to dynamically evaluate the notification recipients based on process context elements and rules and functions available within the expression editor.
                                



                            External users are available in case the intended notification recipients don't exist in SAP NetWeaver UME. You can add a static value, and you'll need to click on the Add button and specify the E-Mail ID attribute accordingly. Note that you can add multiple external users.
                        

Alternatively, you can make the recipient evaluation dynamic by using an expression. Figure 10.55 shows a sample configuration using an external user.

Figure 10.55    Notification Sample Configuration
Mail
This tab specifies the notification content. It includes the subject and text message to be sent to the notification recipients. You can create a static subject and message.
You can also make both the subject and message dynamic (with details from the process data objects) by using variables and parameterized texts as described earlier in Section 10.4.2.

Note
Even though you've configured the notification activity to send a message to designated recipients, you need to make sure that the SAP BPM mail server connectivity configuration has been correctly performed in SAP NetWeaver Administrator. Without SAP NetWeaver Administrator being configured properly, email notification will fail.

10.4.4    Gateways
SAP BPM gateways objects are used to control the flow of a process. A gateway has the ability to determine the path of the process flow based on predefined conditions you've set and modeled at design time.
The different types of gateways all have specific usages. In the next sections, we'll explore each of them and specify under which conditions they can be used.
As discussed in Chapter 9, following are the main types of gateways:


                    Abstract or undefined gateway
                

                    Exclusive choice
                

                    Event-based choice
                

                    Parallel split
                

                    Uncontrolled merge
                

                    Parallel join
                

The technical aspects and configuration details of each of these gateway types will be discussed in the next sections.
Abstract or Undefined Gateway
When designing a process and the specifics of the type of gateway aren't yet known, an abstract gateway can be temporarily used. It can be thought of as a placeholder and will need to be changed to a specific gateway type later on.
Exclusive Choice
The exclusive gateway is a choice between the different outgoing flows (called gates). Only one of the outgoing gates can be selected. The selection of the gate to be taken is facilitated by conditions that need to be supplied for each gate. The conditions are Boolean based and evaluate to true or false.
You also need to define the priority order that will be followed to evaluate the different evaluation conditions. The first gate to evaluate to true will be taken, and the others will be ignored.
You also have the flexibility to specify a default gate, which is taken in case no other gate evaluates to true. Note that the condition of the default gate isn't evaluated. Having a default gate is a good practice to avoid unnecessary exceptions in case none of the conditions evaluate to true.
The property attributes of an exclusive gateway will be explored next.
General
This tab in the property view contains descriptive information, such as name and documentation.
Condition Evaluation
Figure 10.56 shows an example of evaluation conditions for a three-gate exclusive choice.

Figure 10.56    Exclusive Gateway Sample Configuration with Three Gates
You can change the priority of the condition evaluation of each gate by selecting the condition and using the Up or Down buttons on the right side. You can also edit the condition evaluation of each gate by selecting the condition and using the Edit button on the right side.
Event-Based Choice
The event-based choice is almost the same as the exclusive gateway, but instead of using conditions, it uses events. Depending on the event received, the process will flow toward one of the subsequent gates.
The event-based choice is always followed by intermediate events, which can be message or timer events. When an event-based gateway is used, the process waits until one of the intermediate events is triggered before resuming. The event-based choice doesn't require any special settings or configuration. The only attributes it contains are descriptive, such as name and documentation.
Parallel Split
As its name suggests, the parallel split enables the parallel execution of multiple gates. It can be considered as a more complex gateway compared to the ones we've mentioned so far.
It's quite common to have processes that require multiple tasks to be executed at the same time. If the parallel gateway didn't exist, then you would need to execute the steps sequentially. It goes without saying that sequential processing can be slow. When the steps to be performed are independent from each other's processing, a parallel split is a good option to increase performance and to speed up the completion of a process.
The parallel split also works with the notion of parallel joins, in which all the outgoing flows from the split meet again and merge in a join. Another important aspect about the parallel split is that even though all outgoing gates are executed simultaneously, the processing waits (at the join) for all the gates' execution to finish before proceeding to the subsequent steps. To better illustrate the use of the parallel split, consider the driving process example depicted via the process shown in Figure 10.57. You always need to physically drive (steer the wheel and change gears) and to watch the road at the same time (in parallel). Both gates need to be completed for you to arrive at your destination.

Figure 10.57    Driving Process Representation with a Parallel Split and Parallel Join
The parallel split doesn't require any special settings or configuration. The only attributes that it contains are descriptive, such as name and documentation.

Note
You don't have to use a parallel split for modeling a parallel flow, but it's preferable because it makes the process flow more readable and less complex.

Uncontrolled Merge
The uncontrolled merge is derived from the exclusive gateway and is used as a merge for alternative sequence flows. The uncontrolled merge doesn't require any special settings or configuration. The only attributes it contains are descriptive, such as name and documentation.
Parallel Join
The parallel join is used together with a parallel split. It joins all the outgoing gates from a parallel split. We've already explored its functionality when exploring the parallel split (refer to Figure 10.57 for an example process that uses a parallel join).
A parallel join doesn't require any special settings or configuration. The only attributes that it contains are descriptive, such as name and documentation.
10.4.5    Artifacts
An artifact is used in an SAP BPM process to store process-related data and to display extra information for the process. We can distinguish two artifacts in SAP BPM: data objects and annotation. Both artifacts will be explored in the next sections.
Data Objects
The context data of a process can be stored in data objects. As the different steps of a process are performed, the data of the process can be modified and can change along the way. Data structures based on XSDs are used to represent the nature of the data to be stored in the process. These XSD structures are then assigned to data objects. In addition to the custom data types, SAP has preloaded SAP NetWeaver Developer Studio with a large number of data types (primitive, simple, and complex) to choose from. You can therefore assign any of these data types to your data object. The values stored in a data object are used to map to and from the different flow objects of a process.
To add a data object to your process, follow these steps:


                        If the data object needs to be assigned to a custom structure, then make sure that the related XSDs are imported or created in your project. Importing an XSD was described in Section 10.3.
                    

                        Drag and drop the data object artifact from the palette or by using the speed buttons from your process.
                    

                        Select the data object from the process, and navigate to the Properties view.
                    

                        In the Properties view, you can change the name of the data object (from the General tab) to something meaningful.
                    

                        In the Data Type tab, select the data type that represents the relevant data object structure.
                    

If you can't see the desired data type from the dropdown menu, then follow these steps:


                        Select Browse from the dropdown menu (Figure 10.58 1).
                    

                        A new screen will appear. Here, you can type the name of the data type to select it 2.
                    


Figure 10.58    Configuring the Data Type for a Data Object

Note
To store data of a particular structure in the process, you need to first import or create all required XSDs in the SAP BPM process.
Not all data types are supported by data objects. Refer to SAP Note 1266539 for the limitations that apply.

Note that the SAP BPM context data can also be stored in SAP CAF or an EJB, but data objects are preferable because they are visible and simplify the readability of a process.
Annotation
An annotation artifact makes it possible to add descriptive notes to the different flow objects of the process, but they don't change the behavior of your process. The notes can be very useful for documentation purposes and make it easier to read and understand a process model. Figure 10.59 depicts a process that contains an annotation to explain what the Drive activity entails.

Figure 10.59    A Process Using an Annotation to Give More Information about a Flow Object









10.5    Build and Deploy Your Process
All the steps and information provided so far in the previous sections concern the design-time aspects of SAP BPM. After successfully modeling and configuring your process, it's now time to compile the process and make it available in the SAP NetWeaver server by deploying it. The steps required for both actions will be explored next.
10.5.1    Steps for Building a Process
Building a process is the same as compiling the project in Java terminology. Building a process involves compiling the DC that contains the SAP BPM project.
To build a DC, follow these steps:


                    Ensure that the BPMN representation of your process is finished and that all the contained flow objects are correctly configured. Furthermore, you should not have unresolved errors in the Problems view. Unresolved errors on the process can also be identified by red Xs in the process editor (Figure 10.60).
                    
Figure 10.60    Example of a Process with Errors


                    Right-click on the DC to be compiled, and choose Development Component and then Build from the dropdown menu (see Figure 10.61).
                

                    The compiling process starts and might take a few moments. If errors are discovered in the process, then the build will fail, and errors will be displayed in the Problems view.
                


Figure 10.61    Steps Involved in Building an SAP BPM Process
10.5.2    Steps for Deploying a Process
After a successful build, we can proceed to deploy. The deployment process moves and installs the DC and process in the SAP NetWeaver server. Until now, the process has existed only on the local machine of the developer in SAP NetWeaver Developer Studio.
To deploy a DC, follow these steps:


                    Right-click on the DC to be deployed, and choose Development Component and then Deploy from the dropdown menu. Be aware that it might take a few seconds to deploy.
                

                    You'll get a message back with information about whether the deployment was successful or not. If the deployment failed, then you can see the details about the failure in the Deployment view console.
                

                    You can further verify that the deployed process was activated in the server via SAP NetWeaver Administrator. Go to http://<hostname>:<port>/nwa, and log in.
                

                    Navigate to Configuration • Processes and Tasks • Process Repository. A list of deployed processes and their corresponding DCs are now available. You can now see if the deployed DC is available in the list.
                

Now that the process has been deployed, it's ready to accept a call or be started. If the process in question contains automated activities, then extra configurations (called service-oriented architecture [SOA] configuration) will need to be performed in SAP NetWeaver Administrator. See Chapter 11 for details about how to perform SOA configurations, test your process, and monitor it.









10.6    Advanced Mapping
Data mapping takes care of transforming and modifying the process context data for each flow step. Some flow objects are equipped with inbound and outbound mappings, which enable the process context data to be mapped to the activity and the event's input data. In addition, the activity and event's output data can be mapped and copied back to the process context. This section will explore some advanced functionalities of mapping techniques.
10.6.1    Mappings
When working with a mapping, there are always source (on the left side) and target (on the right side) structures. To create the mapping, the appropriate data object needs to be dragged from the left and dropped on the corresponding data object on the right.
As Figure 10.62 shows, the lines between the different items indicate that there is a mapping between them. The value of the element on the left side is copied to the element on the right side. You can also modify the data before assigning it to the target by using rules and functions.

Figure 10.62    Mapping Data Objects in the Mapping Activity
Figure 10.62 also shows an Assignment menu on the right side of the screen. From this menu, you can pick the desired type of assignment that you want to use for a particular node element.
SAP provides a number of predefined rules and functions to cater to different commonly used transformations. These functions are categorized under different function groups. Table 10.13 lists the main categories and explains what they are used for.




                            Category Name
                        

                            Description
                        





Boolean


                            This category contains functions to support the different operations that relate to Boolean values, such as and, or, not, and so on.
                        



Durations, Dates and Times


                            This category is a grouping of functions to manipulate dates, times, and durations. As an illustration, you can retrieve the current date and time with the function current-dateTime().
                        



Generic


                            This category contains node-related functions. For example, get(anyType[1..*] list, long index) retrieves an item at a particular position (indicated by the index parameter) from a collection.
                        



Numeric


                            This category groups functions that relate to the manipulation of numbers, such as adding, subtracting, dividing, and many more. It also includes a number of functions to cast the different data types. For example, double (integer value) will convert a given integer to a double.
                        



Principal


                            This category contains functions to retrieve different principals from the UME. This includes users, roles, and groups.
                        



String


                            This category contains functions to support string-based operations. For example, concat(string head, string tail) will concatenate two string values into one string.
                        



sap.com/tc/bpem/content/predefs/types


                            As it stands, this category group only contains the function remove-timeZone. This function strips the timezone out of a given datetime value.
                        



Table 10.13    Categories of the Default Rules and Functions Provided with SAP BPM
Figure 10.63 shows some of the rules and functions provided with SAP BPM. Each function grouping can be expanded to see the different included functions. You can mouse over each one of these functions to see a description of what the function does. You can also see the signature of the function, specifying the number of input parameters and their data types. You can further filter any of the functions by typing your filtering keyword(s) into the Enter filter text box at the top of the screen.

Figure 10.63    Default Rules and Functions Delivered with SAP BPM
10.6.2    Options in Mapping Assignment
When the nodes of the data objects have an unbounded cardinality (0..n or 1..n), you can use different types of mapping assignments.
Depending on your business requirements, you might need to set, merge, or append the new data:


Set This type of assignment works like the equal operation in mathematics. It replaces the value of the target with the value of the source node or element. The data is basically overwritten. This is also the default assignment type.
                

Append This type of assignment adds or appends the source values to an existing target collection. The values are then appended to the last position (last item) of the collection.
                

Merge This type of assignment merges the data of the source node to the data in the target node. At the end, the target structure will include a new collection containing the data of the source and target node.
                

10.6.3    Automatic Mapping
With SAP BPM, there is a concept known as automapping, which tries to automatically create the appropriate mapping between source and target nodes or elements. This mapping automation feature dramatically reduces the time needed to transform large structures. The algorithm used for suggesting the mapping is referred to as a matcher.
To specify a matcher while mapping two nodes, follow these steps:


                    Select the node from the left side that needs to be mapped to the right side.
                

                    Right-click, and drag and drop to the target element on the left side.
                

                    You'll see a pop-up with the options Create Mapping or Execute Default Matcher. Choose Execute Default Matcher, as shown in Figure 10.64.
                


Figure 10.64    Example of Enforcing the Execution of a Matcher
SAP BPM provides two automapping options: simple and advanced. Both will be explored next.
Simple Cases or Name-Based Automapping
The simple automapping automatically suggests a mapping between source and target elements with identical (matching) names.
Advanced Automapping
In more complex situations, a mapping is automatically created between the source and target elements using a predefined algorithm. This algorithm takes more into account than just matching names. It also creates the mapping suggestion based on the result of matching the data type, path, leaf, and parent elements of the element in question.
You can switch between using the simple and advanced automapping as the default approach from SAP NetWeaver Developer Studio. To do so, follow these steps:


                        After launching SAP NetWeaver Developer Studio, select Window • Preferences.
                    

                        On the left side, select Data Mapping.
                    

                        Select the radio box of the automapping option that you prefer (see Figure 10.65 1).
                        
Figure 10.65    Changing the Default Automapping Matcher and Tuning the Algorithm of the Advanced Automapping


You can further adjust the settings of the algorithm used for the advanced automapping to better fit your needs. To do so, follow these steps:


                        From SAP NetWeaver Developer Studio, select Window • Preferences


                        On the left side, select and expand Data Mapping.
                    

                        Select Advanced Automapping.
                    

                        Deselect or select the matcher to suit your needs (see Figure 10.65 1).
                    

You can further adjust the behavior of the advanced matcher algorithm by using the checkbox options 2.
10.6.4    Custom Functions
You might encounter situations in which the standard rules and functions don't provide you with the functionality that you need to perform your mapping. You can consider such cases as complex mapping.
SAP BPM provides the flexibility to create your own functions to extend the existing function set. These custom functions can then be added in the function repository and reused by other SAP NetWeaver Developer Studio projects and SAP BPM processes. You can create custom functions as expressions, mappings, or EJBs. We'll now explore for which situation or scenario each type of function is suited. Note that each function has a name, return type, and optional input parameters.
Expression and Mapping Function
You can use this type of function to build complex transformation rules using expressions or mappings.
Enterprise Java Bean Function
You can use this type of function to build a complex transformation function using an EJB. This approach involves writing the transformation in Java. You'll need to deploy the Java code in the SAP NetWeaver server and define a reference using a Java Naming Directory Interface (JNDI) name to be used for looking up the EJB.
To create a new custom function, follow these steps:


                        Under your project, right-click on the Function node (Figure 10.66 1).
                    

                        In the resulting pop-up, select the desired type of function.
                    

                        Specify the name of the function.
                    

                        Select the data type of the parameter to be returned. This attribute is called the return type.
                    

                        Add the input parameters and specify their data types (Figure 10.66  2).
                        
Figure 10.66    Steps Involved in Creating the Custom Functions in an SAP BPM Project


                        Enter the expression or mapping, depending on the type of function that you chose. In Figure 10.67, an example expression function is shown based on the expression function started in Figure 10.66.
                    

                        The newly created function is now present and visible in the list of Rules and Functions.
                    

The CustomConcatenate sample expression function in Figure 10.67 is created to concatenate two input values and to separate them with a dash (-) as a separator.
Creating an EJB function requires a few more steps and will be covered in Chapter 11.

Figure 10.67    Expression Used for the Custom Expression Function

Note
When creating a custom function, you can use generic parameters for input or return. This approach is useful and helps to create a flexible function in terms of the data types that might be used as parameters.
The approach lets you specify a parameter with a generic data type during the design time and only discover the specific data type of the parameter during runtime. To achieve this, you can use the data type anyType from the http://www.w3.org/2001/XMLSchema namespace.










10.7    Implementing Error Handling
When modeling a process, it's crucial to think about how to deal with exceptional situations in your business process. The exceptions need to be caught and handled.
There are a couple of options within SAP BPM to handle exceptions:


Error end event An error end event can be used to model an exception that occurs in a process. Imagine a scenario in which you want the process to explicitly throw an exception if a bad value is entered in a human task. To intentionally throw such an exception, an error end event can be used. Be aware that you can select the Terminating checkbox to turn the error end event into a termination event (see next bullet point to learn about a termination event). The error end event requires that you specify the error event to be triggered. It's therefore capable of triggering another process or an independent interface responsible for handling the exception.
            

Termination event This event is the same as the error end event, except that in addition to throwing an exception, the process will be terminated.
            

Boundary event There are more specialized exception events that can be attached to different activities, such as human activities, automated activities, and subprocesses. The boundary event catches an exception that occurred in the activity to which it's attached. These exceptions can be handled by modeling outgoing flows from the boundary event. We already explored specific boundary events when discussing the different activities in Section 10.4.3.
            

Figure 10.68 shows an example process using a boundary event and an error end event to handle an exception that occurred in a human task. It's important to be aware that the mechanisms listed previously are mostly used to catch exceptions and errors. When it comes to handling the errors, you have the freedom to model the error handling in whichever way suits your business requirements best. Some possible error handling solutions can include the following:


                Use a notification activity to notify the appropriate people within the organization who are capable of taking corrective actions.
                
Figure 10.68    Exception Handling in a Process Using a Boundary Event and an Error End Event


                Have a human activity assign a task for the appropriate person to take corrective action.
            

                Call a service (an automated activity) that will handle the exception.
            

                Implement a retry mechanism to repeat the failed step. However, it's important to be careful with this approach! Don't retry steps that might produce the same exception, which could create an infinite loop and a deadlock situation. If you opt for a retry mechanism, make sure to set a maximum number of retry attempts.
            

When an exception occurs at a process level, the process will be stopped and its status will change to suspended. Someone from the support organization or an administrator will need to investigate the reasons that the process ended in an exception and take appropriate corrective action.









10.8    Combining SAP BPM and the AEX
When developing an SAP BPM process, it's important to use SAP BPM for what it was made for. Whenever the process uses an automated activity to call a service, it's a good idea to consider making the service call the AEX. By doing so, we're basically letting SAP BPM focus on human- and system-centric orchestration and letting the AEX focus on what it does best—play the role of an ESB.
This approach involves wrapping all the service calls to be made by SAP BPM via AEX. The communication between SAP BPM and AEX can be achieved using plain Simple Object Access Protocol (SOAP) or the XI 3.0 message protocol. For communication with the SAP backend, it's also possible to use an RFC connection.
As we've discussed in the past sections, an automated activity is used to call services. You can specify the type of service call and the message protocol via the service reference, as shown in Figure 10.69.
The possible values to choose from in the Type dropdown are as follows:


RFCRepresents the RFC protocol. To be used when directly connecting SAP BPM to an SAP backend—bypassing the AEX.
            

WSRepresents a web service or SOAP message protocol.
            

XIRepresents the XI 3.0 message protocol.
                
Figure 10.69    Choice of Type or Message Protocol to be Used When Calling a Service Interface from SAP BPM


After selecting the message protocol, further configurations will be needed in SAP NetWeaver Administrator after the SAP BPM processes have been deployed in the SAP NetWeaver server. These configurations will be explored in Chapter 11. When dealing with an asynchronous message, we recommend using the XI 3.0 message protocol, which is the preferred way to integrate the AEX and SAP BPM runtime.
To be more specific, SAP BPM can interact with the AEX when dealing with the following flow objects:


Start message AEX can send a message to SAP BPM that acts as a trigger for the SAP BPM process. It requires an inbound service interface.
            

Automated activity SAP BPM calls a service exposed via AEX. It requires an outbound service interface to be used on the SAP BPM side.
            

Intermediary event A message is sent to the SAP BPM layer while passing through the AEX. It requires an inbound service interface to be imported on the SAP BPM side.
            

In the configuration of the Integrated Configurations (ICOs) or integrated flows (iFlows) in the AEX, you'll need to represent SAP BPM by using a communication component (a business component). Another way that SAP BPM can take advantage of the AEX is by leveraging and reusing an operation mapping developed in the ES Repository. In the next sections, we'll explore the configuration steps required to exchange messages between SAP BPM and the AEX.
10.8.1    Message from SAP BPM to the AEX
When calling a web service or sending a message from SAP BPM to the AEX, follow these steps:


                    Import the outbound service interface used in SAP BPM's automatic activity from the ES Repository.
                

                    Assign the service interface to the automated activity in SAP BPM. Then, assign a service reference; it's important to be aware that the default type of the message protocol is automatically set to WS. If you want to use the XI 3.0 message protocol, then you'll need to change the Type field to XI (Figure 10.69).
                

                    When configuring ICOs or iFlows, use a business component to represent the SAP BPM process.
                

                    Create a communication sender channel that receives a message from SAP BPM. The sender communication channel can be configured by using the details specified in Table 10.14.
                

                    Ensure that the outbound service interface used in the ICOs/iFlows is the same as the one used in the automated activity in SAP BPM.
                





                            Attribute Name
                        

                            Attribute Values
                        





Adapter type


SOAP




Direction


Sender




Message protocol


XI 3.0




Table 10.14    Configuration Details of a Sender Communication Channel Receiving a Message from SAP BPM

Note
Using the XI 3.0 message protocol enables message reliability in communications between SAP BPM and the AEX. This is especially important for asynchronous calls to and from SAP BPM.

10.8.2    Message from the AEX to SAP BPM
When sending a message from the AEX to SAP BPM, follow these steps:


                    Model and configure the SAP BPM process to fit your requirements.
                

                    Import the inbound service interface to be used in SAP BPM (in the start or intermediary event) from the ES Repository.
                

                    When configuring the ICOs or iFlows, use a business component to represent the SAP BPM process.
                

                    Create a communication receiver channel to send the message to SAP BPM. The receiver communication channel can be configured using the details specified in Table 10.15.
                    



                                    Attribute Name
                                

                                    Attribute Values
                                





Adapter type


SOAP




Direction


Receiver




Transport protocol


HTTP




Message protocol


XI 3.0




Target URL


http://<hostname>:<port>/MessagingSystem/receive/JPR/XI




Table 10.15    Configuration Details of a Receiver Communication Channel Sending a Message to SAP BPM


                    Ensure that the inbound service interface used has the Stateless (XI30-compatible) interface pattern. This same inbound service interface can be used in the SAP BPM process as a trigger for a start event or intermediate event (depending on your situation).
                


Note
The following limitations apply when dealing with XI 3.0 as the message protocol between the AEX and SAP BPM:


                        The WSDL or service interface used must be imported from the ES Repository.
                    

                        The service interfaces in the ES Repository (to be used for communication between the AEX and SAP BPM) must use the XI 3.0 compatible pattern.
                    

                        Messages with attachments and acknowledgements aren't supported by SAP BPM.
                    


10.8.3    Leverage an ES Repository Mapping in SAP BPM
You can leverage the operation mappings created in the ES Repository. You typically need to import the operation mapping into the SAP BPM project. An operation mapping imported from the ES Repository is then treated as a stateless web service with the mapping's input acting as a request of the web service and its output acting as a response of the web service. This is commonly called mapping as a service (MaaS).
The MaaS concept enables you to use a fully featured mapping environment that SAP PI provides to build complex transformations and reuse them in SAP BPM, irrespective of whether the underlying mapping is a message mapping, Java, or XSLT. To reuse an existing SAP PI mapping in SAP BPM, follow these steps:


                    Place an automated activity step in the BPMN diagram of your business process.
                

                    Import the desired operation mapping from the ES Repository. In your SAP BPM project, right-click on Operation Mappings (PI), and select Import Operation Mapping.
                

                    A login pop-up appears so you can access the ES Repository.
                

                    After a successful logon, select the desired operation mapping from the repository (Figure 10.70 1).
                    
Figure 10.70    Importing an Operation Mapping in the SAP BPM Process


                    Click on the Finish button.
                

                    The operation mapping is now present in the SAP BPM project, under Operation Mappings (PI) and WSDL Files 2.
                

                    Go back to the SAP BPM automated activity, and under the Property view and Interface tab, select the imported service interface and operation.
                

                    From the Service Reference dropdown, select the New dropdown option to create a service group (Figure 10.71).
                    
Figure 10.71    Create a New Service Reference for a Service Called from an Automated Activity


                    In the new pop-up, fill in the details, and select the Local Provider System checkbox (Figure 10.72).
                    
Figure 10.72    Sample Details for Creating a New Service Reference


                    Click on the Finish button. The result is a fully configured automated activity that calls and reuses an operation mapping. See the finished result in Figure 10.73.
                


Figure 10.73    Configuring the Imported Service Interface Properties in the Interface Tab
In most cases, the operation mapping to be used should be based on the asynchronous service interfaces. In addition, if you've imported an operation mapping containing a request and response message mapping, then only the request message mapping will be taken into account.

Note
To successfully import the operation mapping from the ES Repository, you need to configure the following settings in SAP NetWeaver Developer Studio:


                        Enterprise Service Browser (Section 10.1.2).
                    

                        SAP PI tools configuration (Chapter 6, Section 6.1.2).
                    











10.9    Exercise: Creating an SAP Business Process Management Process
This section contains an exercise to help you apply the knowledge of SAP Business Process Management (SAP BPM) you've gained in this chapter.
10.9.1    Exercise Description
Reader's Paradise uses SAP PO to send orders to its main supplier, Book Fountain. As is customary in such a process, Book Fountain needs to send an order acknowledgment back to Reader's Paradise. You've been asked to build an interface to receive the order acknowledgement (on the Reader's Paradise side) and send it to your company's backend application. Building such an interface in SAP PO is a piece of cake.
However, you've been informed that the supplier uses a legacy system and can only send a separate acknowledgement for each of the items included in the original order. For example, if the original order that you sent to Book Fountain included 500 items, then you would receive 500 acknowledgements back (as separate messages).
Needless to say, this situation will create a high load and decrease performance on the Reader's Paradise backend application. The specialist on the application side has asked you (as the integration specialist) to collect all of these acknowledgement messages and consolidate them into one single acknowledgement message. This consolidated acknowledgement message then needs to be sent as a collection of acknowledgement messages to the backend application.

Note
In this practical exercise, SAP BPM is purely used to support a technical and system-centric process that doesn't involve a human task.

10.9.2    Exercise Solution Approach
Based on the exercise description, you need to implement a process that supports a collection pattern. To resolve this challenge, you need to perform the following high-level steps:


                    Create a DC that will hold the SAP BPM process.
                

                    Model the SAP BPM process.
                

                    Configure the process steps where relevant.
                

                    Build the process and deploy it to the SAP PO server.
                

                    Perform the required SOA configuration on the deployed SAP BPM process.
                

While building the collect pattern, we'll make the following extra assumptions:


                    Each process instance will be able to collect up to 10 acknowledgement messages.
                

                    Each process instance should only run for a maximum of five minutes.
                

10.9.3    Exercise Step-by-Step Solution
We'll now explore each of the high-level steps listed in the previous section in more detail.
Prerequisite SAP NetWeaver Developer Studio Setup
The first action as part of this process is to make sure that SAP NetWeaver Developer Studio is configured and set up. This is a two-step configuration that covers the SAP NetWeaver AS Java and the ES Repository, as we explain in the next sections.
SAP NetWeaver AS Java
This configuration helps to point your SAP NetWeaver Developer Studio development client to the SAP PO server where the modeled and developed SAP BPM process will need to be deployed. Follow these steps to configure SAP NetWeaver Developer Studio:


                        After launching SAP NetWeaver Developer Studio, choose Window • Preferences.
                    

                        From the pop-up screen, select SAP AS Java on the left side, and then click Add on the right side.
                    

                        In the new window that appears, provide the Instance Host Name and Instance Number of the SAP PO server (see Figure 10.74).
                        
Figure 10.74    Configuration of SAP NetWeaver AS Java in SAP NetWeaver Developer Studio


                        Click on OK. Your newly added SAP PO server will be added in the SAP AS Java list. Be aware that you can add multiple SAP PO servers in this list. You can also set the server that you're currently using as the default system.
                    

After finishing these steps, you're ready to configure a connection to the ES Repository.
Enterprise Service Repository Connection
This is an optional setting and is only necessary when the SAP BPM process to be developed requires objects from the ES Repository to be imported in SAP NetWeaver Developer Studio. Follow these steps to set up the connection to the ES Repository:


                        From the top menu of SAP NetWeaver Developer Studio, choose the Window • Preferences.
                    

                        Navigate to the Web Services section (on the left side of the screen), and expand the node (see Figure 10.75).
                        
Figure 10.75    Connection Settings for the ES Repository


                        Choose Enterprise Service Browser.
                    

                        Add your server details as shown in the figure.
                    

Create a Service Interface in the Enterprise Services Repository
The SAP BPM process that you're about to build requires you to use an order acknowledgement message WSDL. Therefore, make sure that the service interface of this message structure is available in the ES Repository of your SAP PO system. Create all relevant structures (data types and message types) in the ES Repository under the SC of your choice.

Note
If you've done the previous exercises, then you can use the SWC_BOOKFOUNTAIN SC.

For simplicity's sake, you'll use two very minimalistic message structures. The structure to be created for the SAP BPM inbound message should contain the fields presented in Table 10.16. Note that this structure can only hold one item because Book Fountain is only able to send one item per acknowledgment message.




                                Field Name
                            

                                Type
                            

                                Occurrence
                            





AcknowledgementId


String


1




OrderNumber


String


1




LineItem


LineItemType


1




ItemID


String


1




ItemName


String


0...1




Table 10.16    Minimalistic Order Acknowledgement Message Structure for a Single Item
The data type that goes with the structure presented should be named DT_OrderAck, and the message type should be MT_OrderAck. You need to create and name an inbound service interface: SIIA_OrderAcknowledgement.
You also need another structure to hold the aggregated order acknowledgements. This collection of acknowledgements will then be sent from SAP BPM to the backend application. The structure to hold this collection is presented in Table 10.17.




                                Field name
                            

                                Type
                            

                                Occurrence
                            





OrderNumber


String


1




LineItem


LineItemType


1...n




ItemID


String


1




ItemName


String


0...1




Table 10.17    Aggregated Order Acknowledgment Message Structure
The data type that goes with the structure presented should be named DT_OrderConfirmation, and the message type should be MT_OrderConfirmation. An outbound service interface also needs to be created and named SIOA_OrderConfirmation. Note that the data type DT_OrderConfirmation contains multiple items, as opposed to DT_OrderAck, which only contains one item.
We're not going to spend time here explaining how to create a new service interface in the ES Repository; if you need a refresher, refer to Chapter 4, Section 4.1 through Section 4.3. Furthermore, you'll also need to create the interface either as an ICO or iFlow.
Create a Development Component

Note
For simplicity's sake, we're developing this exercise via the local development configuration, so there is no development infrastructure (SAP NetWeaver development infrastructure).

To create a new DC for the process, follow these steps:


                        Launch SAP NetWeaver Developer Studio, and switch to the Development Infrastructure perspective.
                    

                        Extend the localDevelopment development configuration and the MyComponent SC.
                    

                        Right-click on the MyComponent SC, and choose the New option from the context menu.
                    

                        From the resulting submenu, select the Development Component option (see Figure 10.76).
                        
Figure 10.76    Create a New DC in Your Software Component


                        On the next screen, specify the type of DC to be created as Process Composer (see Figure 10.77).
                        
Figure 10.77    Selecting the Process Composer DC Type


                        After selecting the desired DC type, click on the Next button to proceed with the wizard.
                    

                        Provide the details of the DC to be created. This includes the name and a vendor. We suggest the Name "dc_collectack" and the Vendor "readersparadise.com" (see Figure 10.78).
                        
Figure 10.78    Last Step in the Creation of a New DC


                        Click on the Finish button to complete the DC.
                    

                        You'll see a pop-up screen asking if SAP NetWeaver Developer Studio should switch to the Process Development perspective. Click Yes.
                    

You're redirected to the Process Development perspective. This perspective contains all of the views that allow you to model your BPMN object and develop your process.
Creating and Modeling Your Business Process Model Notation
Now that all of the required DCs for your development have been created, it's time to start the SAP BPM development activities. The first step is to create a process from which you'll draw your BPMN model. To create an SAP BPM process, follow these steps:


                        On the left side of the perspective, right-click on the Process category and select New Process.
                    

                        In the pop-up screen, specify a few attributes as listed in Table 10.18.
                        


Attribute Name
Description




Process Name
OrderAckCollection


Documentation
Process implementing the collect pattern for order acknowledgements


Orientation
Left to Right


New Pool
Checkbox should be selected


Pool Name
OrderAckCollectionPool


Lanes
BookFountain, BPM, SAPECC



Table 10.18    Attributes Required to Create an SAP BPM Process


                        After filling in all the attribute details, click on the Finish button.
                    

An empty process is created, from which you can now model the desired BPMN. By default, the empty process only contains a start event, an end event, and a connection line between them. This default process is shown in Figure 10.79. Follow these steps to model the process:


                        Delete the connection line between the start and end events.
                    

                        Model the BPMN of the acknowledgement order collection by placing the different flow objects into the diagram.
                    


Figure 10.79    Empty Generated Process
The final product of the modeling looks like Figure 10.80.

Figure 10.80    BPMN of the Process of Collecting Acknowledgements
The BPMN model just created is described via the steps presented in Table 10.19. The Step # column in the table references the numbers shown in Figure 10.80.




                                Step #
                            

                                Step Type
                            

                                Description
                            





1


                                Start Event
                            

                                This step will start the process by receiving an order acknowledgement message from Book Fountain.
                                As soon as a new order acknowledgement message is received in the SAP BPM engine, a check is performed to verify that there are no other running process instances with the same order number (used as the correlation ID). If such a correlation doesn't exist, then a new process instance is started.
                                If a correlation ID does exist, then the message will join an existing process instance. After a process has started, the process moves to step 2.
                            



2


                                Event-Based Choice
                            

                                This step branches to the left or right depending on which event first occurs. In this case, you have an intermediary message on one side (step 3) and an intermediate timer on the other (step 6).
                            



3


                                Intermediary Message
                            

                                After a new instance of the SAP BPM process (with a particular correlation ID) has been created, all new intermediary order acknowledgement messages arriving will be processed by this step. Then, the process controls move to step 4.
                                Furthermore, the received order acknowledgement needs to be appended to the process context.
                            



4


                                Mapping Activity
                            

                                This mapping increases the counter upon the arrival of a new intermediary message event. After that, the process controls move to step 5.
                            



5


                                Exclusive Choice
                            

                                This gateway evaluates whether the process needs to look back to step 2 and collect more acknowledgements. This is true if you've collected fewer than 10 acknowledgements so far.
                                If you've already obtained the 10 required order acknowledgements, then the process flow will proceed to step 7.
                            



6


                                Intermediate Timer
                            

                                This step is meant to interrupt the process after it has been running for more than 10 minutes, after which the process flow moves to step 7.
                            



7


                                Automated Activity
                            

                                Calls the service to send the collected set of acknowledgements to the backend application that will store the collected acknowledgments.
                            



8


                                End
                            

                                This step ends the process.
                            



Table 10.19    Configuring the Flow Object Properties
Now that the BPMN has been modeled, it's time to configure every one of the flow objects that are represented in it. Configuring these objects gives more context and meaning to the model.
One of the first steps to be performed is to import the required WSDLs and create the necessary data objects to hold process context data. These configurations are necessary to turn the process model into a runnable process.
The next section will show and describe the configuration setting of each step in order.
Import the Necessary Service Interfaces or WSDL
One of the first things to do is to import an existing structure from the ES Repository. In this case, you'll import two service interfaces: one to hold an individual order acknowledgement and one to hold the collection of acknowledgements.
To import the service interfaces from the ES Repository, follow these steps:


                        Expand your project from SAP NetWeaver Developer Studio's Project Explorer view until you reach the Service Interface folder node.
                    

                        Using the context menu on the Service Interface folder node, select the option Import WSDL.
                    

                        A wizard opens in which you need to select the Enterprise Service Repository radio button as the source for the WSDL (Figure 10.81).
                    

                        Click on Next to proceed with the wizard.
                        
Figure 10.81    Importing the WSDL from the ES Repository


                        Navigate to the appropriate SC and namespace where the order acknowledgement service interface can be found, and select it. In this case, the service interface to be imported is called SIIA_OrderAcknowledgement (see Figure 10.82).
                        
Figure 10.82    Choosing the Appropriate Service Interface from the ES Repository


                        Click on Next, and specify a name for your service group; it's important to provide a meaningful name.
                    

                        Click on the Finish button.
                    

As a result, the imported WSDL and all its related XSDs are now available in your project under the Data Types and Services Interfaces folders.
Repeat the preceding steps to import the outbound service interface, SIOA_OrderConfirmations. Now, it's time to create the new data objects and link them to the imported data objects.
Create Data Objects
To support the process, you need to create and add three data objects, according to Table 10.20.




                                Name
                            

                                Data Types
                            





DO_OrderAck



DT_OrderAck
urn:readersparadise.com:scm:procurement:supplier





DO_OrderConfirmationCollection



DT_OrderConfirmation
urn:readersparadise.com:scm:procurement:supplier





DO_CorrelationID



String
http://www.w3.org/2001/XMLSchema





DO_Counter



int
http://www.w3.org/2001/XMLSchema





Table 10.20    Data Objects to be Created and Their Corresponding Data Types
Start by creating the first data object (DO_OrderAck), as described in Table 10.20. This data object needs to hold the content of a message arriving and starting the process. Follow these steps:


                        Drag and drop an artifact of type data object onto the SAP BPM diagram.
                    

                        Select the newly added data object from the diagram, and the Properties view will be displayed at the bottom of the screen.
                    

                        On the general tab, rename the data object to "DO_OrderAck".
                    

                        Click on the Data Type tab. Use the dropdown field to select the Browse option (see Figure 10.83).
                        
Figure 10.83    Assigning a Data Type for the Data Object


                        You'll see a pop-up allowing you to select the desired data type. In this case, select the data type DT_OrderAck because that is the underlying data type behind the imported service interface SIIA_OrderAcknowledgement.
                    

Repeat all of the preceding steps to create the three additional data objects listed in Table 10.20—namely, DO_OrderConfirmationCollection, DO_CorrelationID, and DO_Counter.
DO_OrderConfirmationCollection will be used to collect and aggregate all received acknowledgments, DO_CorrelationID is intended to keep a reference to the OrderNumber field and to be used as a correlation ID to match all other incoming acknowledgement messages, and DO_Counter will be used to keep count of the number of message acknowledgements received.
In the next sections, we'll explore each of the steps included in the BPMN model that was presented in Figure 10.80.
Step 1: Start Event
To configure the start event, follow these steps:


                        Select the Start event from the BPMN diagram.
                    

                        The Properties view is then displayed in the bottom of the screen. From the Properties view, choose the Event Trigger tab.
                    

                        Make sure that the trigger type Message is selected.
                    

                        Open the dropdown menu of the Trigger field, and select the New option (see Figure 10.84).
                        
Figure 10.84    Creating a New Message Trigger for the Start Event


                        A new wizard starts in which you must specify the name of the message trigger (use OrderAcknowledgementMsg). Leave all other fields in this screen set to the proposed default values. Click on the Next button to proceed with the wizard.
                    

                        On the next screen, use the Service field dropdown to select the service interface that you previously imported from the ES Repository. In this case, the service interface is called SIIA_OrderAcknowledgement, but this could be different, depending on how you named your service interface (see Figure 10.85).
                    

                        Click on the Finish button to complete the creation of the message trigger.
                        
Figure 10.85    Details of the Message Trigger to be Used for the Start Event


Next, you need to configure the output mapping of the start event. In the output napping, you also want to transform the initial (acknowledgement) message that started the process to the DO_OrderAck data object and to initialize all other process context.
Follow these steps:


                        From the Properties view, select the Output Mapping tab.
                    

Figure 10.86 shows all of the process context data objects (on the right side) mapped using the output of the start event (on the left side). The details of the mapping to be applied are described in Table 10.21.
                    


Figure 10.86    Mapping the Process Context Data




                                Target Field
                            

                                Mapping Rule
                            





DO_Counter


                                Initialize the field with the constant 1.
                            



DO_CorrelationID


                                Needs to be mapped from the OrderNumber field of the acknowledgment message. Therefore, use the expression MT_OrderAck/OrderNumber.
                            



DO_OrderAck


                                Needs to be mapped from the source message type MT_OrderAck.
                            



DO_OrderConfirmationCollection


                                Needs to be initialized from the source message type MT_OrderAck.
                            



Table 10.21    Mapping Rules between the Output of the Start Event and the Process Context
You're now done with the start event and can proceed to configure other flow objects.
Step 2: Event-Based Choice
This step doesn't require any configuration. SAP BPM knows whether to branch to the left or right side of the process based on which event first occurs. The two possible events include an intermediary message (step 3) or an intermediary message timer (step 6).
Step 3: Intermediary Message
This step needs to be configured to intercept all order acknowledgement messages that match a particular correlation ID. Given that you've already created a trigger for the acknowledgment message, that trigger can be reused here.
To configure this step, follow these steps:


                        Select the intermediary message from the BPMN diagram.
                    

                        From the Properties view that opens in the bottom of the screen, choose the Event Trigger tab.
                    

                        Make sure that the trigger type Message is selected. Select the OrderAcknowledgementMsg option from the Trigger dropdown field. This is the same message trigger used for the start event.
                    

                        From the Properties view, select the Output Mapping tab. On this tab, you need to append the newly received order acknowledgement to the existing aggregated data object (DO_OrderConfirmationCollection; see Figure 10.87).
                    

Note in Figure 10.87 that only the LineItem part of the acknowledgment message is appended to the target structure. This is because you're not interested in the rest of the message structure. In addition, the assignment of type Append needs to be used to ensure that the new item is appended instead of overwriting the existing target structure.

Figure 10.87    Append Newly Received Acknowledgment to Existing One
Furthermore, you need to configure the correlation of the intermediary message. In the correlation, you need to specify the condition under which the received order acknowledgement needs to be assigned to a running process instance. To configure the correlation, choose the Correlation Condition tab from the Properties view. You then need to use the following expression:
string-equal(MT_OrderAck/OrderNumber,DO_CorrelationID)
This expression will compare the order number on the incoming acknowledgement to the existing correlation ID of the process instance. If the expression returns a Boolean true, then it's considered a match.
Note that the preceding expression might look slightly different than yours, depending on the name of your data type.
Step 4: Mapping Activity
In this step (the mapping step), the counter data object needs to be increased. This will ensure that DO_Counter is always in line with the number of acknowledgement messages collected by the process instance.
To configure the mapping activity, start by selecting the mapping activity from the BPMN diagram. Then, select the Mapping tab under the Properties view. From this tab, you'll need to use the DO_Counter + 1 expression to increment the DO_Counter data object. The end result is shown in Figure 10.88.

Figure 10.88    Increasing the DO_Counter
After the counter has been incremented, the process control moves to the exclusive choice.
Step 5: Exclusive Choice
From this gateway, the process will decide to take one of the following actions:


                        Return to the event-based choice (step 2) and wait for more acknowledgements to arrive. This route needs to be followed if the total number of collected acknowledgements is fewer than 10 or whatever other number you choose to set.
                    

                        If 10 order acknowledgements have already been collected by the process, then the process will move to the automated activity to call the backend application (step 7).
                    

To configure the exclusive choice gateway, you'll need to start by selecting it from the BPMN diagram. Then, select the Condition Evaluation tab under the Properties view. Use the expression DO_Counter < 10 for the connection to loop back.
Furthermore, you need to select the Default Gate checkbox for the Call Backend connection (see Figure 10.89).

Figure 10.89    Configuration of the Exclusive Choice
Step 6: Intermediate Timer
This step can be configured to behave as a timeout. After the time (number of minutes/hours/days/months/years) configured in this step elapses, an event is triggered that pushes the event-based choice to take this route instead of going to the intermediary message event. In this case, use 5 minutes.
As soon as 5 minutes have elapsed, the process will be forced to call the backend application (step 7) with whatever acknowledgment messages have been collected so far (see Figure 10.90).

Figure 10.90    Time Offset on the Intermediate Timer
The next step to be configured is the automated activity.
Step 7: Automated Activity
The automated activity step needs to call the service interface that will move data to the backend application. You'll be using the SIOA_OrderConfirmation service interface, which currently holds the aggregated acknowledgements. To configure the automated activity, follow these steps:


                        Select the automated activity from the BPMN diagram.
                    

                        From the Properties view displayed in the bottom of the screen, choose the Interface tab.
                    

                        From the Service Interface dropdown field, select the SIOA_OrderConfirmation option (see Figure 10.91).
                    


Figure 10.91    Configuration of the Interface Tab of the Automated Activity
Now, you need to map the content of the DO_OrderConfirmationCollection data object to the input structure of the automated activity. Follow these steps:


                        From the Properties view, select the Input Mapping tab.
                    

                        Map all the fields of DO_OrderConfirmationCollection (on the left) to the structure of the automated activity (on the right), as shown in Figure 10.92.
                    


Figure 10.92    Mapping the Automatic Activity
You're now ready to proceed with the configuration of the last object of the BPMN diagram: the end event.
Step 8: End Event
This is the last step in the flow. There are no manual special configuration steps to be performed. As soon as a new message trigger is assigned to the start event, the end event is also automatically assigned with the same message trigger event. Figure 10.93 shows what this configuration looks like.

Figure 10.93    Configuration of an End Event
Your configuration is now ready. The next step is to build and deploy the process.
Build and Deploy the SAP Business Process Management Process
After successfully modeling and configuring your process, it's now time to compile the process and make it available in the SAP NetWeaver server by deploying it. To compile it, follow these steps:


                        In SAP NetWeaver Developer Studio, right-click on the DC to be compiled (in this case, dc_collectact).
                    

                        In the menu that appears, choose Development Component • Build, as shown in Figure 10.94. This action will trigger the compilation of the DC.
                    

                        You might see a pop-up requesting confirmation of the DCs to be built. This step is particularly useful if you want to compile and/or build more than one DC. Click on the OK button (see Figure 10.95).
                        
Figure 10.94    Building and Deploying the DC



Figure 10.95    Selecting the DCs to be Built
The compilation of the DC might take a couple of seconds, depending on its size and the speed of your local machine. The compilation might result in a fail status if errors were found in the SAP BPM DC. In such a case, the details of the errors will be visible in the Problems view, and you need to fix them before proceeding.
If the build task was successful, then the DC can now be deployed to the server by following these steps:


                        In SAP NetWeaver Developer Studio, right-click on the DC to be compiled (in this case, dc_collectact).
                    

                        In the menu that appears, choose Development Component • Deploy (refer to Figure 10.94). This action will then trigger the deployment of the DC to the server.
                    


Note
You can see what is going on during the deployment process by looking at the logs via the Deploy view Console tab, as shown in Figure 10.96.

Figure 10.96    Deployment Logs in the Deploy View Console

Now that the DC has been deployed, it's time to perform SOA configurations for the automated activity step.
Post-Deployment Configuration
In the SAP BPM process that was created, a SOA configuration needs to be performed on the service reference of the automated activity that needs to be used to call the backend application with the collected set of acknowledgements.
The service reference can then be configured to point to the desired service endpoint by following these steps:


                        Go to SAP NetWeaver Administrator via http://<host>:<port>/nwa, and log in.
                    

                        Navigate to the SOA tab, then choose Application and Scenario Communication • Application Communication. You're then presented with a list of DCs.
                    

                        Select the DC that contains your SAP BPM process.
                    

                        Upon selection, the bottom screen is populated with two tabs: Consumed Service Groups and Provided Services. Because you're interested in configuring the services that the process calls and consumes, select the Consumer Service Groups tab.
                    

                        Click on the Edit button.
                    

                        Select the <create...> option from the Provider System dropdown (see Figure 10.97).
                        
Figure 10.97    Configuration of the Application Communication


                        A new wizard launches. On the first screen, give the service provider a name (e.g., "OrderConfirmationService"). In addition, select the Other radio button for the System Type field (see Figure 10.98). Click on the Next button to proceed with the wizard.
                        
Figure 10.98    Provider System Creation


                        On the next screen, provide the endpoint of the service to be called. If this service is provided from AEX, then you can obtain its WSDL URL via the Display WSDL feature of the Integration Directory. Depending on the requirement of the web service, you might also have to provide authentication settings, as shown in Figure 10.99.
                        
Figure 10.99    Web Services Connectivity Details for Creating an SOA Provider System


                        After the provider has been created, you're redirected to the main page (refer to Figure 10.97). Click on the Save button to ensure that your settings are stored. You can also check the Processing State column to evaluate whether the settings applied in the provider system were correct. Traffic light colors (green, yellow, and red) visually indicate the processing state status (see Figure 10.100).
                    


Figure 10.100    Saved Consumed Service Groups Processing State
Now that you've configured the consumed service group, it's time to start testing your process.
Testing
With the process successfully deployed and configured, it's now time to trigger it by following these steps:


                        Log in to SAP NetWeaver Administrator.
                    

                        Navigate to Configuration Management • Processes and Tasks • Process Repository. You'll see a list of all deployed DCs.
                    

                        Select the active version, and click on the Start Process button (see Figure 10.101). This will launch the Web Services Navigator. In some circumstances, the Start Process button might be grayed out, in which case, you'll need to click on the Web Services Navigator link to test the process.
                        
Figure 10.101    Manually Starting the SAP BPM Process


                        After the Web Services Navigator launches, fill in the input data that the process requires before invoking the process.
                    

You could have also decided to start the process externally. In that case, you would access the WSDL of the SAP BPM process and use a web service client to trigger it.
To access and download the WSDL of the web service, follow these steps:


                        Log in to SAP NetWeaver Administrator, navigate to the SOA tab, and then choose the Application and Scenario Communication subtab.
                    

                        Click on the Single Service Administration link. Use the Find search field to search based on your service interface name.
                    

                        Once found, select the WSDLs tab, and click on the ZIP Download button to download the WSDL to your local machine.
                    

                        After you know the WDSL link or have the file, you can use a SOAP client tool of your choice to start the process. One commonly used tool is SoapUI.
                    

After invoking the process, it's now time to monitor what is happening with the running process.
Monitoring
To monitor the running SAP BPM processes, access the process management tool as follows:


                        Log in to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                        Navigate to the Operations tab.
                    

                        Select the Processes and Tasks option.
                    

                        Click on the Manage Processes link.
                    

                        A new page will load with a list of failed processes. Change the value of the View dropdown to All Running Processes. Now, you should be able to see the process that you just triggered (Figure 10.102).
                    

As Figure 10.102 shows, you can use the Context Data tab to view the content of different context data. See Chapter 15 for more details about the different options when monitoring an SAP BPM process.
Congratulations! You've just completed the modeling, configuration, running, and monitoring of your first SAP BPM process from scratch.

Figure 10.102    Monitoring All Running Processes in SAP PO









10.10    Summary
While reading this chapter, you were exposed to the functionalities and capabilities of SAP BPM. We started by exploring the SAP NetWeaver Development Studio tool used to model and build deployable processes. We looked at how SAP NetWeaver Development Studio can be configured and set up.
The chapter also explored various technical and configuration aspects of all important BPM objects supported by SAP BPM. These flow objects are categorized in different groups, and this chapter explored the following:


                Events
            

                Activities
            

                Gateways
            

                Artifacts
            

The details and roles of each one of those flow objects was explored and their attributes described. We further investigated some advanced mapping techniques, error handling aspects, and compiling and deploying the process in the SAP PO server.
We closed the chapter with a closer look at the different possible ways to integrate and combine SAP BPM and the AEX to realize the full potential of what SAP PO has to offer. This ESB (AEX) and SAP BPM engine combo creates a unique and powerful platform for you to direct your orchestration's orchestra.
The next chapter will touch on some advanced SAP BPM concepts and extensions.








11    Applying Advanced SAP BPM Concepts and ExtensionsI do the very best I know how, the very best I can, and I mean to keep on doing so until the end.                                                                                              —Abraham LincolnIn the previous chapter, we explored different aspects of implementing an SAP Business Process Management (SAP BPM) process: modeling, configuring, compiling, and deploying. Now that the process has been deployed in the SAP Process Orchestration (SAP PO) server, you might be tempted to think that we can proceed with running and testing the process. That's not entirely the case!At this point, you know how to build SAP BPM processes from the ground up and deploy them to SAP NetWeaver AS Java, so we'll move on to the next step and explore how to configure the deployed processes using the service-oriented architecture (SOA) configuration functionality available in SAP NetWeaver Administrator. The SOA configuration will enable you to indicate the actual endpoint of the services to be consumed by your SAP BPM process.Notions of SAP BPM custom Enterprise Java Bean (EJB) functions and aspects covering the testing and debugging of a running process will also be explored in this chapter, and we'll look at advanced concepts, such as how to consume and leverage SAP BPM internal functionalities from an external application using the provided SAP BPM application programming interface (API) and OData. The chapter also provides some recommendations and best practices to take into consideration during the process of designing and implementing a process using SAP BPM.
11.1    Service-Oriented Architecture Configuration
Depending on the flow objects used in the Business Process Model and Notation (BPMN) model of the process, you may need to perform some extra configuration steps. These extra configurations are mostly needed for flow objects that facilitate the exchange of messages (send or receive) with other systems, such as the Advanced Adapter Engine Extended (AEX). The flow objects in question include the following:


Start event SAP BPM receives a message from an external system to start the process.
            

Intermediary event SAP BPM receives a message from the outside world to resume a waiting process.
            

Automated activity SAP BPM calls an external system. The message is sent from SAP BPM to the outside world.
            

We'll explore the different configuration settings for each one of these flow objects in the following sections.
11.1.1    Configuration for an Automated Activity
During design time, you need to configure a service reference in the settings of the automated activity. A service reference is created for the outbound service interface that has been assigned to the automated activity. At this point, there are no references to the actual endpoint of the service.
The service reference can then be configured at runtime to point to the desired system, providing the service or the service endpoint. This is especially useful because the same SAP BPM process will need to be transported through the landscape: development, test, acceptance, and production. The endpoint that the SAP BPM process will need to call for those different environments won't be the same. Therefore, you need to reconfigure this setting at runtime to point to the relevant environment-specific endpoint.
As Figure 11.1 depicts, SAP BPM can use web services (WS), XI 3.0 message protocol, or Remote Function Calls (RFCs) to communicate with other systems. Different configuration approaches apply depending on whether the service reference used for the automated activity uses RFC, XI 3.0, or the WS as message protocol. The next sections will explore those approaches.

Figure 11.1    Communication Options between SAP BPM and Other Systems
Configuration for Web Services
If the service reference setting of the automated activity is set to WS (Figure 11.2), this implies that the service will be consumed as a web service. The WS message protocol is used in the following scenarios:


Calling an external system via the AEXIn this case, the AEX plays a mediation role.
                    


Figure 11.2    Setting the SAP BPM Service Reference to Call the Appropriate Service as WS


Calling an external service directly without using the AEXThis requires that the external system exposes its service using Simple Object Access Protocol (SOAP) as a web service.
                    

Calling the SAP backend  system directlyThis approaches requires the SAP backend to expose a SOAP service.
                        If the service provided is mediated via the AEX, then the sender communication channel used should have the Message Protocol set to SOAP (Figure 11.3).
                    


Figure 11.3    Sender Communication Channel Settings When SAP BPM Communicates with the AEX via WS
To configure the service reference, follow these steps:


                        After the SAP BPM process has been deployed, log in to SAP NetWeaver Administrator.
                    

                        Navigate to the SOA tab and then to Application and Scenario Communication.
                    

                        Click on the Application Communication link (Figure 11.4). Alternatively, go to http://<hostname>:<port>/nwa/appcommunication. From this page, you can configure the inbound and outbound communication of an SAP BPM development component (DC).
                    

                        You're redirected to another screen, which contains a list of all applications or DCs. From the list, select the name of your DC.
                        
Figure 11.4    Application and Scenario Communication in the SOA Tab of SAP NetWeaver Administrator


                        A screen is populated at the bottom with two tabs:
                        

Consumed Service Groups This tab includes all the services that SAP BPM consumes. All service interfaces used in an automated activity will be configurable from this page.
                            

Provided Services This tab includes the list of services that the process provides. This includes the message triggers used for start events and intermediary events.
                            



Because we're interested in configuring the services that the process calls or consumes, select the Consumed Service Groups tab.
Figure 11.5 shows an example of what a process looks like that has been newly deployed and not yet configured. The figure shows that the service group called SG_CurrencyWS has the WS connectivity type and the provider system pointing to the local system. Furthermore, the processing state is currently red (Failed).

Figure 11.5    Status of Nonconfigured Service Group for Process DC
Your next steps will be as follows:


                        Click on the Edit button in the Consumed Service Groups tab.
                    

                        Select the service group that you want to configure, and open the Provider System column dropdown menu.
                    

                        If the correct system provider already exists, then you can select it from the dropdown. In this case, you need to create a new one, so select the <create...> option (Figure 11.6).
                        
Figure 11.6    Editing the Service Group and Choosing to Create a New Provider System


                        You're forwarded to a new screen to create a new provider system. Fill in the details by providing a meaningful name and a description. Don't forget to choose Other as the System Type. Then, click on Next (Figure 11.7 1).
                    

                        On the next screen, fill in the URL of the Web Service Description Language (WSDL) of the web service to be called 2. Provide a user name and password if the service requires authentication. Click on Next to move to the next screen.
                        
Figure 11.7    First Steps of Creating a New Provider System


                        On the next screen, the web service is automatically tested using the WSDL and authentication details that you provided. If all goes well, you'll see a message indicating success. If it fails, then you'll need to go back to the previous steps and make the required corrections.
                    

                        Click on Finish. You're forwarded back to the original screen. Make sure that the newly created provider system is selected (Figure 11.8).
                    

                        Click on the Save button to store your configuration.
                    

                        Click on the Refresh button on the right side of the screen to get the updated status of the service group with the new provider system. You should now see an Error, Warning, or Successful status. In our example, the configuration ended in a warning (in yellow), as shown in Figure 11.8.
                    


Figure 11.8    Pointing the Service Group to the Newly Created Provider System
Congratulations! You've successfully configured the service group to point to the runtime web service.
Note that this ability to configure different endpoints after deployment is a very useful feature that provides flexibility. If the service provider moves or changes its URL, you only need to reconfigure the service provider, and then you're ready to go. You don't need to change or redeploy the SAP BPM DC.

Note
If you get an error or warning in the service group, you can see more details about the problem by clicking on the Show Log button (Figure 11.8). A new screen will pop up with log details from the SAP NetWeaver Log Viewer.

If your Services Registry is configured with your SAP PO installation, then you can let the system automatically discover the provider system by clicking on the Auto Assign button. The system automatically looks up and discovers the provider system via the Service Registry. You can remove this assignment at any point by selecting the <none> option in the Provider System dropdown.
Configuration for XI 3.0
The XI 3.0 message protocol is an SAP-proprietary message protocol based on SOAP and enhanced with extra information, such as routing and monitoring. Most importantly, the XI 3.0 message protocol supports reliable messaging.
The XI 3.0 message protocol is used in the following scenarios:


Calling a service provided by the AEX from an SAP BPM processIn this case, the AEX plays a mediation role. It goes without saying that the service being called from the AEX can point to any system (SAP backend or legacy).
                    

Calling the SAP BPM processThe SAP BPM process exposes an XI 3.0 endpoint that can be consumed from the AEX.
                    

If the SAP BPM process is calling the AEX, then the sender communication channel should have the Message Protocol field set to XI 3.0 (Figure 11.9).

Figure 11.9    Sender Communication Channel with XI 3.0 Message Protocol Sender
When dealing with the XI 3.0 message protocol as a medium of communication between SAP BPM and the AEX, the SAP BPM process needs to be represented in AEX as a communication component of type business component. This communication component is used in the integrated configuration (ICO) for sending or receiving messages from SAP BPM. Figure 11.10 shows an ICO example that receives a call from an SAP BPM process.

Figure 11.10    ICO Using the Sender Communication Channel with an XI 3.0 Protocol
Note that the ICO uses BC_DemoBPM as the sender communication component. This information will be handy when setting up the service group configuration in SAP NetWeaver Administrator.
In SAP NetWeaver Developer Studio, when importing the service interface and service group, you'll need to configure the service reference, as shown in Figure 11.11.
You'll also notice in Figure 11.11 that the Type field is set to XI and that the Sender Component field is set to BC_DemoBPM, thus matching the sender communication component used in the ICO. This is the mechanism by which SAP BPM can send the message directly to the correct ICO. If this setup is correctly performed, then there is no need to make extra configurations in SAP NetWeaver Administrator. After the SAP BPM process has been deployed to the server, it's also possible to change the details of the sender component from within SAP NetWeaver Administrator.

Figure 11.11    Configuration of the Service Reference
To configure the service reference in SAP NetWeaver Administrator for an XI 3.0-based communication, follow these steps:


                        After the process has been deployed, go to http://<hostname>:<port>/nwa/appcommunication. You might need to log in.
                    

                        You're redirected to a screen showing a list of all applications or DCs. From the list, select the name of your DC.
                    

                        The bottom screen is then populated with details of the selected DC. In the Consumed Service Groups tab, select the XI-based service group (Figure 11.12 1).
                    

                        Click on the Edit button.
                    

                        You'll see a list of service references, which is part of the service group that you selected in the previous step.
                    

                        Select the desired service references, and click on Show Details (Figure 11.12 2 and 3).
                    

                        In the screen populated at the bottom, select the Configuration tab.
                    

                        From the new tab, it's then possible to select the General tab.
                    

                        Change the Sender Component field 4.
                    

                        Click on Save to store your configuration.
                        
Figure 11.12    Configuration of a Service Reference for an XI-Based Communication in SAP NetWeaver Administrator


Configuration for Remote Function Call
If your BPM process will be calling an SAP function module, then you need to use the RFC protocol. This means that SAP BPM will directly call the SAP backend system. During design time (in SAP NetWeaver Developer Studio), one of the first steps will be to import the RFC function structures (input and output). During the import, you'll need to specify the service group for the connection to the backend. The service reference associated with the service group is automatically assigned the RFC type (Figure 11.13).

Figure 11.13    Setting of the SAP BPM Service Reference to Call an RFC Function Module
After the process has been deployed to the SAP PO server, it's time to configure the service group from SAP NetWeaver Administrator by following these steps:


                        After the process has been deployed, log in to SAP NetWeaver Administrator.
                    

                        Navigate to the SOA, and then to Application and Scenario Communication.
                    

                        Click on the Application Communication link. Alternatively, go to http://<hostname>:<port>/nwa/appcommunication. From this page, you can configure the endpoints of the services used in an SAP BPM DC.
                    

                        You're redirected to a screen showing a list of all applications or DCs. From the list, select the name of your DC.
                    

                        A screen is populated at the bottom with two tabs: Consumed Service Groups and Provided Services. Because you're interested in configuring the services that the process calls, select the Consumed Service Groups tab. Configure the service reference as shown in Figure 11.14, in which you can see that the service group called SG_BAPI_USER_GET_DETAIL has the RFC connectivity type and a provider system not configured.
                    

                        Click on the Edit button in the Consumed Service Groups tab to configure it.
                    

                        Select the service group, and open the Provider System dropdown.
                    

                        If the correct provider system already exists, then it can be selected from the dropdown. In this case, you need to create it. Proceed by selecting the <create...> option (Figure 11.14).
                        
Figure 11.14    Creating a Provider System for the RFC Service Group


                        You're forwarded to a new screen to create a new provider system. Fill in the details by providing the name (System ID) of the backend system, a Client, and a System Type. Note that System Type should always be ABAP. Click on Next to proceed with the wizard (Figure 11.15 1).
                    

                        On the next screen, fill in all RFC connectivity details, such as the Target Host, System Number, and login credentials (User Name and Password) 2.
                    

                        Click the Next button to proceed to the next screen of the wizard. Keep all the default values.
                    

                        Click the Finish button.
                    


Figure 11.15    Steps to Configure the RFC Provider System
11.1.2    Configuration for a Start Event or Intermediary Event
Both start events and intermediary events are used by SAP BPM to receive messages from an external system. The start event receives a message and starts a new instance of a process, whereas the intermediary event receives a message in the middle of the process, when the process is idle and waiting. When a matching message is received, the process resumes.
Although used for slightly different purposes in SAP BPM, the configuration of these two flow objects are the same. They both handle messages going toward SAP BPM. These two types of inbound connectivity toward SAP BPM are automatically configured to provide both XI and WS message protocols. It's up to the system calling the SAP BPM process to decide which one of these message protocols is more suitable to use. SAP PO automatically configures XI and WS for you, so you don't need to perform additional configurations. However, you can configure or assign a communication profile to a connection of the WS type. A communication profile groups a set of policies that the connection between the consumer and SAP BPM needs to adhere to. In a communication profile, settings of what authentication method to use can be configured. This includes elements such as user name and password (basic), X.509 Client Certificate, SAP Logon Tickets, Security Assertion Markup Language (SAML) Assertion, and so on.
Create a Communication Profile
A communication profile can be created via the following steps:


                        After the SAP BPM process has been deployed, log in to SAP NetWeaver Administrator.
                    

                        Navigate to the SOA tab, and then select the Technical Configuration subtab.


                        On the subsequent screen, click on the System Connections link.
                    

                        On the following screen, select the Communication Profile tab.
                    

                        Click on the New button to start the wizard to create a new communication profile.
                    

                        Specify the name and description of your communication profile—for example, "BASIC_AUTH_LOCALHOST". Then, click on Next to move to the next screen.
                    

                        Specify the desired connection type and authentication settings.
                    

                        Click on the Finish button.
                    


Note
Communication profiles only apply to connections of the WS type. A service provided by an SAP BPM process with a connection type of XI can't be configured or modified after deployment. Therefore, you can't assign a communication profile to a configuration for a connection of type XI.

Assign a Communication Profile
As previously mentioned, a configuration of the start event or intermediary event is restricted to assigning a communication profile to the connections of the WS type. Follow these steps to assign a communication profile:


                        After the SAP BPM process has been deployed, log in to SAP NetWeaver Administrator.
                    

                        Navigate to the SOA tab, and then go to Application and Scenario Communication.
                    

                        You're redirected to a screen showing a list of all applications or DCs. From the list, select the name of your DC.
                    

                        A screen is populated at the bottom; click on the Provided Services tab.
                    

                        Select the service interface that the SAP BPM process provides or exposes, and click on the Edit button.
                    

                        Click on the Assign Profile button to select the desired communication profile.
                    

                        Click on the Save button to activate the change.
                    










11.2    Testing and Running an SAP BPM Process
After you've successfully deployed and made all necessary SAP NetWeaver Administrator configurations, it's time to trigger your process. This section will focus on finding the deployed processes in the SAP PO server via the Process Repository. Furthermore, we'll explore how to run and test the deployed process.
11.2.1    Process Repository Overview
The Process Repository is a tool within SAP NetWeaver Administrator that enables administrators to view the following information:


                    All deployed SAP BPM DCs
                

                    Versions of the components
                

                    Related process and task definitions
                

                    Start process instances
                

                    Process-related resources available to download
                

To access the Process Repository, follow these steps:


                    Log in to SAP NetWeaver Administrator.
                

                    Navigate to Configuration Management • Processes and Tasks • Process Repository. You'll then see the screen presented in Figure 11.16.
                

The next sections will explore each of the Process Repository's features.

Figure 11.16    Process Repository Overview with the List of Components
List of Process Development Components
In this view, you'll see a list of deployed DCs containing processes. After selecting a DC, a list of all its deployed versions is shown. Each time the DC is deployed, a new version is created on the server. The version number contains the deployment date and time. The latest DC to be deployed is automatically activated and considered as the active version.
Activate and Deactivate Development Components
You can always see which process is currently active by looking for the check in the Active column (refer to Figure 11.16). If you want to run a different version than the latest deployed one, you can select any version and then click on the Activate button to make it the running version. Similarly, you can deactivate any versions by using the Deactivate button.
Start Process
From this page, you can start any process that has been deployed to the SAP PO server. It's important to note that starting a process from the Process Repository is an activity reserved for administrators. The user needs to have sufficient authorization to access the functionality.
In most cases and normal, everyday operations, a process should be triggered from the outside. An example is an arriving message or an interface being called from the AEX.

Note
More details about the functionalities provided by this page are provided in Section 11.2.2.

To start a new process instance, follow these steps:


                        From the Process Repository's page, select the active version, and click on the Start Process button.
                    

                        You'll see a new pop-up, in which you can enter input data.
                    

                        After filling in the data, click on Start Process to trigger the creation of a new instance.
                    

Download Resources
You can go to the Resource tab from the Process Repository's page, select any of the listed resources, and download them. The files to be downloaded are in different forms: WSDL files, data types, and other file resources.
11.2.2    Process Testing
You now know how to find a deployed process on the server via the Process Repository. There are two main ways to call or test these SAP BPM processes:


                    Internally from SAP PO
                

                    Externally using a web service client tool
                

We'll now explore these two approaches.
Internally from SAP Process Orchestration
To call the process from within the SAP PO server, follow these steps:


                        To get to the Process Repository, from the SAP NetWeaver Administrator main page, navigate to Configuration Management • Processes and Tasks • Process Repository.
                    

                        From the Process Repository, search for the DC containing the process that was previously deployed. After selecting it, the Processes and Tasks tab will be populated with all available processes contained in the selected DC.
                    

                        Select the desired process from the Processes and Tasks tab, and click on the Start Process  button (Figure 11.17).
                    

                        You'll see a new pop-up, in which you can provide input data for the process.
                        
Figure 11.17    Start an SAP BPM Process from SAP NetWeaver Administrator


                        After filling in the data, click on Start Process (Figure 11.18). You'll see a message indicating that the process started. The message also provides you with the process instance ID.
                        
Figure 11.18    Provide Input Data for the Process


                        As you can see in Figure 11.18, in addition to directly providing the input data required by the SAP BPM process, you can also upload an existing XML file using the Browse and Upload buttons.
                    

                        Alternatively, you can call the SAP BPM process like any other web service by using the Web Services Navigator, accessible via http://<hostname>:<port>/wsnavigator.
                    

You can also use the Single Service Administration tool from SAP NetWeaver Administrator to test or start the SAP BPM process, via the following steps:


                        From SAP NetWeaver Administrator, navigate to the SOA tab.
                    

                        Click on the Application and Scenario Communication subtab, and then click on the Single Service Administration link.
                    

                        Enter the name of your service interface in the Find search field to find the WSDL.
                    

                        Once found, select the WSDLs tab, and click on the Test button to launch the Web Services Navigator.
                    

After starting the new process, you can monitor it. More details about how to monitor the process can be found in Chapter 15.
Externally Using a Web Service Client Tool
It's more common to call the SAP BPM process from outside of the SAP PO server. An external application will send a message, which will in turn start a new instance of the SAP BPM process. First, you need to obtain the WSDL or endpoint of the concerned process.
The WSDL can be obtained in one of two main ways:


SAP NetWeaver Developer Studio It's possible to use the message event trigger of the SAP BPM process from SAP NetWeaver Developer Studio to find the location of the WSDL. Figure 11.19 shows that the WSDL URL can be retrieved from the Endpoint Name field. Here, the endpoint is http://<hostname>:<port>/nwa/appcommunication. You'll need to replace <hostname> and <port> with the actual details of your SAP PO server.
                    


Figure 11.19    Endpoint of the SAP BPM Process as Seen in the Message Event Trigger


Single Service Administration (SOA in SAP NetWeaver Administrator) From SAP NetWeaver Administrator, you'll need to navigate to the SOA tab, and then choose the Application and Scenario Communication subtab. Then, click on the Single Service Administration link. Use the Find search field to search based on your service interface name. Once found, you'll need to select the WSDLs tab and click on the ZIP Download button to download the WSDL on your local machine.
                    

After you know the WDSL link or file, you can use a SOAP client tool of your choice to start the process. One such commonly used tool is SoapUI.
As mentioned in Chapter 1 when talking about the positioning of SAP BPM, the recommended approach is to call the AEX and let it trigger SAP BPM.









11.3    Custom Enterprise Java Bean Functions
As discussed in Chapter 10, when performing mappings in SAP BPM and find that the standard functions provided by SAP don't fulfill your needs, you can create your own custom functions. This section will focus on how to create your own functions using an Enterprise Java Bean (EJB). Be aware that a basic understanding of Java is required to create an EJB function. The next section will provide step-by-step instructions for how to create a custom EJB function in SAP BPM.
Let's start by describing the requirements for our sample custom function. The function to be created needs to provide the functionality to replace a set of characters from a sentence with another set characters, basically performing the same functionality as the replace method of the string object in Java.
To create the custom EJB function, the following tasks will need to be accomplished:


                Create a DC for the EJB.
            

                Create a DC for the Enterprise Application Archive (EAR).
            

                Create dependencies between the EJB and EAR DCs.
            

                Create a Java Bean (in the EJB DC) with the required mapping functionality.
            

                Build and deploy both the EJB and EAR DCs.
            

                Create a new EJB function holder in your SAP BPM DC.
            

Let's now explore each of these steps.
11.3.1    Create EJB and EAR Development Components
For the sake of simplicity, we'll create local DCs instead of using the SAP NetWeaver development infrastructure. Follow these steps:


                    Launch the SAP NetWeaver Developer Studio IDE, and select the Development Infrastructure perspective.
                

                    Create a new DC of the EJB module type under Java EE. Fill in the name, description, and vendor. Follow the wizard. If you're asked to change perspective, answer No (see Figure 11.20 1 and 2).
                    
Figure 11.20    Steps in Creating an EJB Module DC


                    Repeat the previous step to create a new DC of the enterprise application type. Make sure to reference the EJB DC during the wizard, as shown in Figure 11.21. Follow the wizard until the end. If you're asked to change perspectives, answer No.
                    
Figure 11.21    Steps in Creating an EAR Module DC


                    From the Development Infrastructure perspective, select the EJB DC that you previously created.
                

                    Add dependencies to the EJB DC according to the dependencies presented in Table 11.1 under the EJB DC type by clicking on the Add button from the Dependency tab (see Figure 11.22).
                

                    From the pop-up, filter for the appropriate dependency, and click on Finish (Figure 11.22).
                

                    Repeat the two previous steps for all the dependencies marked in Table 11.1 under the EJB DC type.
                

                    When asked to Sync Used DCs if Prompted, click on OK.
                    



                                    DC Type
                                

                                    Dependencies
                                





                                    EJB DC


engine.jee5.facade (from ENGFACADE)tc/bl/logging/api (from ENGFACADE)tc/je/sdo21/api(from ENGFACADE)tc/bpem/mapping/facade (from SERVICE-COMP)




                                    EAR DC


tc/je/sdo21/api (from ENGFACADE)tc/bpem/mapping/facade (from SERVICE-COMP)




Table 11.1    List of Dependencies to be Added, Depending on the DC Type

Figure 11.22    Adding Dependencies to a DC


                    Repeat steps 4 to 8 for the EAR DC.
                

11.3.2    Create the Enterprise Java Bean
The EJB with the function logic in Java needs to be created in the EJB DC. Follow these steps:


                    In SAP NetWeaver Developer Studio, change to the Java EE perspective.
                

                    Navigate to the EJB project (DC), and expand it.
                

                    Right-click on the ejbModule folder, select New and Session Bean (Figure 11.23 1).
                

                    Specify a Java package and class name 2.
                

                    Follow the wizard, and click on Finish.
                    
Figure 11.23    Creating a New Session Bean


                    Make your new bean implements both com.sap.glx.mapping.execution.api.invoker.SdoInvoker and com.sap.glx.mapping.execution.api.function.Function.
                

                    Implement the functionality of your bean in the invokeSdo method. The final source code of the class is presented in Listing 11.1.
                

package com.rojoconsultancy.function.custom;import javax.ejb.Stateless;import javax.xml.namespace.QName;import com.sap.glx.sdo.api.SdoRenamingHelper;import commonj.sdo.DataObject;import commonj.sdo.Type;import com.sap.glx.mapping.execution.api.function.*;import com.sap.glx.mapping.execution.api.invoker.*;/*** Session Bean implementation class CustomReplace*/@Statelesspublic class CustomReplace implements CustomReplaceLocal,  Function,SdoInvoker{    //Parameter declaration    private static final String ORIGINALSTRING = "originalString";    private static final String OLDCHARS = "oldChars";    private static final String NEWCHARS = "newChars";    private static final String RESPONSE = "response";    private static final String NAMESPACE = "com.rojoconsultancy.      function.custom/CustomFunction";    private static final String       INPUT_ORIGINALSTRING = SdoRenamingHelper    .renameXsdElementToSdoProperty(new QName(NAMESPACE,        ORIGINALSTRING), false);    private static final String INPUT_OLDCHARS = SdoRenamingHelper    .renameXsdElementToSdoProperty(new QName(NAMESPACE, OLDCHARS),        false);    private static final String INPUT_NEWCHARS = SdoRenamingHelper    .renameXsdElementToSdoProperty(new QName(NAMESPACE, NEWCHARS),       false);    private static final String OUTPUT_RESPONSE = SdoRenamingHelper    .renameXsdElementToSdoProperty(new QName(NAMESPACE, RESPONSE),       false);/*** Default constructor.*/public CustomReplace() {// TODO Auto-generated constructor stub}    @Override    public DataObject invokeSdo(DataObject dtObt, InvocationContext       invContext) {        // retrieve input parameter values        Type typeInput = dtObt.getType();        String originalString = dtObt.getString(typeInput.getProperty(          INPUT_ORIGINALSTRING));        String oldChars = dtObt.getString(typeInput.getProperty(          INPUT_OLDCHARS));        String newChars = dtObt.getString(typeInput.getProperty(          INPUT_NEWCHARS));        // implement the logic of the mapping        String responseString = originalString.replace(oldChars,           newChars);        // building the output        DataObject dataObjectResponse =          invContext.createOutputDataObject();        dataObjectResponse.setString(                dataObjectResponse.getType().getProperty(                  OUTPUT_RESPONSE), responseString);        return dataObjectResponse;    }}
Listing 11.1    Source Code for the CustomReplace Java Bean
11.3.3    Build and Deploy
After implementing the logic of the EJB, it's now time to build and deploy the source code to the SAP PO server. To build and deploy, follow these steps:


                    Open the EAR project, and right-click on the project DC.
                

                    Click on Build. This task will run for a few minutes.
                

                    Right-click on the project DC one more time
                

                    Click on Deploy. This task will run for a few minutes.
                

11.3.4    Create a New Enterprise Java Bean Function
To create a new EJB, follow these steps:


                    Log in to the Java Naming and Directory Interface (JNDI) via http://<hostname>:<port>/nwa/appcommunication.


                    From the JNDI page, filter on the name of the class (Java Bean) used to implement the custom mapping logic in the Find field. See the top red outline in Figure 11.24.
                

                    Copy the JNDI object name of the bean. See the lower red outline in Figure 11.24.
                    
Figure 11.24    JNDI Lookup of the EJB


                    Return to SAP NetWeaver Developer Studio, and expand the SAP BPM project.
                

                    Right-click on the FUNCTIONS folder, and select New EJB Function (Figure 11.25 1).
                

                    Give the new function a name and specify input and return parameters (Figure 11.25 2).
                

                    Click on Finish.
                

                    On the new screen, fill in the JNDI Name field (see Figure 11.26).
                    
Figure 11.25    Creating a Custom EJB Function

Figure 11.26    Adding the JNDI Reference to the EJB Function


                    The newly created custom function is now present in the in the rules and functions repository and can be used (see Figure 11.27).
                


Figure 11.27    Using the Newly Created Custom EJB Function
The newly created CustomReplace EJB function can be used just like any normal function or rule.









11.4    Using the Claim Check Pattern
You might come across a requirement to send large files to your SAP BPM process. Loading a large file in your process can be a memory-expensive exercise. If not taken care of in a proper manner, these tasks can cause a severe performance problem in your SAP PO server. SAP BPM operates better with a smaller payload.
The claim check pattern is part of the Enterprise Integration Patterns (EIPs) and was introduced to reduce the volume of data to be transported through the integration layer by only taking the necessary chunks of data and filtering the rest out (see Figure 11.28).

Note
For more in-depth details about EIPs, refer to the book Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions by Gregor Hohpe and Bobby Woolf (Addison-Wesley Professional, 2003).


Figure 11.28    Enterprise Integration Patterns: Claim Check
The claim check pattern can be used in the context of SAP BPM. The general high-level approach to implementing this pattern in SAP BPM is as follows:


                The large payload is temporarily persisted and saved in database storage before it reaches SAP BPM. The persisted message is then given a Ready status.
            

                A primary key is retrieved from the database. This primary key or unique identifier will be used later to reaccess the full payload. The unique identifier is also referred to as the claim check.
            

                Only a subset of the payload is extracted and transferred to SAP BPM. This data subset is a smaller message and contains the critical data needed by SAP BPM. The unique identifier retrieved from the database is also included in this small message.
            

                While the process is running, the large payload can be retrieved via the unique identifier.
            

                The large payload is updated to the processed status. Messages marked with the processed status will be later deleted from storage via the deletion job.
            


Note
The claim check pattern answers the question of how to reduce the data volume of messages sent across the system without sacrificing information content.

The preceding steps will be translated to concrete SAP PO actions, which are explored in the next sections.
11.4.1    Create Interfaces
In the first step of implementing the claim check pattern, you need to create the following interfaces:


                    From the ES Repository, create a data type, message type, and service interface for the large payload structure (original message).
                

                    Create a data type, message type, and service interface for the small payload structure. This new structure only includes the fields that are absolutely necessary in SAP BPM. The message structure also needs to include a field for a unique identifier.
                

11.4.2    Create Mappings
After the interfaces to represent the large and small messages have been defined, the following mappings will need to be created:


                    Create a mapping between the large (original) message and the small message.
                

                    Create a second mapping to aggregate many individual messages into one large message.
                

11.4.3    Configure the Channel
In the ICO or iFlow used to send the message to SAP BPM, configure the receiver communication channel using the SCPMappingBean adapter module. See Figure 11.29 for an example receiver communication channel configuration.

Figure 11.29    Receiver Communication Channel Configured for the Claim Check Pattern
Table 11.2 lists the module parameters (used for the SCPMappingBean module) and describes what they are used for.




                            Module Parameter
                        

                            Description
                        





mappingid


                            The message ID of the operation mapping used. The ID can be retrieved from the ES Repository.
                        



persistuntil


                            The duration that the persisted message needs to be stored for. The period needs to be expressed in days.
                        



xpath


                            The XPath expression to the field of the small message to be used for storing the message ID (unique ID).
                        



Table 11.2    Module Parameters Used in the Communication Channel for the Claim Check Pattern
11.4.4    Retrieve the Large Message from SAP BPM
From the SAP BPM processes, it's possible to retrieve data from the large message that was temporarily stored. The payload can be retrieved by calling a special web service from SAP BPM using an automated activity. The service interface to be imported is called OriginalMessageAccessor. The service calls the OriginalMessageAccessorBean in SAP PO. This service has four fields, which are described in Table 11.3. These fields will need to be filled in the inbound mapping in the SAP BPM process.




                            Field Name
                        

                            Description
                        





MESSAGE_ID_LIST


                            A list of message IDs to be used to retrieve data from the store
                        



PROCESS_INSTANCE_ID


                            The instance ID of the process that needs to retrieve the claim check
                        



OPERATION_MAPPING_GUID


                            The GUID of the operation mapping from the ES Repository
                        



SWCV_GUID


                            The GUID of the software component (SC) from the ES Repository
                        



Table 11.3    Fields of the OriginalMessageAccessor Message to be Used in the Claim Check
11.4.5    Update the Status of the Large Message from SAP BPM
Similar to the previous step, the SAP BPM process needs to call the MessageStatusUpdater service from an automated activity. The service calls the MessageStatusUpdaterBean in SAP PO. This service call will update the status of the message stored in the database from Ready to Processed.
This service has two fields, which are described in Table 11.4. These fields will need to be filled in the inbound mapping in the SAP BPM process.




                            Field Name
                        

                            Description
                        





MESSAGE_ID_LIST


                            A list of message IDs to be used to retrieve data from the store
                        



PROCESS_INSTANCE_ID


                            The instance ID of the process that needs to retrieve the claim check
                        



Table 11.4    Fields of the MessageStatusUpdater Message to be Used in the Claim Check









11.5    SAP BPM Application Programming Interface
In your projects, you might need to use or call the functionalities provided by SAP BPM from an external application. You can access the SAP BPM functionality from outside SAP BPM by using its API. A common scenario for using the SAP BPM API is when you want to use another UI technology that better fits your requirements to complete tasks generated by SAP BPM. Be aware that you can use any UI technology of your choice to consume the SAP BPM API, including Web Dynpro, EJB, Java Server Pages (JSP), SAPUI5, and so on.
The SAP BPM API is provided from within SAP PO, so you can't directly consume it from an external application. To access it remotely, you'll need to write an application that wraps the internal SAP BPM API functionality and exposes it as a REST or a web service (SOAP). There are some open-source projects available on SAP Code Exchange that provide a REST wrapper for the SAP BPM API.
Following are some of the functionalities that can be accessed by using the SAP BPM API:


                Starting an SAP BPM process
            

                Retrieving details of a process
            

                Retrieving details of a task
            

                Executing a task
            

                Assigning a task to a user
            

                Retrieving different statistics on the administrators of processes and tasks
            

                Retrieving a process flow diagram
            

                Retrieving reports
            

11.5.1    Prerequisite to Using the SAP BPM API
To start consuming the SAP BPM API functionality, the following conditions need to be satisfied:


                    The SAP BPM process on which the API needs to be used must be deployed on the SAP PO server.
                

                    The user to be used to connect to the SAP PO server (via the API) must have the necessary UME actions added to his profile to use the SAP BPM API. For instance, to start an SAP BPM process, you'll need the role SAP_BPM_TRIGGER_EVENT assigned to the user's profile.
                

                    The UI technology chosen to call the SAP BPM API can be deployed in the SAP NetWeaver AS Java of the SAP PO server.
                

11.5.2    Implementation Aspects and Examples
The DC used to implement and call the SAP BPM API needs to have dependencies to the SAP DCs, as indicated in Table 11.5.




                            Development Component
                        

                            Software Component
                        





tc/bpem/facade/ear


BPEM-FACADE




tc/je/sdo21/api


ENGFACADE




Table 11.5    Dependencies Required to Consume the SAP BPM API
SAP BPM API classes are included in a number of SAP-provided packages. Taking the com.sap.bpm.pm.api package as an example, the following main objects or managers are included:


ProcessDefinitionManager Represents the collection of all process definitions.
                

ProcessInstanceManager Represents the collection of all instances of a particular SAP BPM process.
                

TaskInstanceManager Class to manage instances of a task.
                

ProcessStartManager Class responsible for managing the functionality of starting processes.
                

ProcessModelManager Manages the objects related to process models.
                

Uniform Resource Indicator Concept
Some general behaviors and concepts across the different SAP BPM objects need to be considered to understand how to use the API. One of those concepts is the URI. Every object accessed and used via the SAP BPM API can be addressed via its URI. The URI can be considered as a unique identifier for any SAP BPM objects during runtime. A lot of methods on the objects require the URI as input. After getting access to the ProcessDefinition object, you can call the getId() method on it to retrieve its URI.
In the next section, we'll provide an excerpt to illustrate how to use the SAP BPM API to start an SAP BPM process.
Start a Process
To start a process from the SAP BPM API, follow these steps:


                        Get a reference to the ProcessDefinitionManager.
                    

                        Access the ProcessDefinition object from the ProcessDefinitionManager.
                    

                        Retrieve a ProcessStartEvent object.
                    

                        Create an input data object, and populate it with data.
                    

                        Start the process.
                    

Sample source code to start an SAP BPM process is presented in Listing 11.2.
//Get a reference to the ProcessDefinitionManager - gives access on all //existing Process Definitions in the server.ProcessDefinitionManager manager = BPMFactory.getProcessDefinitionManager();//Access a specific process definition based on the vendor, name of the //DC, and the process name.ProcessDefinition activeProcessDefinition = manager.getActiveProcessDefinition("rojoconsultancy.com", "dc_demoapi", "employeedata");//Retrieve a ProcessStartEventSet<ProcessStartEvent> processStartEvents = BPMFactory.getProcessStartManager().getProcessStartEvents(activeProcessDefinition.getId());ProcessStartEvent currentEvent = processStartEvents.iterator().next();//Build the input data object, and populate it with valuesDataObject inputDO = BPMFactory.getProcessStartManager().createDataObjectForStartEvent(currentEvent);inputDO.set("firstname", "John");inputDO.set("leaveType", "smith");//Start processif(currentEvent!=null){URI startedInstanceID = BPMFactory.getProcessStartManager().startProcess(currentEvent, inputDO);}
Listing 11.2    Sample Code to Create and Start a New SAP BPM Instance
For further details on this and other packages, classes, and methods available for the SAP BPM API, refer to the following link: http://bit.ly/2wIC9tp.









11.6    SAP Business Process Management OData
Today's technology environment encourages openness of systems. Data generated by a system should be easily accessed by third-party applications. It's in that spirit that the SAP BPM API was made available. Unfortunately, the SAP BPM API only worked from within SAP NetWeaver. In an effort to achieve true openness, it was important to make the functionalities provided by the SAP BPM API accessible from outside of SAP PO by using well-adopted standards.
That is why , the SAP BPM Open Data Protocol (known as SAP BPM OData or OData API) functionality was introduced since SAP NetWeaver 7.3 EHP 1 SP 09. SAP BPM OData is a REST-based set of services that provides the same functionality as the SAP BPM API. It's an OData wrapper of the SAP BPM API. A series of URLs are available to access it externally.

Note
To find out more about OData, refer to www.odata.org.

Because the SAP BPM OData is REST based, the following principles apply:


                It can be accessed via HTTP.
            

                Each SAP BPM OData functionality is exposed by way of a special URL.
            

                You'll need to authenticate with a valid UME user. The user will need to have the required roles and actions on his profile to perform tasks in SAP BPM. In general, the user needs to have the SAP_BPM_ODATA and SAP_BPM_ODATA_INBOX roles assigned.
            

                Inputs to the SAP BPM OData services can be provided in JavaScript Object Notation (JSON) or XML.
            

                Depending on the functionality used, different HTTP methods can be used (GET, POST, PUT, and DELETE).
            

The base URL for SAP BPM OData is http://<hostname>:<port>/bpmodata.
Depending on the function that you want to perform using SAP BPM OData, extra characters need to be added after the base URL. The extra information after the URL has the following general format:
/<service_name>/<path_segment(s)>/<OData_resource_path_and_query_options>
The URL variables can be explained as follows:


<hostname>  The hostname of SAP PO.
            

<port> The port of SAP PO.
            

<service_name>  The service or feature to be called. A number of services are available in SAP BPM OData. Some of these services will be explored in the next section.
            

<path_segment(s)>  Each service has a different set of path segments. Note, however, that the <path_segment> isn't mandatory for all service types.
            

<OData_resource_path_and_query_options> The resource path specifies the operation to be performed on the service. The query options contain the data that needs to be queried or passed to the operation.
            

In addition, note that SAP BPM objects have a unique identifier assigned to them during runtime. These IDs are also used in SAP BPM OData to uniquely refer to these objects.
11.6.1    OData Services for Tasks and Task Data
SAP BPM OData supports OData services for tasks, task data, value help, and processes. As an illustration, we'll explore the tasks and task data services in the next sections.
OData Services for Tasks
This service can be used to perform different types of actions on tasks, such as retrieving the list of available tasks, reading their data, and claiming and releasing them. There also are many more features included in this service.
This service is represented by the service named tasks.svc. As a result, the base URL becomes http://<hostname>:<port>/bpmodata/tasks.svc.
For a list of URIs available for the tasks service, refer to http://bit.ly/2hKWg7A.
OData Services for Task Data
This service can be used to read data of a task and perform operations such as reading the data of the task's input and output and completing a task.
This service is represented by the service named taskdata.svc. As a result, the base URL becomes http://<hostname>:<port>/bpmodata/taskdata.svc.
For a list of URIs available for the task data service, refer to http://bit.ly/2uq3m7t.
11.6.2    Error Handling
When unexpected circumstances are encountered during an OData request, a response is returned from SAP PO with an HTTP error status code. The fault response also generally contains a log ID that can be used in the Log Viewer application to further investigate the cause of the exception.
For a full list of possible HTTP status codes that might be returned by the OData service and their meanings, refer to www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.









11.7    Using the Push API to Access SAP BPM Lifecycle Events
Extending on the concepts discussed in Section 11.6, the SAP BPM API provides the facility and the flexibility to use your SAP BPM data/events in different ways. It's possible to externally (outside SAP BPM) access the data related to process and task execution. Imagine you've built a custom application that needs to raise a specific alert as soon as the business process (built in SAP BPM) has reached a certain step.
To enable this feature, SAP BPM publishes different events occurring during the execution of a processes or tasks using Java Message Service (JMS). As things currently stand, you can access the published events via two mechanisms:


                Message Driven Bean (MDB)
            

                JMS API
            

Each of these mechanisms will be discussed in the following sections.

Notes
For SAP BPM events to be published, all Java Enterprise Edition (JEE) services in com.sap.glx.core.svc starting with the name eventlog.publish.jms should be activated with the Custom Calculated Value of true in the SAP NetWeaver Administrator, as shown in Figure 11.30.

Figure 11.30    Setup of Services to Publish SAP BPM Events

11.7.1    Accessing Events through a Message Driven Bean
With this approach, it's possible to use an EJB DC. If you're a Java developer, this is one of the easiest way to access the events. Following is a list of high-level steps required to consume an event using a MDB:


                    Ensure that when creating the DC, the following dependencies are added:
                    

tc/bpem/facade/ear (public part API), which is part of the BPEM-FACADE SC
                        

engine.jee5.facade, which is part of the SC ENGFACADE


tc/je/sdo21/api, which is part of the SC ENGFACADE




                    Create a new Java class that extends the abstract class com.sap.jms.api.AbstractBPMMessageListener.
                

                    Use the annotation as indicated in the example in Listing 11.3.
                    @MessageDriven(activationConfig = {@ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),@ActivationConfigProperty(propertyName = "messageSelector", propertyValue = SELECT_EVENT_PROCESS_STARTED + " OR " +SELECT_EVENT_PROCESS_COMPLETED + " OR "+ SELECT_EVENT_PROCESS_CANCELED + " OR "+ SELECT_EVENT_USERTASK_CREATED + " OR "+SELECT_EVENT_USERTASK_COMPLETED + " OR "+ SELECT_EVENT_USERTASK_CLAIMED + " OR "+ SELECT_EVENT_USERTASK_CANCELED + " OR "+ SELECT_EVENT_USERTASK_ACTIVATED + " OR "+ SELECT_EVENT_SERVICETASK_STARTED + " OR " + " OR "+ SELECT_EVENT_USERTASK_DELEGATED + " OR "+ SELECT_EVENT_USERTASK_DELEGATED + " OR "+SELECT_EVENT_SERVICETASK_COMPLETED + " OR "+ SELECT_EVENT_INTERMEDIATE_MESSAGE_TRIGGERED + " OR "+SELECT_EVENT_CALLACTIVITY_STARTED + " OR "+ SELECT_EVENT_CALLACTIVITY_COMPLETED) }, mappedName = AbstractBPMMessageListener.JMS_TOPIC_NAME)+ SELECT_EVENT_CALLACTIVITY_STARTED + " OR " + SELECT_EVENT_CALLACTIVITY_COMPLETED + " OR " + SELECT_EVENT_PROCESS_SUSPENDED+ " OR " + SELECT_EVENT_USERTASK_SUSPENDED + " OR " + SELECT_EVENT_USERTASK_IN_ERROR) }, mappedName = AbstractBPMMessageListener.JMS_TOPIC_NAME)
Listing 11.3    Example Annotation


                    The methods of the class created in step one can be overwritten to suit your needs. An example is given in Listing 11.4.
                

@Overridepublic final void onBPMEvent(final BPMEventMessage bpmMessage) {   // process bpmMessage} @Overridepublic void onBPMProcessEvent(final BPMProcessEventMessage bpmMessage) {   // process bpmMessage}; @Overridepublic void onBPMTaskEvent(final BPMTaskEventMessage bpmMessage) {   // process bpmMessage};
Listing 11.4    Standard Methods of the Class com.sap.jms.api.AbstractBPMMessageListener

Notes
The class BPMEventMessage used in the methods in represents an instance of an event that occurred in SAP BPM. It's therefore possible to extract information such as type of event, date and time, and a unique key for the related entity (process or task). If you want to extract detailed data about the process or task, you can use com.sap. bpm.pm.api.ProcessInstanceManager or com.sap.bpm.tm.api.TaskInstanceManager, respectively. Furthermore, you can access the original JMS message by using the getJmsMessage method on the BPMEventMessage object.

Finally, it's important to note that using an MDB isn't always an option because, in some cases, more control is required for processing the events. The next alternative is to use the JMS API.
11.7.2    Accessing Events through a Java Message Service API
You can access TopicConnectionFactory and the topic from the JNDI by their names. There is plenty of information available on https://help.sap.com on how to use the JMS API. Please refer to it for more details. The aim of this section is to give you some pointers to consider when accessing SAP BPM-specific events and using the JMS API.
As a starting point, to consume the events using the JMS API, you need to retrieve an instance of the BPMJmsManager by calling com.sap.bpm.api.BPMFactory.getBPMJmsManager().
Furthermore, the SAP BPM API makes available a number of string constants that you can use to look up names and retrieve the TopicConnectionFactory and topic via the JNDI. See Table 11.6 for the constant string names to be used for each object type.




                            Object
                        

                            Constant String
                        





javax.jms.TopicConnectionFactory


com.sap.bpm.jms.api.BPMJmsManager.JMS_TOPIC_CONNECTION_FACTORY_NAME




javax.jms.Topic


com.sap.bpm.jms.api.BPMJmsManager.JMS_TOPIC_NAME




Table 11.6    Instances and Their Corresponding Constant String
Furthermore, it's also possible to retrieve the same objects listed in Table 11.6 using methods, as follows:


                    Use BPMJmsManager.getBPMJmsConnectionFactory() to retrieve an instance of javax.jms.TopicConnectionFactory.
                

                    Use com.sap.bpm.jms.api.BPMJmsManager.getBPMJmsTopic() to retrieve an instance of javax.jms.Topic.
                

Lastly, it's also possible to access the content of the JMS message by using the com.sap.bpm.jms.api.BPMJmsManager.mapJmsMessageToBPMEventMessage(Message) method. This will return an instance of the object BPMEventMessage.









11.8    Debugging and Troubleshooting SAP BPM Processes
In learning to use SAP BPM, mistakes and errors are bound to show up in our processes. This section will focus on how to debug or troubleshoot such errors. When debugging, you can stop at every step of a running process and analyze its data to investigate an error that occurred.
SAP BPM developers are able to debug their SAP BPM processes from SAP NetWeaver Developer Studio. When using SAP NetWeaver Developer Studio to debug, the following considerations apply:


                The Debug perspective needs to be used due to its specialized views that facilitate troubleshooting.
            

                Breakpoints need to be placed on the SAP BPM process.
            

                Breakpoints can be added to events, activities, and gateways.
            

                It might be necessary to analyze the process context data (the values stored in different data objects).
            

                Specialized debugging functionscan be used, including stepping over, stepping into, and stepping out of the flow objects and resuming the execution.
            


Note
Debugging isn't possible under the following circumstances:


                    When using a cluster SAP PO installation
                

                    If the SAP BPM process contains activities with a loop or an embedded subprocess
                

Furthermore, before using the debug functionality, the following prerequisites apply:


                    SAP NetWeaver AS Java must only have one server node.
                

                    The process to be debugged must have already been deployed to the SAP PO server.
                

                    The user used to debug needs to have the SAP_BPM_Debug role assigned.
                


11.8.1    Place Breakpoints in the Process
To properly debug a process, it's useful to place breakpoints at the relevant flow objects. To place a breakpoint, follow these steps:


                    In SAP NetWeaver Developer Studio, expand the SAP BPM DC, and open the applicable process.
                

                    Right-click on the flow object that you want to attach the breakpoint to, and select Toggle Breakpoint. Note that a blue dot will be placed next to the object to indicate that the breakpoint has been set. You can remove the breakpoint by selecting the Toggle Breakpoint option one more time (Figure 11.31).
                

                    Build and deploy the process to the SAP PO server.
                


Figure 11.31    Placing a Breakpoint on an Activity before Debugging the Process
11.8.2    Add a Debug Configuration
To debug a process, some debug configuration settings are needed in SAP NetWeaver Developer Studio. To configure SAP NetWeaver Developer Studio for debugging, follow these steps:


                    In SAP NetWeaver Developer Studio, make sure that you're in the Process Development perspective.
                

                    From the top menu, select Run • Debug Configurations (Figure 11.32 1).
                

                    In the new pop-up, select the Process node of the left panel, and click on the New button 2.
                

                    Fill in details such as the configuration name, select the project or DC containing the process, and select the applicable process.
                

                    If the process requires a specific XML/payload input, then you can provide it in the Arguments tab.
                

                    Click on the Run button to start debugging.
                    
Figure 11.32    Creating a Debug Configuration in SAP NetWeaver Developer Studio


                    You might need to provide your login credentials. SAP NetWeaver Developer Studio will automatically switch to the Debug perspective. Your screen should be similar to the one shown in Figure 11.33.
                


Figure 11.33    SAP NetWeaver Developer Studio Debug Perspective
Note the following details about the options shown in Figure 11.33:


                    Use this menu bar 1 for debugging options such as resume, terminate, step over, and step into. For instance, you can move to the next step of the process by selecting the Step Over option.
                

                    Use this area 2 to watch the context data values as they change at each SAP BPM process step.
                

                    As you use the options at 1, the arrow at 3 will keep moving to show at which step the process currently stands.
                










11.9    Tuning SAP BPM-Related Performance Parameters
After installing SAP PO, it's important to adapt some parameter settings to suit your environment and performance needs. There are a lot of aspects to take into consideration. The subject of tuning SAP PO can be a book in its own right, so this section will only focus on a few settings that are relevant to SAP BPM's actions and that can be changed without needing to restart the server. These settings manage the behavior of the queues used to hold all SAP BPM actions before they can be processed by one of the cluster's nodes. You can access these parameters from SAP NetWeaver Administrator via the following steps:


                Go to http://<hostname>:<port>/nwa/sys-config.
            

                From there, select the Services tab, and filter for a service called Galaxy Core Service under the Name column.
            

                Select the result; the Property tab will appear at the bottom of the screen.
            

                In the Properties tab, you can filter for any parameter that you want to change and tune for your performance needs (Figure 11.34).
            


Figure 11.34    Tuning and Modifying the SAP BPM Action Parameters
Table 11.7 includes a list of parameters and an explanation of the roles they play.




                        Parameter
                    

                        Description
                    





asyncactionqueue.polling.interval


                        The duration in milliseconds that cluster nodes need to wait before polling to check if there are asynchronous actions in the queue that can be processed. The polling can be disabled by setting the parameter to a negative value. Using zero (0) as a value will make the cluster node immediately pool. Note that it's highly recommended not to set this value to zero or a negative number, unless you're aware of the negative consequences that might result from it. The default value is 5000.
                    



asyncactionqueue.execution.maxattempts


                        When an action goes into an error state, it's automatically retried a couple of times. This parameter specifies the maximum number of times that the actions should be automatically retried before no further attempts are made. The default value is 50.
                    



asyncactionqueue.polling.timeout


                        The time after which a cluster node stops its task of requesting actions from a queue.
                    



asyncactionqueue.execution.chunksize


                        This parameter determines how many actions need to be polled at the same time from the queue. This parameter is very useful if you're expecting a big number of messages that need to be correlated. The default value is 1000.
                    



Table 11.7    SAP BPM Action Parameters to Tune the Behaviors of the Queues

Warning
Don't change any of the default settings for the parameters in Table 11.7 unless you're clear on the consequences for your environment. The default settings should be fine for most installations.










11.10    Best Practices for Your SAP BPM Application
This section of the chapter lists aspects that need to be taken into consideration when developing SAP BPM processes based on SAP PO. The best practices listed in the coming sections should be considered as general guidelines during your development activities.
11.10.1    BPMN, Mapping, and Parallelism
When modeling a process, keep the following considerations in mind:


                    It's preferable to keep your BPMN model as simple as possible. Try to limit the total number of process steps to below 50.
                

                    Keep the signatures of interfaces used for SAP BPM as small as possible.
                

                    It's better to have small mappings rather than big ones that have more than 50 fields mapped.
                

                    Keep the mapping complexity as low as possible. If not well-designed, a mapping can cause bad performance in SAP BPM.
                

                    When mapping structures, use the move-corresponding feature when possible.
                

                    Avoid using the same message trigger for multiple processes. It's better to create a different trigger for each process (when possible).
                

                    Whenever a group of steps can be reused by multiple processes, consider creating a subprocess that can be referred to by other processes.
                

                    Consider using parallel processing or a parallel split gateway when some actions or steps in your process can be performed concurrently. This will reduce the time needed to complete your process. However, be aware that parallelism might lead to high memory consumption, so use it carefully!
                

11.10.2    Task Related
Tasks have a life of their own and might need to stay active for a long time. Keeping the total number of tasks on the lower side can dramatically improve your performance. Consider the following actions:


                    Create human tasks with reusability in mind. It's better to combine similar tasks into one and reuse that task for multiple human tasks.
                

                    When reusing the same task for many human tasks, you might need to use parameterized subjects and texts to give it more context.
                

11.10.3    Gateways
When your SAP BPM process uses a gateway, consider the following aspects:


                    When using a split gateway, pay special attention when updating the same data object concurrently, which can cause locks, data inconsistencies, and decreased performance.
                

                    When dealing with an exclusive gateway (or exclusive choice), make sure that the conditions are designed in such a way that one gate will always be taken. Setting a default gate is a good practice.
                

                    When using an event-based choice, ensure that you have a sanity check in case none of the events occurs. If none of the specified events occur, then the process might run forever! Consider including an event timer in the list of events to avoid keeping the process active for an undetermined time.
                

11.10.4    Looping
Looping allows a group of steps to be repeated multiple times. When dealing with loops in your process, avoid creating infinite loops. This may occur when there are no proper conditions to exit the loop. Consider using any combination of counter-data objects, timer events, and gateways to exit your loop.
11.10.5    Data Object
Data objects are used to hold process data. This data is modified and manipulated across the process lifecycle. Consider the following points while dealing with data objects:


                    Give meaningful names to your data objects. Others should be able to determine what the data object is used for from its name.
                

                    Only create data objects in a process when needed. Avoid large data objects by not adding unnecessary fields.
                

                    Use defensive checks on data types in case you're expecting some constraints. For example, instead of directly accessing the second item in a collection, it might be a good idea to first check if an item at position 2 exists in the collection and isn't null. These checks might save you from unnecessary runtime exceptions.
                

                    If the same data object needs to be accessed in parallel, then consider splitting the data object into smaller ones. In that way, each parallel branch only accesses the data pertinent to it.
                

11.10.6    Correlation
Consider the following practices when dealing with correlations in your process:


                    Avoid implementing you own logic to correlate messages; use the standard features (in start or intermediary events) to achieve correlation.
                

                    Make your correlation conditions as specific as possible to narrow the chance of unintended messages correlating to your process instance.
                

11.10.7    Error Handling
Error handling should be given attention in every process. It's important to think about all situations that might cause exceptions to an SAP BPM process and to make sure that each is correctly handled. When a high volume of errors is produced, SAP PO's performance can be severely affected in a negative way. Therefore, be aware of the following points:


                    When handling errors, make the error messages as specific as possible, and provide enough information to make life easy for the process administrator to handle the exception. This approach also aids traceability.
                

                    Whenever you use an automated or human activity, use boundary events when possible.
                

                    If many different types of errors are possible in a particular step, then use multiple boundary events to handle each exception separately.
                

                    If exceptions in different processes can be handled in the same way, then consider creating a process that handles the exception so that it can be reused by many processes.
                

11.10.8    Housekeeping
Consider regularly running some housekeeping activities to clean up and reduce the size of your database. Some of the actions to be performed include the following:


                    As your processes run, a lot of business logs are written. Remove and delete business logs to keep to database size reasonable.
                

                    Change the log level setting to a low value to write fewer logs. This is especially important for a productive SAP PO machine.
                

                    Consider archiving data of completed or canceled processes and those older than a certain period. The higher the process data volume is, the shorter your archiving period should be.
                










11.11    Exercise: Applying Advanced SAP BPM Concepts and Extensions
This exercise walks you through the process of building a custom EJB function to be used in an SAP BPM process.
In your daily development activities, you might encounter a situation in which the function that you need for your business process isn't available as one of the default functions delivered by SAP. In this situation, you can build an EJB function that can be used as a mapping function. In this exercise, we'll create our own custom function to concatenate two strings (although such a function already exists). This concatenation function has been chosen for its simplicity. The purpose of the exercise isn't to create a complex function, but rather to learn how to create a custom function.
11.11.1    Exercise Solution Approach
To create a new EJB custom function for the purpose of being used in your SAP BPM process, you need to perform the following main high-level actions:


                    Create EJB and enterprise DCs, and maintain their dependencies.
                

                    Implement the logic of the function in Java.
                

                    Build and deploy the implemented functionality to the SAP PO server.
                

                    Verify the JNDI details of the implemented function.
                

                    Use the developed custom function in your SAP BPM process.
                

The next section will focus on providing a step-by-step walkthrough of these actions.
11.11.2    Exercise Step-by-Step Solution
In the following sections, we will walk though the steps necessary to build a custom EJB function.
Create the Development Components
Follow these steps to create new DCs:


                        Launch SAP NetWeaver Developer Studio, and ensure that it's configured to point to the SAP PO server where the SAP BPM process was deployed.
                    

                        Create two DCs. In SAP NetWeaver Developer Studio, go to the Development Infrastructure perspective.
                    

                        Right-click on My Components SC, and select New • Development Component.
                    

                        Select EJB Module under Java EE (Figure 11.35), and click on Next.
                        
Figure 11.35    Selecting the DC Type


                        Proceed with the wizard, and name your DC "dc_processfunctions".
                    

                        Click on the Finish button. When asked to switch perspectives, choose the No button.
                    

                        Create another DC, this time of the Enterprise Application type. Name your DC "dc_processfunctions_ear", and then click on the Next button.
                    

                        On the next screen, leave all default options as is, and click on Next.
                    

                        On the subsequent screen, select the DCs that the enterprise application DC will depend on, which are called the referenced projects. For this example, select the DC that you previously created: dc_processfunctions. Click on Finish. When asked to switch perspectives, choose No.
                    

It's now time to set up the dependencies between the EJB DC and other DCs that are required for the purpose of creating custom EJB functions for an SAP BPM process. Follow these steps:


                        Select the previously created EJB DC (dc_processfunctions).
                    

                        Go to the Dependencies tab, and choose the Add button (see Figure 11.36).
                        
Figure 11.36    Adding Dependencies to the EJB DC


                        When the pop-up appears, enter the filtering term "*mapping*".
                    

                        From the filtering results, expand the SERVICE-COMP [sap.com] SC, select the tc/bpem/mapping/facade entry, and click on Finish (Figure 11.37).
                        
Figure 11.37    Adding the tc/bpem/mapping/facade Dependency


                        Add another dependency by filtering for "*sdo21*". From the results, expand the ENGFACADE SC, select tc/je/sdo21/api, and click on Finish (Figure 11.38).
                    


Figure 11.38    Adding the tc/je/sdo21/api Dependency
It's now time to set up the dependencies between the EAR DC and the DCs that are required for the purpose of creating custom EJB functions for an SAP BPM process. Follow these steps:


                        Select the previously created EAR DC (dc_processfunctions_ear), go to the Dependencies tab, and click on the Add button.
                    

                        Add a dependency to tc/bpem/mapping/facade as you did previously for the EJB DC. However, instead of clicking on the Finish button, click on the Next button, and select both the Deploy Time and Runtime options (Figure 11.39). Then, click on Finish.
                    


Figure 11.39    Dependencies Details Options for the Enterprise Application DC
Implement the Functionality
Now that the different DCs and the relevant dependencies have been created, it's time to create the source code needed to perform the desired concatenation function. Follow these steps:


                        Open the Java EE perspective. Open the previously created EJB DC, and right-click on ejbModule.
                    

                        From the subsequent menu, choose New • Session Bean (EJB 3.x) (Figure 11.40).
                        
Figure 11.40    Creating an EJB Session Bean


                        In the new screen that appears, provide details of the session bean, as shown in Figure 11.41. Click on Finish.
                        
Figure 11.41    Details of the Session Bean to be Created


                        A new class is created, with very few lines of code. Add the import lines presented in Listing 11.5 to your code.
                        import javax.ejb.Stateless;import javax.xml.namespace.QName;import com.sap.glx.mapping.execution.api.function.Function;import com.sap.glx.mapping.execution.api.invoker.SdoInvoker;import com.sap.glx.sdo.api.SdoRenamingHelper;import commonj.sdo.DataObject;import commonj.sdo.Type;
Listing 11.5    Import Statements


                        Now, remove the generated default constructor code presented in Listing 11.6.
                        /**     * Default constructor.      */    public ConcatFunction() {        // TODO Auto-generated constructor stub    }
Listing 11.6    Default Constructor to be Removed


                        Replace the default constructor with the source code provided in Listing 11.7.
                        private static final String NAMESPACE_FUNCTION_PARAM = " com.rojoconsultancy.process.functions/demoprocess";private static final String PARAM1 = "param1";private static final String PARAM2 = "param2";private static final String RESULT = "result";private static final String NAME_PROPERTY_INPUT_PARAM1 = SdoRenamingHelper.renameXsdElementToSdoProperty(new QName(NAMESPACE_FUNCTION_PARAM, PARAM1), false);private static final String NAME_PROPERTY_INPUT_PARAM2 = SdoRenamingHelper.renameXsdElementToSdoProperty(new QName(NAMESPACE_FUNCTION_PARAM, PARAM2), false);private static final String NAME_PROPERTY_OUTPUT_RESULT = SdoRenamingHelper.renameXsdElementToSdoProperty(new QName(NAMESPACE_FUNCTION_PARAM, RESULT), false);public DataObject invokeSdo(DataObject inputDO,SdoInvoker.InvocationContext invocationContext) {// get inputType typeInput = inputDO.getType();String string1 = inputDO.getString(typeInput.getProperty(NAME_PROPERTY_INPUT_PARAM1));String string2 = inputDO.getString(typeInput.getProperty(NAME_PROPERTY_INPUT_PARAM2));// build resultString result = string1.concat(" ").concat(string2);// set outputDataObject outputDO = invocationContext.createOutputDataObject();outputDO.setString(outputDO.getType().getProperty(NAME_PROPERTY_OUTPUT_RESULT), result);return outputDO;}
Listing 11.7    Source Code to Perform the Concatenation


                        Open the ConcatFunctionLocal.java interface file, and change it to extends Function, SdoInvoker. You also need to add the needed import lines. The result is shown in Figure 11.42.
                        
Figure 11.42    Extends Interface with Function, SdoInvoker


                        Save everything by pressing (CTRL) + (Shift) + (S).
                    

Build and Deploy to the Server
It's now time to compile and deploy your work. Follow these steps:


                        Go back to the Development Infrastructure perspective.
                    

                        Right-click on the dc_processfunctions_ear EAR DC, and select the Build option (Figure 11.43).
                        
Figure 11.43    Build and Deploy the EAR DC


                        After a successful build, right-click on the EAR DC one more time, and select the Deploy option (see Figure 11.43).
                    

Verify in the Java Naming and Directory Interface
After a successful deployment of the custom EJB function, you want to ensure that the new function correctly reflect in the JNDI and retrieve its object name. Follow these steps:


                        Go to http://<hostname>:<port>/nwa/jndi, and look up your new EJB function named concatFunction. Enter "concatFunction" as a search keyword in the Find text field (Figure 11.44).
                    

                        Select the correct entry from the returned search results.
                    

                        Copy the Object Name from the Object Info tab (see Figure 11.44). This name will be used in the next steps.
                    


Figure 11.44    Looking Up the JNDI Name of the EJB Function
Use the Custom Mapping Function in the SAP BPM Process
You now need to add the newly created EJB custom function to the SAP BPM DC that will use it. Follow these steps:


                        Launch SAP NetWeaver Developer Studio, and choose the Process Development perspective.
                    

                        Right-click on the Functions folder, and choose the New EJB Function option from the context menu (Figure 11.45).
                        
Figure 11.45    Using the New EJB Function Option


                        On the subsequent screen, name your function as shown in Figure 11.46. Be aware that the names of the parameters are exactly the same as the ones specified in the source code of the session bean.
                        
Figure 11.46    Creating an EJB Function


                        Click on the Finish button.
                    

                        The overview page of the EJB function opens (Figure 11.47). Paste the object name that you copied from the Object (JNDI) Name field in Figure 11.44.
                    


Figure 11.47    Maintaining the JNDI Name of the Custom EJB Function
After completing these steps, the newly created function is now available as part of the Rules and Functions folder and can be used normally in your SAP BPM process (Figure 11.48).

Figure 11.48    Newly Created EJB Custom Function Available to Use
Voilà! Congratulations for finishing this exercise.









11.12    Summary
This chapter introduced some advanced topics around modeling and developing SAP BPM processes. We explained that after the process has been deployed in SAP PO and depending on the type of flow objects used in the BPMN model, it might be necessary to perform extra configuration steps in SAP NetWeaver Administrator. We've also explored what is required to debug a process with errors from the SAP NetWeaver Developer Studio.
The chapter also explored the parameters to be tuned according to the needs of your environment to increase the performance of processes. After this chapter, you should be able to squeeze more musical notes out of SAP PO.
The next chapter will explore the different ways a process implemented in SAP BPM can be combined with the different available UI technologies.








12    Combining SAP BPM and UI TechnologiesIt's not a faith in technology. It's faith in people.                                                                                                            —Steve JobsFor every human activity flow object represented in a Business Process Model and Notation (BPMN) model, you can generate a user interface (UI) for the purpose of enabling a human being to interact with the SAP Business Process Management (SAP BPM) process. In the process flow, when the process context arrives at the human activity step, a task is triggered, and the UI allows the user to access the task and execute it.Different types of UI technologies can be used in combination with SAP BPM. Web Dynpro Java/ABAP, Adobe Offline forms, Visual Composer and SAPUI5 are among the types of UIs that can be generated within the process context. As of SAP NetWeaver Developer Studio 7.3 EHP 1 SP 13, you can also generate an SAPUI5 UI. Given the multitude of choices of UI technologies that can be used, we've chosen to focus on the generation of UIs using Web Dynpro Java and SAPUI5 from the process context in the SAP BPM process flow in this chapter. These two technologies can be generated based on the SAP NetWeaver Developer Studio development that you've become accustomed to in past chapters. In addition, these technologies can be directly deployed to your SAP Process Orchestration (SAP PO) server without the need to add an additional server. In real life, however, you might decide to run the supporting UI screen in another server (non-SAP PO), based on your requirements in terms of performance, load on the server, and various other reasons.
12.1    Web Dynpro Java User Interface Technology
The Java Web Dynpro technology is a toolset for building server-side business applications, and it provides the powerful feature of defining UIs in a declarative manner. Depending on the approach, platform, and types of functionalities to be supported, SAP provides two flavors of Web Dynpro: Web Dynpro for ABAP and Web Dynpro for Java.
Web Dynpro for ABAP supports the design of business applications and screens within SAP backend systems. Such applications designed with Web Dynpro for ABAP run on the SAP NetWeaver Application Server for (SAP NetWeaver AS ABAP).
Web Dynpro for Java supports the design of business applications within an SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java) engine. As a result, it can be deployed on SAP PO, which also runs on SAP NetWeaver AS Java. Web Dynpro for Java applications can be designed from scratch in SAP NetWeaver Development Studio and later linked to SAP Business Rules Management (SAP BPM). Alternatively, the Web Dynpro for Java application can be directly generated from within an SAP BPM process. The generated Web Dynpro for Java application can then later be modified to cater to additional functionalities. To generate a Web Dynpro for Java application within an SAP BPM process, a number of steps need to be performed. In the next section, building a sample SAP BPM process will be briefly discussed, including the human activity step in which the UI will be generated.

Figure 12.1    Overview of SAP BPM Process for Generating the Web Dynpro UI
For the purposes of outlining the essential steps involved in generating a Web Dynpro UI from the process context, the simple process shown in Figure 12.1 has been modeled. It consists of four modeled steps: the start step, two human activities, and an end step. The process will be triggered by a web service client tool (SoapUI). Subsequently, the data passed into the process context will be received by the Web Dynpro UI, which can be accessed in the universal work list (UWL) or via the SAP BPM Inbox.
12.1.1    Generating a Web Dynpro User Interface
A Web Dynpro UI will need to be generated to enable a user to interact with the human task in the process. The generation of a Web Dynpro UI from the process context requires a data object. The structure of the data object is used as a basis to create corresponding text fields, checkboxes, or dropdowns in the UI screen. In our sample process, a data object named DO_PurchaseOrder is used to support the UI generation. An illustrative structure of the data object is shown in Figure 12.2.

Figure 12.2    Definition Structure of the Data Object to be Used to Generate a Web Dynpro UI
To generate a Web Dynpro UI from the process context, follow these steps:


                    Select the human activity step from the process pane. The Property view appears at the bottom of the screen.
                

                    From the Property view, select the Task tab (Figure 12.3). From the dropdown, select the New option.
                

                    A wizard will appear. Provide a name for the Web Dynpro UI that will be generated, and check the Generate UI Component checkbox as shown in Figure 12.4.
                    
Figure 12.3    Creating a New Web Dynpro UI for the Human Task

Figure 12.4    Details of the Web Dynpro Task to be Created


                    Click on the Next button.
                

                    On the next page, select the Web Dynpro value from the UI Technology dropdown field (see Figure 12.5).
                    
Figure 12.5    Selecting the Web Dynpro UI Technology with a New Development Component


                    A new development component (DC) needs to be created to host the Web Dynpro developments. To create a new DC, click on the New button to the right of the Development Component dropdown (Figure 12.5). This action will launch a new wizard.
                

                    In the wizard, select the same software component (SC) for which the SAP BPM process was created (see Figure 12.6). Note that you can create the Web Dynpro DC in another SC, but then you'll need to create dependencies between the different SCs.
                    
Figure 12.6    Selecting the Software Component for the New Development Component


                    Follow the wizard by clicking on the Next button. The pop-up that appears requires some details to be filled in to create the Web Dynpro component. Fill in the name and description information, as shown in Figure 12.7. Leave the default settings for the other fields.
                

                    Follow the wizard, and click on the Finish button in the last step to conclude the creation of the new Web Dynpro DC. Now, you can carry on with the generation of a UI for the process.
                

                    Follow the wizard, and the Web Dynpro component details are prefilled automatically. You have the option to modify the values if necessary, but, in this case, there's no need to change anything from the default values (see Figure 12.8).
                    
Figure 12.7    Details of the New Web Dynpro DC

Figure 12.8    Component Details for the Web Dynpro UI


                    Click on the Next button to proceed to the next step. In this step, you need to bind data objects from the process context to the Web Dynpro component that you're about to generate.
                

                    You don't have to select all the fields of the data object. In the example presented in Figure 12.9, however, all the fields have been selected.
                    
Figure 12.9    Process Context for the Web Dynpro UI Generation


                    Click on the Finish button to complete the task of generating the Web Dynpro UI from the process context.
                

                    Verify that the newly generated Web Dynpro UI was selected by choosing the human activity from the SAP BPM process flow. You'll then see the Property tab displayed at the bottom of the screen. Click on the Task tab, and check that the newly generated Web Dynpro UI is assigned to the Task field (Figure 12.10).
                

The generation of the Web Dynpro UI from the process context is now completed. However, a number of post-configurations still need to be performed, which we'll discuss in the next section.

Figure 12.10    Created and Assigned Web Dynpro UI to Task
12.1.2    Post-Configuration Steps
We completed the process of generating a Web Dynpro UI from the process context, and now the graphical view of the Web Dynpro UI can be reviewed and modified. Thereafter, we can proceed with performing post-configuration steps for the UI as follows:


                    Switch to the Web Dynpro perspective of SAP NetWeaver Developer Studio.
                

                    Navigate through the DC you created earlier, and follow the path [LocalDevelopment] hradmin • Components • OrderDetailsComponentView (see Figure 12.11).
                

                    Double-click on OrderDetailsComponentView to view the UI screen that was generated based on the process data object, as shown in Figure 12.12.
                


Figure 12.11    Web Dynpro UI Components and Views

Figure 12.12    Web Dynpro UI Component View Details
Now that the Web Dynpro UI has been created, it's time to assign principals to its task. Assigning a principal to the UI task specifies which principals (user, group, or role) are allowed to take action on the task, including claiming and completing the task. Follow these steps to assign principals to the human task:


                    Switch back to the Process Development perspective, navigate through the Process Modeling object, and expand the Task folder, as shown in Figure 12.13.
                    
Figure 12.13    Task Folder Displaying the Web Dynpro UI for Task Execution


                    Double-click on the WebDynpro UI component. From the screen that opens, select the roles as shown in Figure 12.14. From the first box, Potential Owners, select the Choose one or more UME principals radio button, and click on the Choose button.
                    
Figure 12.14    Assigning Users for Web Dynpro UI Task Execution


                    A new pop-up screen appears. From the new screen, select the User option from the Principal Name dropdown, and enter the user name that you want to act as a potential owner for the human task.
                

                    Click on the Search button to find the user in the user management engine (UME). After finding the user, click on the Add --> button (see Figure 12.15).
                

                    Click on the OK button.
                    
Figure 12.15    Searching for Users from the UME to Assign to the Task


                    Now that the user has been added as a potential owner of the process, when the processing of an SAP BPM process reaches the human activity, it creates a task that can be seen by all potential users. The user can access this via the UWL of SAP Enterprise Portal or the SAP BPM Inbox.
                

                    To complete the process of generating a Web Dynpro UI, you need to perform mappings of data flows between the Web Dynpro component and the process data object. Select the human task, and in the Property view, choose the Inbound Mapping subtab (Figure 12.16).
                

                    Map the fields from the data object to the UI request context of the Web Dynpro UI (Figure 12.16).
                


Figure 12.16    Mapping for Data Input and Output from and to the Web Dynpro UI
Depending on your requirements, you might also need to perform mappings in the Outbound Mapping subtab to move the details captured by the user (in the UI) back to the process context.
After these steps are completed, the SAP BPM process can be built and deployed to the server.

Note
As the SAP BPM process is deployed to the server, the generated Web Dynpro UI DC is also automatically selected for deployment. This is because SAP NetWeaver Developer Studio detects a link or dependency between SAP BPM and Web Dynpro DCs.










12.2    Integrating SAPUI5 into an SAP BPM Process
SAPUI5 is a UI technology that leverages the power of HMTL5 and JavaScript to provide a rich user experience. SAPUI5 is more frequently used by SAP in recent times to design robust business applications that can be accessed using standard web browsers, smart devices, tablets, and so on.
Please note that the goal of this section isn't to teach you how to develop UIs using SAPUI5, but rather to demonstrate how it can be integrated with SAP BPM to improve the user experience in a simple manner.

Note
For more information on working with SAPUI5, refer to the book SAPUI5: The Comprehensive Guide by Christiane Goebels, Denise Nepraunig, and Thilo Seidel (SAP PRESS, 2016, www.sap-press.com/3980).

Let's start with a very high-level description of some basic SAPUI5 concepts.
12.2.1    SAPUI5 Technology Platform
SAPUI5 is based on JavaScript and open-source jQuery. From an architectural point of view, the SAPUI5 runtime is a client-side HTML5 rendering library with a large set of Rich Internet Application (RIA)-like standards and extension controls. It uses the model-view-controller (MVC) concept and is equipped with a large number of very rich standard UI controls. It also provides a lot of themes that can be adapted with a Theme Designer tool. The libraries that it uses for rendering controls comply with OpenAJAX. SAPUI5 is a modern framework that relies on standards such as jQuery, HTML5, JavaScript, Cascading Style Sheets (CSS), and others, which helps it to better support modern browsers and to enhance the experience with SAP applications. The support for all of these standards makes SAPUI5 platform independent. SAPUI5 can consume data from a variety of sources, such as XML, JavaScript Object Notation (JSON), and OData.
An Eclipse plugin provided by SAP supports developers in creating SAPUI5 applications. To create an SAPUI5 application, the types of UI libraries to be used are dependent on which device and platform this application is intended for. Some of these important libraries and their features are as follows:


sap.ui.core Contains the framework classes, such as Control and Element. It provides some controls, such as HTML for embedding native HTML and the model and data-binding classes.
                

sap.ui.commons Contains basic controls, such as Button, Label, Image, and Link. More complex controls (e.g., Accordion, DropdownBox, and several controls for menu implementation) are also included. sap.ui.commons also extends to layout controls, such as AbsoluteLayout, MatrixLayout, BorderLayout, and VerticalLayout.
                

sap.ui.table Contains DataTable, a table type that is available to support an end-user-friendly display and interaction on the table content.
                

sap.ui.ux3 Contains container controls, including Shell, ExAct, Thing Inspector, Feed, and DataSet.
                

The next section will briefly describe the MVC paradigm.
12.2.2    Model-View-Controller Concept
The MVC paradigm is used by SAP to implement its UI technologies such as Web Dynpro and, more recently, SAPUI5. This concept is also used in the design of SAPUI5 applications. One of the main goals of the MVC pattern is to achieve a separation of concerns between different tiers and layers of a UI application.
MVC provides the important ability to separate users' interactions from information representation. This is made possible through the capabilities of the three parts of this paradigm (see Figure 12.17):


Model The model layer contains the functional logic of an application. It constitutes the services and data layers of the application.
                

View The view supports defining and rendering the UI. This is the presentation layer. It retrieves data from the model layer and displays it to the user. The view represents the output of the application to the user.
                

Controller The controller reacts to view events and user interactions by modifying the view and model layers.
                


Figure 12.17    The MVC Paradigm Architecture
Ideally, data binding in the UI supports the separation of these three components in such a way that the definition of the UI (view), the data visualized by the application (model), and the code for the business logic for processing the data (controller) is done seamlessly. Separating these elements helps to provide better readability, maintainability, and extensibility. It also allows for making changes to the view without touching the underlying business logic while defining several views of the same data. The MVC approach helps to support the flexibility of working on these different layers independently. Naturally, within the MVC design, views and controllers usually have a 1:1 relationship, but it's also possible to have controllers without a UI. Such controllers are called application controllers. Views can also be created without controllers. In SAPUI5, a view is an SAPUI5 control and can have or inherit from an SAPUI5 model.
12.2.3    SAPUI5 Components
In building SAPUI5 applications, components form an important part of the architecture. These components constitute reusable parts that can be used in multiple SAPUI5 applications. A typical SAPUI5 application can use multiple components remote to the location where it's running. This makes development of SAPUI5 components agile, such that components developed by one team can be used by other teams across the board and in different projects. The component model helps in the categorization or delineation of similar parts of the application into a single representation or component. An important advantage of this segmentation is the ease of understanding the structure of an application and the readability of the code as well as ease of maintenance. Technically speaking, the SAPUI5 platform provides two types of components:


Faceless components As the name suggests, these faceless components don't have a UI and are used for some sort of system-system interaction typified in a service that delivers data from a backend system.
                

UI components UI components are a screen area or element in the UI. The UI components are the basic building blocks of a UI. A human uses them to interact with the application. They include things such as buttons or shells and their respective settings and metadata.
                

Both of these types of components are part of the sap.ui.core.Component class.

Note
The sap.ui.core.Component class is the base class for the faceless and UI components. The functionality of a component can be extended by inheriting from the base class and enhancing the required behavior.

The structure of a component can be viewed and defined as a folder. The name assigned to a folder during its creation defines the component name. It contains all optional and required resources that are to be used in the component, except for the required SAPUI5 libraries and child components. A couple of resources relate to the CSS, internationalization files, views, and images. When a component is created, certain files are compulsory, including the following:


component.js This represents the component controller and provides the runtime metadata (properties, aggregation, events) and the component methods.
                

component.json This is the component descriptor and also contains the design-time metadata. The file isn't loaded during runtime.
                

Note that all paths contained within a component are paths relative to the component.js file and not to the index.html file.
12.2.4    Other SAPUI5 Concepts
In addition to SAPUI5 components discussed previously, there are a few others that play important roles in developing an SAPUI5 application. These concepts and how they differ from SAPUI5 components are as follows:


Composite controls Composite controls and SAPUI5 components are similar in the sense that they provide a set of controls behind a single interface. A point of difference is that composite controls can be reused within control development and allow for including existing controls in a complex control, whereas SAPUI5 components are to be reused in application development.
                

UI library The UI library is the deployable unit around controls. Controls are never deployed standalone but always as part of a control library. Components, however, are self-contained and should not be used to deploy controls.
                

Notepad control A notepad control can be created with JavaScript on the fly. Notepad controls have all the characteristics of a control.
                

Application An application has a single URL to start it and groups everything belonging to the application in a deployable unit. In addition, because the knowledge of the required libraries, scripts, and additional style sheets is contained in index.html, this makes it impossible to embed one application into another.
                

12.2.5    Integration Steps
In the past, creating and consuming a human task from SAP BPM using a custom UI involved the use of the SAP BPM Java application programming interface (API). However, the introduction of SAP BPM OData makes integrating SAPUI5 into an SAP BPM process an easier task. This section will provide a guide for how to execute a human task from an SAP BPM process using SAPUI5 technology.

Prerequisites
To generate a human task using SAPUI5 technology, SAP NetWeaver Developer Studio 7.3 EHP 1 SP 13 and above should be used at a minimum.

To better explain the steps involved in integrating SAPUI5 with SAP BPM, we'll use a simple SAP BPM process scenario as an example.
Sample SAP Business Process Management Process Scenario
For simplicity's sake, we'll keep the sample process scenario used for this exercise very basic because most SAP BPM concepts were explored earlier in Chapter 10 and Chapter 11. The essence of this section is only to focus on a human activity step of a process. Therefore, the SAP BPM process will only consist of the following three step types:


                        Start event
                    

                        Human activity
                    

                        End event
                    

Assume that the process simulates a manager of an organization receiving an order request that he needs to approve. The manager will then be able to complete the task via an SAPUI5 UI. The order request is made by an employee, but that part of the process is excluded from our sample UI generation using SAPUI5.
The BPMN representation of this simple process is presented in Figure 12.18.

Figure 12.18    Sample SAP BPM Process with Human Activity to a Consumer SAPUI5 Application
Generating an SAPUI5 DC from SAP BPM
After completing all other SAP BPM process configuration, perform the following actions to generate the SAPUI5 UI from within the process:


                        Create or import an XSD schema to be assigned to the data object that will be used to hold the process's data. For this guide, a service interface from SAP PO's Enterprise Service Repository (ES Repository) was imported and assigned to the process.
                    

                        Select the human activity Approve from the process. In the Property section and the Task subtab, choose the New option from the Task dropdown menu (Figure 12.19).
                        
Figure 12.19    Creating a New SAPUI5 Application from SAP BPM


                        A new wizard will start to facilitate the generation of the SAPUI5 application. Follow the wizard to create a DC for SAPUI5. Name the task as shown in Figure 12.20.
                        
Figure 12.20    Naming the SAPUI5 Task


                        For the UI Technology dropdown menu, select SAPUI5. If a DC needs to be created, choose the New option, and follow the wizard to create a new DC (Figure 12.21).
                        
Figure 12.21    Selecting the SAPUI5 Technology


                        Follow the wizard until the last step to select the data object to be used as the basis to generate the SAPUI5 UI (Figure 12.22).
                    

                        After you click on the Finish button, the SAPUI5 technology generates its own data type from the original data object within the process context. The result is presented in Figure 12.23.
                        
Figure 12.22    Process Context Details for Generating the SAPUI5 Application

Figure 12.23    Custom SAPUI5 Data Types Generated


                        Open the Tasks folder under the SAP BPM project tree, and select the Roles tab. From there, select one or more users from the UME to be assigned to this task as potential owners (Figure 12.24).
                        
Figure 12.24    Assigning a Task's Potential Owner to SAPUI5 for Task Execution


                        From the SAP NetWeaver Developer Studio tool, switch to the Web perspective to view all the files that have been generated for the SAPUI5 DC. Navigate to the DC project structure, and note the generated folders, libraries, JSON, and index files (Figure 12.25).
                        
Figure 12.25    JavaScript Code Generated for the SAPUI5 Controller


                        The created SAPUI5 DC will need to be deployed to the SAP PO server as an Enterprise Application Archive (EAR) file. You need to create an EAR DC and add the SAPUI5 DC as a dependency to it. In Figure 12.25, you can see an EAR DC named dc_sapui5_ear. Figure 12.26 shows that dc_sapui5 has been added as a dependency to dc_sapui5_ear.
                        
Figure 12.26    Creating Dependency of the EAR DC to the SAPUI5 DC

Note
Extra steps need to be taken to ensure that the human task notifications of SAP BPM are sent to the SAP BPM Inbox. In SAP PO, by default, the value for the notification_task_inbox is set to the UWL. However, if you want the notification to be consumed by the SAP BPM Inbox, then this value will need to be set to bpm_inbox instead.



                        Configure the notification_task_ inbox property settings by navigating through the Java system properties of SAP NetWeaver Administrator, and change the default value from uwl to bpm_inbox, as shown in Figure 12.27. Select the notification_task_ inbox property, and click on the Modify button to be allowed to change its value.
                    

It's finally time to build and deploy the SAP BPM process and the EAR DCs. Building and deploying the EAR DC will automatically perform the same actions for the SAPUI5 DC because of the dependency that exists between them.
After the DCs have been deployed, the SAP BPM process can be started from the Process Repository application in SAP NetWeaver Administrator.
The steps described in this section highlighted the activities needed to generate an SAPUI5 application from within an SAP BPM process context. In the next steps, we'll perform a test to complete a task from our SAPUI5 application using SAP BPM Inbox. After an employee triggers an order request from a web client, this data is passed to the SAP BPM process. The manager can then view and complete the task that has been assigned to him via the SAP BPM Inbox.

Figure 12.27    SAP NetWeaver Administrator Settings for notificationTask from uwl to bpm_inbox

Note
The URL of the SAP BPM Inbox to view and complete the SAPUI5-based task is http://<hostname>:<port>/bpminbox.
The following roles should be assigned to a user for that user to access the SAP BPM Inbox:


UnifiedInboxUserRole allows the user to view the list of tasks and their details in the SAP BPM Inbox.
                        

com.sap.bpem.Enduser enables users to manage and work on the task.
                        


Proceed to the SAP BPM Inbox to claim the employee task and fill in the details. After the employee task is completed, you can claim the manager's task and complete it, as shown in Figure 12.28.

Figure 12.28    SAP BPM Inbox Tasks for SAPUI5
Finally, to complete the task from the SAPUI5 application, open a web browser, and go to http://<hostname>:<port>/bpminbox. An example of how the final result looks in the browser can be seen in Figure 12.29.

Figure 12.29    Completing a Task from the SAPUI5 Application via the Web Browser
The manager can preview the details filled or change any of the previous values passed into the process by the employee and then complete the task.
In the previous paragraphs, we discussed the basic steps involved in executing a human task within an SAP BPM process using the SAPUI5 technology. Note that the SAPUI5 application generated within the process context can be modified and extended to meet the business and functional requirements desired.
In the next section, we'll explore alternative UI technologies that can be used in combination with SAP BPM.









12.3    Other User Interface Technologies
So far, we've discussed two UI technologies for consuming human tasks within an SAP BPM process. In this section, we provide an overview of two additional UI technologies that can be used to consume human tasks within SAP BPM. Bear in mind that these other technologies will only be presented from a high level because they don't fall under the core objectives of this book. However, we feel that it's important to mention them so that you know all of your options.
12.3.1    Visual Composer
Visual Composer is a UI technology that can also be used within an SAP BPM process to consume human tasks. It can be generated directly from within SAP BPM process modeling from the process context. SAP has described Visual Composer as a powerful tool that business process experts can easily use to model applications and prototypes without having to write a single line of code. The advantage of using Visual Composer is that it can be used to build new applications by business process specialists, without writing code. This aids an iterative development to support a company's dynamic business processes. Visual Composer helps bridge the gap between the business process expert and IT, thus reducing the need for expensive consulting services and lowering the total cost of ownership for the company. The approach used to link Visual Composer to SAP BPM is pretty much the same as the one used for Web Dynpro Java.
12.3.2    Adobe Offline Forms
Adobe offline forms can be integrated into an SAP BPM process to consume human tasks within the process. This provides the ability to complete tasks assigned to users while offline. However, creating an Adobe offline form is normally done outside of the SAP NetWeaver Developer Studio modeling environment. Using Adobe offline forms in tasks is a convenient way to design a collaborative process in which the following conditions apply:


                    Certain tasks are executed offline.
                

                    Offline form completion and submission don't require logging in to the portal.
                

                    Paper-based processes need to be replaced or facilitated.
                

                    Process input depends on information collected offline.
                

SAP BPM enables you to integrate Adobe offline forms into your business process by wrapping them in tasks in the Process Composer, which is in the SAP BPM design time. The offline form is assigned to a certain task as a UI component. Form templates are stored in a dedicated folder in the Enterprise Content Management (ECM) Repository, which you access through the SAP Enterprise Portal drive. Forms in SAP BPM are schema based. The Adobe LiveCycle Designer is used to import form data from the XML Schema Definition (XSD) schema and to create a form template, which is an XML Data Package (XDP) file.
Forms are then sent as a PDF attachment in an email message sent to potential owners of the task. At runtime, the actual owner of the task submits the form as a PDF attachment via email back to the SAP BPM framework. Even though there may be a number of potential owners of the task, only one user can complete it. To design an Adobe offline form, the following high-level steps need to be performed:


                    Design the form template.
                

                    Store and access the offline form.
                

                    Assign the offline form to the SAP BPM task.
                

                    Configure the email submission of forms.
                

                    Perform runtime-related activities and task management.
                

12.3.3    Support for Custom User Interface Technologies
You can integrate almost any UI technology of your choice with SAP BPM. The main prerequisites are as follows:


                    The UI technology in question has the capability to access and consume the Java-based or OData API provided by SAP BPM.
                

                    Technologies that are Java-based and can be deployed to SAP NetWeaver AS Java.
                

These custom UI technologies can make use of the SAP BPM API to access SAP BPM data and interact with it. The provided API facilitates reading the complete data of a task, including the ability to complete it. Be aware that because the interaction between the custom UI and SAP BPM is achieved through the SAP BPM API, the accessible data and functionalities are restricted by what the SAP BPM API supports. Refer to Chapter 11 to find out more about the SAP BPM API.
To use a custom UI technology with SAP BPM, follow these steps:


                    After you've successfully modeled a process with a human activity, create a task for the human activity. Do not select the Generate UI Component checkbox (Figure 12.30).
                

                    From the Process Development perspective in SAP NetWeaver Developer Studio, navigate through the project tree structure, and expand the Process Modeling and Tasks folders.
                    
Figure 12.30    Creating a Task to Support a Custom UI Technology


                    Open the task, and click on the Choose button under the User Interface section.
                

                    On the subsequent screen, select the Custom Technologies as your choice for the UI Wizard (Figure 12.31 1). Click on OK.
                

                    In the subsequent wizard screen, specify the relative URL of the custom web application that will be used to execute the task. Also specify the input and output data to be used. You can also specify fault data types 2.
                

                    Click on the Finish button to complete the task creation.
                

                    After an SAP BPM process has reached a human task, a task is created and assigned to the owner. As soon as the user accesses the task via the UWL or the SAP BPM Inbox, the URL of the custom application will be accessed.
                    
Figure 12.31    Steps in Integrating a Custom UI Technology with SAP BPM











12.4    Summary
This chapter provided an overview of the UI technologies SAP provides for executing tasks and consuming the human activity within an SAP BPM process. The Web Dynpro (for Java or ABAP UI) technology is commonly used in this arena. However, more recently, the SAPUI5 technology has been redefining the options of UI consumption within an SAP BPM process.
The SAPUI5 integration into the SAP BPM process for executing human tasks gives flexibility and ease of task completion by the assigned users. This stems from the fact that SAPUI5 applications can be developed to run on different platforms (including standard browsers and mobile and smart devices). In addition, Visual Composer and Adobe offline forms can also be integrated into an SAP BPM process as UI technologies.
It's also possible to use any other third-party UI technology to interact with SAP BPM tasks. However, this will require using the API provided by SAP BPM to gain access to its functionality.
In conclusion, the UI technologies presented in this chapter can be used for implementing human task consumption with an SAP BPM process. The UI technology to be used is dependent on the business requirements, the available infrastructure, the developers' skill set, and the IT landscape.
The next chapter will explore SAP Business Rules Management (SAP BRM).








13    SAP Business Rules ManagementYou have to learn the rules of the game. And then you have to play better than anyone else.                                                                                                    —Albert EinsteinThis chapter introduces SAP Business Rules Management (SAP BRM) as a technology enabler to streamline the business rules that govern your business processes. SAP BRM makes it possible to centrally model, test, execute, and manage business rules, all from one single platform.We'll explore the background of business rules within the context of SAP Business Process Management (SAP BPM) and then take a deep dive into the technology again and learn how SAP BRM is supported within SAP Process Orchestration (SAP PO). After reading this chapter, you should have enough background to start designing and building business rules to support business processes across your organization.
13.1    How Business Rules Work
Automated business processes are a combination of process actors, activities, events, and information flowing from the start to the end of the process flow. Along that journey, a business process encounters different checkpoints at which the business process engine has to choose which process path to execute, which task should be assigned to which employee, what value should be set to a specific field, and so on. The outcome of that decision step may depend on different aspects, of which the business requirements supported by that automated decision step is one of the most important. In SAP BPM terminology, we call that type of in-flight process decision a business rule. Decisions made by or the results given by a business rule have to be executed quickly, be traceable, be accurate, and be done according to the business process requirements and corporate policies.
Business rules enrich business processes with conditions and constraints that must be met or checked before executing a certain process activity or returning a particular result to a requester. Put another way, a business rule represents constraints that affect the behavior or final result of a business process; for instance, corporate policies are standard business practices that need to be consistently applied across business processes.
An important aspect about business rules is that they are initially created by IT but owned and maintained by the business. Business rules can support simple conditions, such as validating a customer postal code in an order, or more complex business decisions, such as calculating pricing conditions and special discounts for selected accounts. It's also good to mention here that the concept of business rules is absolutely not new and certainly not only applicable for automated business processes, such as those modeled and executed on modern business process management (BPM) engines such as SAP BPM. We find business rules in every line of business and industry; they support the business in driving the decisions taken in repetitive process steps in an efficient and quick way. However, the process of managing and maintaining those important rules imposes a big challenge for companies that haven't implemented a BPM strategy across their organization. Many of those organizations still rely on individuals to make those decisions based on their knowledge and experience. That creates a knowledge-leak risk and limitation in terms of the reusability and efficiency of those rules.
Table 13.1 summarizes the different conventional implementation methods of business rules enforcement and automation within organizations.




                        Business Rules Implementation Methods
                    

                        Disadvantages
                    





                        Automated in the application or database layer
                    



                                Zero to limited visibility for process stakeholders.
                            

                                Combination of business and decision logic. makes coding and maintenance of rules more complex.
                            

                                No agility and flexibility offered to support quick changes driven by the business and market environment.
                            





                        Documented as work procedures enforced and executed by individuals in the organization
                    



                                Difficult to enforce and control due to its static character.
                            

                                Error prone and increases risk of fraud because of its manual execution.
                            

                                Limited to no knowledge transfer possible; rules knowledge leaves the organization when individuals leave the company.
                            





Table 13.1    Conventional Methods of Business Rules
It's clear from the preceding overview that traditional methods of maintaining and applying business rules in business processes aren't suitable for coping with the high degree of flexibility and transparency demanded by modern businesses, in which agility and visibility is a must to run their processes. There is a need for a continuous flow of information through flexible and agile business processes able to cope with the increasing demand and high expectations from the market they operate in.
Automated business rules change the game by adding the level of maturity and flexibility that organizations need to effectively introduce and execute business rules. With automated rule-based decisions, you can enforce corporate policies and process constraints by supporting and speeding up decision making at key points in business processes.
Furthermore, you can take advantage of role-based applications by combining your organizational structure and process flows, which dynamically allocates tasks to the correct role or user via configurable business rules. When working with automated business rules, all activities related to rules modeling and development are managed and executed from one central platform, which gives you total transparency over the existing rules and their content and usage.
Business rules are one of the most fundamental parts of an application and the business processes it supports. Hence, identifying, documenting, and centralizing business rules helps to improve the efficiency and reliability of the business processes owned by an organization. Externalizing decision logic as automated business rules establishes a natural separation of application and decision logic, which in turn leads to easier ways of communicating business rules and managing applications organization-wide.
A special type of software platform called a Business Rules Management System (BRMS) provides organizations with that type of functionality. Such a platform addresses all the areas of business rules and removes the disadvantages presented by nonautomated business rules. It also adds transparency and manageability to the entire business rule lifecycle. Figure 13.1 provides a high-level overview of the basic architecture offered by a typical BRMS platform.

Figure 13.1    Basic Architecture of a BRMS Platform
The following main components can be found in a BRMS architecture:


                Rules engine, where the rules are deployed and executed
            

                Rules repository, where the rules and their related objects (data types, scripts, etc.) are stored and maintained
            

                Administration and monitoring tools for the rules and their system environment
            

                Rules simulation and test tools
            

                Business applications and/or business processes that access the rules using service interfaces
            

Business rules can be categorized in different groups, depending on their usage and supported functionality. Table 13.2 lists the different types of business rules, as applied in most processes.




                        Type of Business Rule
                    

                        Usage
                    





                        Decision


                        Supports simple and complex decisions at runtime. For example, there might be a business rule that computes task allocation to the correct role, team, or business unit in the organization.
                    



                        Validation


                        Commonly used to automate technical or business validation rules of specific information objects (data input) within a business process.
                    



                        Calculation


                        This type of rule is typically applied to support complex calculation tasks during process execution—for example, in pricing engines that have to take into consideration different factors (credit rating, special customer-level discounts, localization, marketing campaigns, etc.) before a price or quotation is released to a customer.
                    



                        Error and exception handling


                        Can be applied to determine which corrective or escalation steps to take when predictable and unpredictable exceptions during process execution occur.
                    



                        Internationalization and localization


                        Support of specific company policies, products, and services for international business and cross-border activities—for example, compliance with tax and legal acts and support of international markets with generic processes and systems.
                    



                        Routing


                        Applicable mainly for system-centric business processes in which the flow of messages is decided based on the contents of the message or other type of events while executing the process.
                    



Table 13.2    Types of Business Rules









13.2    SAP Business Rules Management
SAP BRM is an integral component of SAP PO and complements SAP BPM in the fundamental areas of modeling, maintenance, and execution of automated rule-based decisions (see Figure 13.2).

Figure 13.2    Positioning SAP BRM within SAP PO
SAP BRM introduces transparency to the way rule-based decisions are enforced in your business processes. You can also easily decouple your process logic from your decision logic. SAP BRM is an all-in-one platform that helps you automate the execution of business rules and manage their entire lifecycle (i.e., model, execute, monitor, and improve in conjunction with the business processes they are part of).
SAP currently offers two different flavors of supporting automated business rules with SAP technology:


                SAP BRM as part of SAP PO
            

                SAP Business Rules Framework plus (BRFplus), which is an ABAP-based, rules-based framework
            

In this book, we only focus on the first category (SAP BRM), which is based on the Java-only stack of SAP PO and supports integration according to service-oriented architecture (SOA) principles and technologies.
SAP BRM is delivered as part of SAP PO and can be seen as an independent BRMS running in parallel with the SAP BPM and AEX engines on the SAP Java stack of SAP PO. It consists of three main components that support the different competencies (i.e., IT and business) within business rules management in an organization: Rules Composer, Rules Manager, and rules engine.
We'll now discuss each of these tools in the following sections, how they are used, and when to use them.
13.2.1    Rules Composer
The Rules Composer represents the design time of SAP BRM. It's the place where you create, model, develop, test, and deploy your business rules. SAP delivers this functionality as part of its Eclipse-based integrated development environment (IDE), SAP NetWeaver Developer Studio, which was introduced and discussed in Chapter 2 and Chapter 6.
SAP NetWeaver Developer Studio offers a rich palette of business rules perspectives, from which (depending on your role, e.g., business analyst, business rules developer, or the process owner of the business rule) you can model, develop, or maintain business rules. Figure 13.3 shows a simple business rule modeled as a rule flow using the SAP NetWeaver Developer Studio Rules Composer perspective.

Figure 13.3    Rules Composer with Flow Ruleset in SAP NetWeaver Developer Studio
As a developer, you can follow two different approaches for creating business rules:


                    A standalone business rule service can be reused by different applications and business processes. You create this type of rule directly from the Rules Composer perspective in SAP NetWeaver Developer Studio. You'll typically opt for this approach when you expect that a business rule will be generic enough to be used by different processes.
                

                    Rules can be embedded as part of a business process context and created as part of the Process Composer development component (DC). This type of rule is commonly used inside processes that require specific decision logic, and the chance that such a rule will be reused by other applications is very slim.
                

When you've decided which method to apply for implementing your business rules (i.e., as rules service or embedded inside the context of a business process), then you also have to determine how to integrate the business rule within your business process. There are different ways of adding the business rules to your process flow in SAP BPM:


                    As an automated activity—that is, called as a web service using its Web Service Description Language (WSDL).
                

                    Inside a gateway condition as a custom-built function. This feature is only supported for a ruleset that has been created inside the same DC in which the process flow is maintained (Figure 13.4).
                

                    Programmatically via Enterprise Java Bean (EJB) custom functions and mappings.
                


Figure 13.4    Embedded Rule as Gateway Condition in Process Flow
13.2.2    Rules Manager
Business rules are rarely static and tend to evolve according to the dynamics of the business. Therefore, a well-established set of procedures and tools must be in place to support the ongoing process of maintaining and changing business rules.
Rules Manager (see Figure 13.5) is a rule-centric Web Dynpro application that provides a web-based environment to administer and monitor previously deployed rules on the rules engine. It allows business managers, IT and functional administrators, and key users to modify business rules and implement changes instantaneously. With Rules Manager, it's possible to create, update, and delete rules, scripts, and decision tables on the fly rather than via time-consuming transport procedures.

Figure 13.5    Rules Manager
There are also different web-based tools built alongside Rules Manager that support the maintenance and management of business rules in SAP PO. Those tools are explained in the following subsections.
Business Rules Access Control Management
With the access control mechanism, you control the access and authorizations to the administration area for active rules on the rules engine. In the access control, you configure which user roles are allowed to perform changes to all rules or only to specific rules under a particular project.
Open the access control configuration screen via SAP NetWeaver Administrator (http://<hostname>:<port>/nwa), and then select the tabs Configuration • Security • Identity Management (Figure 13.6).

Figure 13.6    Business Rules Access Control Management
Rules Manager Editing Tool for Functional and Business Users
Perhaps one of the most interesting features that Rules Manager has to offer is the Rules Manager online editing tool, which targets mainly non-IT users with knowledge of the business rules and the processes using them. The Rules Manager provides business analysts, administrators, and users with a tool to modify business rules and effect changes in real time. Figure 13.7 shows the Rules Manager online editing tool when editing a decision table deployed on the server. Remember that you can only see and edit rules that have been previously deployed to the server. Use this link to access the Rules Manager: http://<hostname>:<port>/rulesmanager.

Figure 13.7    Rules Manager Editing Tool
Business Rules Execution Logs
You can access this functionality by navigating to SAP NetWeaver Administrator and then selecting Troubleshooting • Processes and tasks • Rules Business Logs (see Figure 13.8).

Figure 13.8    Business Rules Execution Logs
The rules engine stores technical logging and vital runtime information during rules execution; we call that type of logging business logs. The generated business logs and execution stack trace information can then be used for further analysis, debugging, testing, audit trails, and so on.
Using this function, technical and functional administrators can query the rules engine and search for the rule's execution logs based on basic search parameters (e.g., execution timestamps) but also on advanced search requests based on business rule events and specific rule invocation IDs. Figure 13.9 shows the different types of search filter criteria you can select from the predefined list of business rule events. Note the link on the top-right side of the page where you can switch from Basic to Advanced search mode. When you click on Basic, the different business rules events are shown as search criteria.

Figure 13.9    Business Rules Execution Logs Advanced Search in SAP NetWeaver Administrator
Figure 13.10 shows the results returned by a search query when the business rule event All was previously selected (refer to Figure 13.9) as the search criteria. All the events related to the same rule invocation are automatically logged and correlated using one unique Rule Invocation ID for easy monitoring and tracing.

Figure 13.10    Business Rules Execution Logs Results in SAP NetWeaver Administrator
13.2.3    Rules Engine
When you've modeled, configured, and locally unit-tested your rules in SAP NetWeaver Developer Studio's Rules Composer, it's time to deploy the business rules and execute them on the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java). Executing the rules on SAP NetWeaver AS Java is the main job of the rules engine; it achieves this by interpreting and executing the business rules deployed on the application server. The rules engine is the runtime component of SAP BRM, and it can be found on the same Java stack (SAP NetWeaver AS Java), next to the adapter and process engine inside SAP PO (as shown in the Functional Unit area in Figure 13.11).

Figure 13.11    Rules Engine in the SAP NetWeaver Administrator Functional Units Screen
In the next section, we'll explain how to create a business rule and add context to it, as well as how to test your rules from SAP NetWeaver Developer Studio and external tools. Section 13.4 will show you different ways of testing your business rules using internal and external methods.









13.3    Modeling Business Rules with Rules Composer
We've broadly elaborated the business needs and various benefits offered by automated business rules in SAP BRM, and now we're ready to jump into the design time of SAP BRM and start developing some business rules. We'll provide the step-by-step instructions you'll need to build an entire ruleset and will discuss the different tasks required to implement rules in the Rules Composer.
13.3.1    Create the Rules Composer Development Component
Like any other SAP PO component in SAP NetWeaver Developer Studio, you need to create a new project and new DCs for SAP BRM; here, it will be a new DC of the Rules Composer type, which will contain the business rule objects in your SAP NetWeaver Developer Studio workspace.

Note
This step is optional when you're working with SAP NetWeaver development infrastructure for version control, in which case, you'll only need to download the previously configured development configuration, including software components (SCs) from the SLD. You do so via the Development Infrastructure perspective in SAP NetWeaver Developer Studio (Figure 13.12).

Figure 13.12    Importing Development Configuration
For the sake of simplicity, we assume that you're working locally, and thus SAP NetWeaver development infrastructure hasn't yet been configured.

Execute the following steps in SAP NetWeaver Developer Studio to create a new Rules Composer DC from local development:


                    From SAP NetWeaver Developer Studio, choose File • New, and then select either Project or Other.
                

                    A new wizard opens. Enter "rules" as the type filter text (Figure 13.13), and select Rules Composer Development Component.
                    
Figure 13.13    Creating New Rules Composer DC: Wizard 1


                    Expand LocalDevelopment, and select your own local SC or the default local development, MyComponents [demo.sap.com].


                    In the New Development Component dialog, enter a valid name for the new rules DC, and click Finish when done (Figure 13.14).
                

If you already have SAP NetWeaver development infrastructure installed and development configuration properly configured for SAP PO, then you should create the Rules Composer DC in the SLD, including all necessary software dependencies for that type of DC. After that, you can start adding rule objects (flow ruleset, ruleset, etc.) directly into your preconfigured rules DCs.

Figure 13.14    Creating New Rules Composer DC: Wizard 2
13.3.2    Adding Context to the Rules
Now, it's time to add the appropriate context to the new business rules, which means configuring or importing the data model that will serve as the backbone to execute the decision logic inside the business rule. An example of such a data model is provided in Listing 13.1 as an XML snippet. Note that the same structure serves as the input and output of the rule, so from that perspective, there is no distinction made between request and response. In this example, the ApprovalNeeded field with a Boolean value will be set by the rule every time the rule is successfully executed.
<?xml version="1.0" encoding="UTF-8"?><ns1:BudgetRequest xmlns:ns1="http://www.rojoconsultancy.com"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="http://www.rojoconsultancy.com Approval.xsd ">    <ns1:ApprovalNeeded>false</ns1:ApprovalNeeded>    <ns1:Amount>10000</ns1:Amount>    <ns1:Region>EMEA</ns1:Region></ns1:BudgetRequest>
Listing 13.1    Approval.xsd
To add context to the business rule, you can either use XML Schema Definitions (XSDs) or Java classes, which is easily achieved by adding the XSDs or Java classes to the Rules Composer DC. You can also create a brand-new XSD within the same Rules Composer DC and use it as context; just make sure it's created under the src folder and the wsdl subfolder, as shown in Figure 13.15.

Figure 13.15    Adding XSD to Rules Composer DC
You can also extend a rule's context with fixed and dynamic variables created as common definitions in Rules Composer. Figure 13.16 shows how to import an existing XSD file in the Rules Composer DC.

Figure 13.16    Import XML Schema in Rules Composer DC
Follow these steps to import an external XSD or WSDL file into your business rules DC:


                    Right-click on the src folder inside your business rules DC, and select Import.
                

                    A dialog box appears; navigate almost to the bottom of the screen, and expand the Web Services folder. Select XSD.
                

                    The XSD import page appears. Leave the default values, and click on Next.
                

                    Click on Browse to select the XSD file from your local or network system. Select the XSD file you want to import, and click on Open.
                

                    Click on Finish.
                

To make the new context visible to the rules, first build the project and the Rules Composer DC. To build the project, select Build Project • Development Component • Build from the context menu of the Rules Composer DC.
13.3.3    Creating a Ruleset
A ruleset is in essence a logical container that holds different, related rule objects (if-then rules and decision tables) together. For example, all rule objects used to decide whether or not a customer has a VIP credit rating can be grouped into the CreditRateRuleset ruleset.
Open the Rules Composer DC from the Project Explorer, right-click on Rules Modeling, and choose New Ruleset. You should now see the new ruleset under the Rules Modeling node. Now, you can start building up your rules, either as if-then rules or as decision tables. We discuss each of these options in the following subsections.
Rules
A rule is a set of conditions or logical evaluation statements with one or more associated actions. Rules are created and maintained as part of a ruleset, and you can have more than one if-then rule under the same ruleset. You construct rules using the rule editor, which is a text-based tool with built-in functions and predefined actions to write rules (Figure 13.17).
The if part of a rule is always represented by the conditions in the rule, and the then part is the action (or actions) that needs to be executed if a condition is satisfied.

Figure 13.17    Rule Definition in Rule Editor

Example
A business rule needs to be introduced for a company that wants to check whether approval from the CFO is needed for projects with a budget above a certain amount.
If the region is EU, and the budget request for a project is less than €10,000, then no additional approval is needed from the CFO. The corresponding if-then rule might look like this:
If Region = EUANDAmount <= 10000ThenApproval = false
This example might seem trivial, but it's complete enough to demonstrate the concept and style of logic applied in this type of rule. In the next paragraphs, we'll come back to the topic of if-then rules.

Let's now take a look what type of predefined actions we have available in the Rule Editor.
Rule actions are grouped into the following six different categories:


Assert Use this action in combination with Java methods that return an object such as a collection, iterator, enumeration, and so on. You can use it to examine more than one object at a time—notice, the object tested by the assert action isn't the collection, iterator, or enumeration, but rather the objects returned by looping through them. This functionality doesn't work with a rule only configured with an XSD and requires a Java class as its data model or context. The syntax for an assert is as follows:
                        

Assert:: [imported Java class with a method returning any object]


                                Example: Assert:: BudgetRequest.getRequests


                        As a result, all Requests objects returned by this action will be examined by the rule.
                    

Assign This type of action is used to assign a new value to a variable definition. The variable has been previously declared at the project resources level in the same Rules Composer DC. The new value could be the result of some calculation or method execution. The syntax for an assign is as follows:
                        

Assign:: [Variable Definition] = new value


                                Example: Assign:: Var_StandardRegion = EU


                        Note that only previously defined variables at the DC (project resources/common definitions) or ruleset (definitions) level will be available for selection in this function.
                    

Execute Execute is an action type that can be used to run methods on Java objects or to set values for XML elements in the ruleset's context. The syntax for execute is as follows:
                        

Execute:: [Any XML schema or public Java method on any of the classes available in the Ruleset context.]


                                Example: Execute:: BudgetRequest/Region = AP




Re-evaluate Re-evaluate is an action that is applied to let the rules engine reexamine all rules involving a previously asserted object. As a result of the re-evaluate action, any rules that were satisfied because of that object's examination are removed from the firing queue. Then, the conditions that apply for that type of object are checked, and if any rules satisfy them, then they are added to the firing queue again. This type of action isn't used frequently and should be applied with caution because it can introduce infinite loops into your rule. The syntax for re-evaluate is as follows:
                        

Re-evaluate rules involving:: [object that must be re-evaluated]


                                Example: ..If BudgetRequest has changed = trueThenRe-evaluate rules involving:: BudgetRequest ..





Note
As explained at https://help.sap.com, a firing queue is a collection of actions of all satisfied rules that are to be executed by the rules engine. When a rule is satisfied, the rules engine creates an entity that represents all the actions for that rule. The entity is then added to the firing queue at the correct place according to the rule's priority. Finally, the engine then reads each entity from the firing queue and executes all the actions per entry.



Retract As the name of this action indicates, it's an action type used to pull back an earlier asserted object from the engine. The result of a retract action is that the engine will withdraw any inferences triggered by the object. Rules previously satisfied by the object are removed from the firing queue. However, if actions were fired as a result of that object, then those actions can't be rolled back. Just as for the re-evaluate action, this action is also rarely used. The syntax for retract is as follows:
                        

Retract :: object that must be retracted


                                Example: Assert:: BudgetRequest.getRequests...Retract :: requests




Evaluate decision table This is probably the most common type of action you'll be using when coding rules. With this action, you can execute a decision table in the same ruleset as the rule from which you're calling it. It's also possible to dynamically call different decision tables from the same rule using If-Then-Else-If statements. The syntax for evaluate decision table is as follows:
                        

Evaluate-DecisionTable :: Name of DecisionTable to be called


                                Example: Evaluate-DecisionTable:: ApprovalDecisionTable




Decision Tables
A decision table is a relatively easy yet effective way to represent different sets of related conditions and their associated actions in a tabular fashion. Due to that fact, decision tables play a prominent role in any business rules application, and SAP BRM applications aren't an exception. In fact, you'll be using them frequently when developing business rules in SAP BRM. They are also easy for non-IT users to maintain without having to change the decision logic.
Conditions in a decision table can be grouped horizontally or vertically, always followed by their corresponding actions on the right side of the table. Conditions are allowed to have one or more actions when the rule they enforce is satisfied (see Figure 13.18 and Figure 13.19).

Figure 13.18    Decision Table with Double Vertical Condition

Figure 13.19    Decision Table with Multiple Values Condition
The following comparators can be used to declare your conditions in decision tables:


In


                                For example: In EUR;USD;JPY


True if any of the semicolon-separated values are found in the condition input
                            

                                Can't be used for Boolean data types
                            



Not In


                                For example: Not In ZAR;RUB


True if any of the semicolon-separated values aren't found in the condition input
                            

                                Can't be used for Boolean data types
                            



Between


                                For example: Between 100 AND 1000


                                Range-match condition
                            

                                Can't be used for String data types
                            



Like


                                For example: Like EU*


                                Pattern-match condition
                            

                                If value compared is EUR, it returns true; if value is USD, it returns false


                                Can't be used for Numeric data types
                            



Not Like


                                Example: Not Like EU*


                                Pattern-mismatch condition
                            

                                Can't be used for Numeric data types
                            



>, ⩽, <, ⩾


                                Greater than, greater than or equals, smaller than, smaller than or equals
                            

                                Can't be used for Boolean data types
                            



= (equal)
                        

                                For example: = Rojo


                                For example: = true


                                This is the only comparator that can be used for Boolean data types
                            



!= (not equal)
                        

                                For example: != Rojo


                                For example: != true


                                Can be used for Numeric and String data types
                            



The data in a decision table can be exported and imported as a Microsoft Excel sheet (an XLSX file). In this way, non-IT users can actively participate in the maintenance and control of business rules without having to be totally aware of the technology around it.
You can import the XLSX file during design time in the Rules Composer or via the SAP NetWeaver Administrator Rules Manager tool. A requirement for the second approach is that the rules must be already deployed on the rules engine. Before your users can start using this type of function, you have to assign them to the appropriate default role for viewing and editing content in Rules Manager. To do so from SAP NetWeaver Administrator, follow these steps:


                        Log in to SAP NetWeaver Administrator.
                    

                        Select Identity Management • Configuration Management • Identity Management.


                        Search for and select the user, and double-click on the row to access details for the user.
                    

                        In the Details section, choose the Assigned Roles tab, and search for the default role, SAP_BRM_ADMIN.
                    

                        Select the role, and click on the Add button to assign that role to the user.
                    

                        Save your changes.
                    

13.3.4    Flow Ruleset
A flow ruleset is a special type of ruleset that offers the ability to execute different types of business rules grouped in one process flow. It consists of one main flow and one or more rule elements, including other rule flows.
For those of you used to modeling business processes using Business Process Model and Notation (BPMN) flows, you'll find the concept of rule flows very similar to process flows modeled using the BPMN 2.0 standard. However, as you can see in Figure 13.20, there are clear differences in terms of the available objects in the rule flow palette.

Figure 13.20    Rule Elements Palette in the Rule Flow Editor
A flow ruleset consists of the following elements:


Rule flows A rule flow is a sequence of activities for evaluating business rules. The order of the execution of the rules is graphically represented in the form of a flow chart, very similar to a process flow in BPMN.
                    You can reuse it within a flow ruleset, and it's based on activities associated with other SAP BRM elements, such as rule scripts, rule flows, rulesets, flow rulesets, rules, and decision tables.
                

Rule scripts A rule script is a reusable rule element that you use within a flow ruleset that contains a sequence of actions. It looks much the same as a standard rule, with some differences in the types of actions that you can perform inside it.
                    It's associated with other artifacts (rules, rulesets, and decision tables) in a flow ruleset and is triggered when the conditions listed in the preceding activities are satisfied.
                

If-then rules A set of conditions followed by one or more associated actions that are executed when the conditions are met (Section 13.3.3).
                

Decision tables A tabular representation of related rules (Section 13.3.3).
                

A flow ruleset becomes very useful for the execution of related business rules, which require more flexibility and "orchestration" logic than is available with a traditional ruleset. It also has the advantage of representing the sequence of the rule execution in a graphical way, making it easier to follow and understand the logic executed by the rule. Consider the simple example of a rule flow presented in the following box.

Example
A rule flow is used to control the execution of steps inside a rule depending on specific predefined conditions and the input provided to the rule. Figure 13.21 shows how a simple rule flow has been modeled to execute different steps as part of the same business rule.
Let's examine the steps inside the rule flow.

First, validate the input provided to the rule with a rule script before entering the decision table. You can think of different kinds of validation, such as format or the presence of a certain value in the context of the rule.
A gateway checks the output of the validation rule script and decides which path (default or decision) should be executed. In this case, the rule will continue to the default path if the input provided to the rule doesn't need to be checked against the logic configured in the decision table.
The rule executed in the default path is used to apply less complex decision logic and returns a standard value as the response of the rule.
If the rule flow enters the path containing the decision table, it means that a more complex or specific decision logic needs to be applied to the provided input.

Figure 13.21    Flow Ruleset









13.4    Testing Business Rules
Before a business rule is deployed on the server, it's best practice to perform some unit test (i.e., test the rules locally). In this section, you'll learn how to do that with a few different methods.
Depending on the type of test scenario (e.g., functional or technical) and the specific test requirements, you can test business rules in different ways in SAP PO. Which test approach you choose also depends on whether your business rules are exposed as a web service or not. The different test options you have include the following:


Using the WS Navigator: http://<hostname>:<port>/wsnavigatorThis is recommended for testers and non-IT users.
            

Creating a test scenario from SAP NetWeaver Developer Studio in the Rule Composer DCThis isn't recommended for nondevelopers. We'll explain this in the next section, which discusses modeling rules with the Rules Composer.
            

By testing the business rule embedded as part of a business process modeled in SAP NetWeaver Developer Studio Process ComposerWhen you test your business processes, you implicitly test the business rules it contains. Business rules logs and execution traces can be read using the business logs, as explained in Section 13.2.2.
            

By using an external test toolTest tools include the SoapUI or any other Simple Object Access Protocol (SOAP) client.
            

Using the WS Navigator or using an external test tool require that you've previously generated and configured an existing ruleset or flow ruleset as a web service so that it can be exposed as a web service.

How to Generate a Web Service for Business Rules
You can generate a web service for business rules in SAP PO as follows:


                    From SAP NetWeaver Developer Studio, expand the Rules Composer DC containing the Rules Modeling nodes.
                

                    Select a ruleset or flow ruleset, and right-click on it. Choose Web Service • Create WSDL Artifact from the context menu.
                

                    A dialog box is shown in the wizard with the Service Attributes page; accept the default values, or apply changes if necessary to the suggested values. Click on Next.
                

                    The Service Signature page is presented, the input and output types appear, and the checkboxes are selected by default. Click on Next.
                

                    The WSDL Preview page is shown. By this point, you should be able to see the contents (WSDL parts) of the new web service.
                

                    Click on Finish.
                

                    Deploy the DC containing the business rules on the server.
                

Figure 13.22 shows the service attributes for the new ruleset web service.

Figure 13.22    Ruleset as Web Service










13.5    Best Practices for Modeling Business Rules
When modeling and developing business rules in SAP BRM, you should always design those rules while applying best practices and design principles. By doing so, you'll become aware of various aspects that may positively or negatively impact the overall quality of your business rules.
In this section, we'll share some practical tips that have been proven to improve the quality of the rules and to mitigate other general risks, such as poor performance and difficult-to-maintain rules. However, before we look into that, we'll share a couple of good sources of information about business rules on the Internet—namely, www.businessrulesgroup.org and, of course, the SAP Community, which has its own page dedicated to SAP PO including business rule topics (https://www.sap.com/community/topic/process-orchestration.html). There, you'll find an entire collection of blogs, how-to documents, and lots of forum topics discussing SAP BRM.
13.5.1    Separate Decision Logic from Other Types of Logic
When implementing business rules with SAP BRM, you should always apply an important design principle: isolate decision logic (in SAP BRM) from integration logic (in SAP Process Integration [SAP PI]/AEX) and application logic (in SAP and non-SAP backend systems). Use SAP BRM to support decision-making logic and nothing else. Don't confuse the true power of business rules with other types of logic, such as executing transformations, and calling web services/external systems, or modeling an entire process flow in a flow ruleset. You should use the right tool depending on the type of logic (i.e., SAP BPM to orchestrate and call external services via the AEX). If you fail to do so, you'll end up introducing maintenance and performance problems in your business rules.

Tip
Here are some additional guidelines for you to consider when designing and before you start implementing your business rules.


                        Use SAP BRM exclusively to support decision making.
                    

                        Think and decide which fields and (XML/Java) data types you'll need to support the context of your business rule.
                    

                        Send only input data required to execute the business rule. The output of the rule will be updated with the results of the rule execution.
                    


13.5.2    Reuse and Extend before Building
Before you start implementing new rules, first analyze the existing rulesets, and then choose wisely which ones you could reuse or extend before you create new rules. The following specifies when to use a rule, decision table, or rule script:


Ruleset:


                            Execute based on the Rete algorithm, and give preference whenever possible as its footprint tends to be lower than a flow ruleset. The SAP BRM engine takes control of execution in automatic pilot mode.
                        

                            Support execution and dynamic execution of one or more decision tables under the same ruleset.
                        



Rule:


                            Use for straightforward, not too complex conditions and actions.
                        

                            Limit to a two-level condition check.
                        

                            Create rules with common conditions, and reuse them if possible across the ruleset.
                        

                            Reuse conditions by using the precondition feature.
                        

                            Keep in mind that a rule when compared with other rule objects (e.g., decision table) can be less user-friendly to maintain for non-IT users.
                        



Flow ruleset:


                            Strongly consider introducing a flow ruleset when your business rules contain different logical steps (validate, filter values, etc.) and combine multiple rule objects such as rules, decision tables, rule scripts, and rule flows.
                        

                            Try not to overpopulate your flow ruleset with too complex rule flows and large amounts (more than 20x rule objects) of different rule objects inside the same flow ruleset.
                        



Decision table:


                            Use if (similar) conditions for business rules already exist in tabular form, especially with a greenfield SAP BRM implementation.
                        

                            Give preference if non-IT stakeholders are highly involved in the periodic maintenance of data in the decision table.
                        

                            Size does matter is the message here; split decision tables into logically related smaller decision tables if they become too big in terms of number of conditions or actions.
                        

                            Keep decision tables to fewer than 20,000 rows and 100,000 cells. Avoid going above that threshold; otherwise, you'll enable potential performance issues.
                        

                            Define aliases where possible for better understanding by non-IT folks.
                        



Rule script:


                            Apply for multilevel (nested), more complex conditions.
                        

                            Use when you need to loop through a list of objects in Java or a collection of elements in XML.
                        

                            Avoid using it when non-IT users are involved with the maintenance of business rules, as rule scripts tend to be harder to understand than other type of rules.
                        












13.6    Exercise: SAP Business Rules Management
This exercise will help you get started with the creation of business rules in SAP PO. In this exercise, you'll learn how to translate a functional requirement into an SAP BRM DC, which you'll then implement using the Rules Composer.
For that purpose, we'll extend the purchase order business use case introduced in Chapter 10. Let's first see what requirements you've received from the process expert. Before a purchase order is sent by Reader's Paradise to its supplier, Book Fountain, the purchase order must be validated against a set of business rules.
The process expert has provided you with the required input (see Table 13.3) to define the business rules in SAP BRM. The combination total amount of a purchase order and priority level (1 is low, 2 is medium, and 3 is high) assigned to the order should result in manual or automatic approval. This check is performed before an order is sent to the supplier. The business has also requested that you provide maximum flexibility in terms of changing the values driving this approval criteria. This is a common business use case that you might encounter when implementing SAP BPM applications running on top of SAP PO.
13.6.1    Exercise Solution Approach
After analyzing the requirements provided by the process expert, you decided to translate the approval criteria for this process step into a business rule DC containing a decision table, which in turn will be executed via a flow ruleset. The decision table will support the input from the business process. Table 13.3 shows the content your new decision table should contain.




                            Purchase Order Amount
                        

                            Priority Level
                        

                            Approval Needed?
                        





                            1000
                        

                            3
                        

                            NO
                        



                            10000
                        

                            3
                        

                            NO
                        



                            100000
                        

                            3
                        

                            YES
                        



                            1000
                        

                            2
                        

                            NO
                        



                            10000
                        

                            2
                        

                            NO
                        



                            100000
                        

                            2
                        

                            YES
                        



                            1000
                        

                            1
                        

                            NO
                        



                            10000
                        

                            1
                        

                            YES
                        



                            100000
                        

                            1
                        

                            YES
                        



                            1000
                        

                            0
                        

                            YES
                        



                            10000
                        

                            0
                        

                            YES
                        



                            100000
                        

                            0
                        

                            YES
                        



Table 13.3    Decision Table
We're assuming the following to be true for this exercise:


                    You have access with admin rights to an SAP PO installation (sandbox or development system).
                

                    SAP NetWeaver Developer Studio is installed locally on your development PC.
                

                    You have a good understanding of XML and XSD.
                

13.6.2    Exercise Step-by-Step Solution
We'll go through the following high-level steps (covered in more detail ahead) to create the business rule in SAP PO:


                    Create the Rules Composer DC locally in SAP NetWeaver Developer Studio without the SAP NetWeaver development infrastructure.
                

                    Define the rules input and output parameters by adding a new XML schema to the SAP BRM DC.
                

                    Define aliases for the XML schema.
                

                    Create a flow ruleset (to group all business rule components in one set).
                

                    Create a decision table.
                

                    Configure a rule flow (to graphically represent the business rule as a flow).
                

                    Test the business rule.
                

Create Rules Composer Development Components Locally
To create the Rules Composer DC locally in SAP NetWeaver Developer Studio without the SAP NetWeaver development infrastructure, follow these steps:


                        Start SAP NetWeaver Developer Studio, and select or create a new workspace (Figure 13.23).
                        
Figure 13.23    Selecting a Workspace in SAP NetWeaver Developer Studio


                        From the SAP NetWeaver Developer Studio Welcome page, click on Workbench (Figure 13.24). This is an optional step that is only applicable when you're working with a brand-new workspace.
                        
Figure 13.24    SAP NetWeaver Developer Studio Welcome Page


                        Create a new project via File • New • Project (Figure 13.25). In the dialog box that appears, choose Rules Composer and expand the folder.
                        
Figure 13.25    Creating a New Project in SAP NetWeaver Developer Studio


                        Click on Rules Composer Development Component, and click on Next (Figure 13.26).
                        
Figure 13.26    New Rules Composer DC Wizard


                        In the window that appears, choose the SC in which you want to create the DC. For this exercise, use the default local SC. Under the LocalDevelopment node, select MyComponents [demo.sap.com] (Figure 13.27). Click on Next.
                        
Figure 13.27    Local Software Component Wizard


                        In the screen that appears, enter "dc_brm_povalidation" in the Name field, accept the default values for the other fields, and click on Finish (see Figure 13.28).
                    


Figure 13.28    Local DC
The result of this exercise is that you should see the dc_brm_povalidation DC in the Project Explorer view (see Figure 13.29). Click on it to expand its contents.

Figure 13.29    Rules Composer DC in SAP NetWeaver Developer Studio
Define the Rules Input and Output Parameters
To define the rules input and output parameters by adding a new XML schema to the SAP BRM DC, follow these steps:


                        Navigate to the src folder, right-click on the wsdl subfolder, select New, and click on XML Schema (Figure 13.30).
                        
Figure 13.30    Importing the XML Schema in SAP BRM DC


                        Enter the file name for the new XML schema ("POValidationRules.xsd"), and click on Finish (Figure 13.31).
                        
Figure 13.31    Create New XML Schema Wizard


                        Copy and paste the XML source shown in Listing 13.2 into the window that appears for the newly created XSD, as shown in Figure 13.32. Press (Ctrl) + (S) when you're done.
                    

<?xml version="1.0" encoding="UTF-8"?><xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"xmlns="urn:rojoconsultancy:sap:po:brm:validation" targetNamespace="urn:rojoconsultancy:sap:po:brm:validation"><xs:element name="OrderApproval"><xs:annotation><xs:documentation>This is the root element that carries the input and  output of the business rules</xs:documentation></xs:annotation><xs:complexType><xs:sequence><xs:element name="OrderAmount" type="xs:int" /><xs:element name="Priority" type="xs:int" /><xs:element name="ApprovalNeeded" type="xs:boolean" /></xs:sequence></xs:complexType></xs:element></xs:schema>
Listing 13.2    POValidationRules.xsd

Figure 13.32    POValidationRules.xsd
Define Aliases for the XML Schema
To define aliases for the XML schema, follow these steps:


                        Navigate back to Rules Modeling, select the Project Resources folder, right-click, and select Open (Figure 13.33).
                        
Figure 13.33    SAP BRM Project Resources


                        Select the Aliases tab, and from the upper-right menu, click on Add • XSD Element (Figure 13.34 and Figure 13.35).
                        
Figure 13.34    Aliases Wizard: Project Resources

Figure 13.35    Aliases Wizard: Creating a New Alias from the XSD Element


                        From the wizard, select OrderApproval under the namespace urn:rojoconsultancy:sap:po:brm:validation, accept the default values, and click on Finish (Figure 13.36).
                        
Figure 13.36    Aliases Wizard: Selecting the XSD Element


                        In the next window, select all entries in the list prefixed with OrderApproval, and press (Ctrl) + (S) when finished. The final result is shown in Figure 13.37.
                    


Figure 13.37    Aliases Wizard: Selecting Aliases from the OrderApproval
Create Flow Ruleset
To create a flow ruleset (to group all business rule components in one set), follow these steps:


                        Select Rules Modeling, and then click on New Flow Ruleset, as shown in Figure 13.38. Enter "POValidationFlowRuleset" as the name of the new flow ruleset. Save your work by pressing (Ctrl) + (S).
                        
Figure 13.38    Creating the New Flow Ruleset


                        Open the folder structure under the new flow ruleset to explore its contents. Notice that there is a basic flow rule created automatically when you open the Rule Flows tab. It should look like the one shown in Figure 13.39. We'll come back to the configuration of that rule flow in the "Configure Rule Flow" section.
                    


Figure 13.39    Rule Flow: MainFlow
Create Decision Table
To create a decision table, follow these steps:


                        Select the new flow ruleset POValidationFlowRuleset, right-click on it, and select New Decision Table, as shown in Figure 13.40.
                        
Figure 13.40    New Decision Table


                        Enter "ApprovalTable" as the name of the decision table and click on Next (Figure 13.41).
                        
Figure 13.41    Decision Table Creation Wizard


                        If everything worked properly in the previous steps, then you should see a window like the one shown in Figure 13.42. Use the small arrow buttons in the middle of the wizard window to move the entries OrderApproval/OrderAmount and OrderApproval/Priority from the Available Conditions to the Selected Conditions at the bottom of the screen. Click on Next.
                        
Figure 13.42    Select Conditions for Decision Table


                        Use the small arrow buttons in the middle of the wizard window to move the OrderApproval/ApprovalNeeded entry from the Available Actions to the Selected Actions at the bottom of the screen (the result is shown in Figure 13.43). Click on Finish.
                    

                        You should now see the new decision table, as shown in Figure 13.44. Enter the values from Table 13.3 into the Condition and Action columns of the decision table. Save your work by pressing (Ctrl) + (S). When you finish, the final result should look like the one shown in Figure 13.45.
                    


Figure 13.43    Select Actions for Decision Table

Figure 13.44    Decision Table with Default Values

Figure 13.45    Decision Table with Condition and Output Values
Configure Rule Flow
Now that you have the decision table in place, you can configure the rule flow part of your previously created flow ruleset (POValidationFlowRuleset), which will contain a graphical representation of the business rule as a flow. After that step, you'll configure a test scenario to test the business rule with XML as input.
Select the POValidationFlowRuleset flow ruleset, and navigate to the Rule Flows tab. You should see the MainFlow rule flow with its default flow, as you saw previously (refer to Figure 13.39).
We'll now model the flow with the aid of the objects from the Rules Composer Palette, which is on the right side of the screen when you open the rule flow (Figure 13.46).
Start modeling the rule flow by dragging and dropping the objects needed to achieve the flow (Figure 13.47). Press (Ctrl) + (S) to save your changes.
As you can see in Figure 13.47, there is a warning inside the decision table activity step in our flow because you still have to tell your rule flow which decision table it should use to execute this step. As you can imagine, at a certain point in a real project, there might be more than one decision table in the same rule flow.
You'll now configure the decision table so that you can finish your rule flow. Select the Decision Table activity on the flow to open its Properties, and then select Browse from the Decision Table dropdown menu, as shown in Figure 13.47.

Figure 13.46    Rule Flow with Rules Composer Palette

Figure 13.47    Rule Flow with Warning
Select ApprovalTable and click on OK (Figure 13.48). Save your changes by pressing (Ctrl) + (S).

Figure 13.48    Decision Table Configuration in Rule Flow
After you've configured the decision table, the rule flow should look like the one shown in Figure 13.49.

Figure 13.49    Rule Flow with Configured Decision Table
There is one last configuration step you have to perform before you can finish the rule flow. The gateway after the start step must be configured to check the input of the business rule. If the validation of the input fails, then the business rule will automatically trigger an exception with a standard error message. You can configure the error message by double-clicking on the error step and entering a text value.
Configure the conditions inside the gateway activity by double-clicking on its symbol and opening its properties. Inside the gateway properties, click on the Conditions tab, and then click on the Edit button. Make sure that your gateway is configured as shown in Figure 13.50.

Figure 13.50    Gateway Activity for Input Validation
Table 13.4 shows the conditions as they must be configured for the gateway activity in your rule flow.




                                Order
                            

                                Name
                            

                                Condition
                            

                                Default Gate
                            





                                1
                            

                                Throw Exception
                            

OrderApproval/Priority Not In 0 , 1 , 2 , 3





                                2
                            

                                Execute Rule
                            

Boolean.TRUE Equals Boolean.TRUE


                                X
                            



Table 13.4    Testing the Business Rule
Next, you'll need to follow these steps:


                        From the POValidationFlowRuleset flow ruleset, navigate to the Test Scenario tab. Click on the Add XML button (Figure 13.51).
                        
Figure 13.51    Test Scenario Tab: Create XML


                        Select POValidationRules.xsd, and click on OK (Figure 13.52).
                    

                        Enter "POvalidationRules.xml" as the name of the new XML file (Figure 13.53), and click on Next.
                        
Figure 13.52    Test Scenario: Select XSD

Figure 13.53    Test Scenario: Create XML


                        Accept the default values, and click on Finish (Figure 13.54).
                        
Figure 13.54    Test Scenario: Select Root Element


                        Copy and paste the XML source code provided in Listing 13.3 into the XML Source tab. Press (Ctrl) + (S) to save your work.
                        <?xml version="1.0" encoding="UTF-8"?><p:OrderApproval xmlns:p="urn:rojoconsultancy:sap:po:brm:validation"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">  <OrderAmount>1001</OrderAmount>  <Priority>3</Priority>  <ApprovalNeeded>false</ApprovalNeeded></p:OrderApproval>
Listing 13.3    POValidationRules.xml


                        From the Test Scenario tab, click on the Add XML button, as shown in Figure 13.55.
                        
Figure 13.55    Test Scenario: Add XML


                        Select POValidationRules.xml, and click on OK (Figure 13.56).
                    


Figure 13.56    Test Scenario: Select XML to Test
After the last step, your test scenario should now contain the XML (POValidationRules.xml) configured as input for the test. In Figure 13.57, you can see the test scenario configured with the input XML. Figure 13.58 also shows the contents of POValidationRules.xml.

Figure 13.57    Test Scenario: XML Input for Test Business Rule

Figure 13.58    Test Scenario: POValidationRules.xml
To support different test cases with the same XML file as input, you can change the values of the XML fields. Just make sure that the XML remains valid and that you save the XML after making any changes.
That's it! You're ready to run your test scenario and check whether your rule works according to the functional and technical requirements. From the Test Scenario tab, click on the Run Test Scenario button, as shown in Figure 13.59.

Figure 13.59    Test Scenario: Run Test Scenario
If everything worked correctly, you should see the results of the test in the Rules Testing Console, as shown in Figure 13.60.

Figure 13.60    Test Scenario: Rules Testing Console
Congratulations! You've officially created your first business rule in SAP PO.









13.7    Summary
In this chapter, we provided an overview of the business background and purpose of business rules inside the enterprise. We saw how business rules are applied to enforce organization policies and business constraints across business processes. You should now be able to recognize the disadvantages of managing your rules using conventional implementation methods and/or limited levels of rules automation.
We then looked to the advantages offered by automated business rules, especially when modeled and maintained using a BRMS platform such as the one provided by SAP. You're now aware of the different functional and technical areas where you can apply business rules. We also explored what SAP BRM has to offer in the gamut of tools and how to work with simple if-then rules and more complex flow rulesets combining distinct types of rule objects, such as rule flows, rule scripts, and, of course, powerful decision tables. Finally, this chapter ended with a list of best practices and design principles to gear you up for the big rules game out there.
In the next chapter, we'll explain the concept of Java proxies and how you can use them in combination with composite applications.








14    Implementing Java ProxiesLogic will get you from A to B. Imagination will take you everywhere.                                                                                                   —Albert EinsteinSAP Business Process Management (SAP BPM) is generally best suited for asynchronous processes, those that don't need to return a direct response to their consumers. Even though an SAP BPM process is technically capable of returning a response, this isn't what it's built for. Especially when dealing with a high-volume and high-performing synchronous composite service, one should consider another alternative. This might sound a bit odd at first glance, but in this chapter, we'll explain why this is the case and a good alternative for supporting synchronous SAP BPM process flows.An SAP BPM process needs to persist the state of the different steps of the process. This continuous combination of serialization and deserialization of data objects creates considerable overhead.A couple of alternatives can be used to accomplish a high volume and performance composite service. Java proxies are one of these alternatives, and they will form the main topic of this chapter. Be aware that Java proxies require programming in Java. You therefore need to have a basic understanding of the Java programming language. Java proxies have pretty much the same capacities as ABAP proxies in the SAP backend. Theoretically speaking, a Java proxy can be abused to create business logic in the middleware layer, but obviously that is not a good idea.In this chapter, we'll explore the concepts and notions you'll need to grasp to become familiar with Java proxies. We'll also provide a practical guide and code snippets to help in your journey of implementing Java proxies.
Note
A basic knowledge of Java is required to gain the full benefit of this chapter.

14.1    Java Proxy Concept and Considerations
The Java proxy runtime is designed to build Java EE applications on the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java) using Enterprise Java Beans (EJBs). These applications can communicate (receive or send messages) with the integration server without the need for special adapters.
Java proxies are Java programs based on the Java application programming interface (API) for XML Web Services (JAX-WS). JAX-WS is a Java programming language API that's used to create web services. It's part of the Java EE platform from Sun Microsystems and included in the SAP NetWeaver AS Java. As a result, Java proxies can be deployed in the SAP Process Orchestration (SAP PO) server and make use of the Java proxy runtime. The Java proxy runtime is designed to build Java applications, which can be called directly without having to configure an Integrated Configuration (ICO) or Integration Flow (iFlow) because the Java proxy runtime is equipped with message processing and queuing mechanisms.
If you've written Java code before to call a web service, then you know what a pain it can be. The level of pain depends of the chosen Java framework. In most cases, a lot of repetitive and grunt work needs to be performed. Luckily for us, when using Java proxies in SAP PO, the pain is lightened by the ability to autogenerate most of the needed classes. The Java classes are generated based on the Web Service Description Language (WSDL). It's possible to reuse the WSDL or service interfaces present in the Enterprise Service Repository (ES Repository) as the basis for generating proxies.
In principle, these proxies can be generated in ABAP or Java. To be able to generate an ABAP proxy, you'll need to have the support of an underlying SAP NetWeaver AS for ABAP. Because SAP PO only runs on the SAP NetWeaver AS Java, the choice is already made for us: we'll need to choose Java proxies.
However, just because Java proxies can be used to support your scenario's needs doesn't mean that you have to use them. Take the following points into consideration before using Java proxies:


                Java proxies require programming in Java, so consider the Java knowledge level within your organization. After all, someone will need to maintain it.
            

                Given that Java proxies are programmed in Java, all the Java best programming practices apply. Bad programming can result in performance penalties.
            

                Use Java proxies as a last resort—when no other SAP PO alternatives meet your needs.
            

                Avoid using Java proxies to implement business logic in the middleware. Just because you can do so doesn't mean you need to.
            

                Java proxies are best used when you require a composite service (or orchestration) of a synchronous nature, high volume, and performance.
            










14.2    Implementation Approaches
There are two main approaches to follow when dealing with proxies: outside-in and inside-out. These approaches will be explored in the next sections.
14.2.1    Outside-In Approach
In this approach, you want SAP PO to act as a service provider to provide a functionality or service that doesn't yet exist. You start by creating the necessary structure of the service interface in the ES Repository of SAP PO. Typically, this will include artifacts such as data types, message types, and service interfaces.
You can then generate a Java proxy based on the WSDL of a service interface. Note that the service interface to be used will need to be of the inbound type. The proxy generated with this method is also generally referred to as a server proxy because the proxy acts as a server—by providing a service. Other names popularly used for it include inbound proxy and receiver proxy.
You might be wondering why such an approach is needed, given that a service can be provided in SAP PO using the normal ICO or iFlow approach. The difference is that ICOs or iFlows generally act as mediators or bridges to call services exposed by other provider systems (such as SAP ERP, SAP Customer Relationship Management [SAP CRM], legacy, etc.), whereas the server proxies make SAP PO act as the provider system (see Figure 14.1).

Figure 14.1    The Java Server Proxy Providing a Web Service
14.2.2    Inside-Out Approach
As depicted in Figure 14.2, the inside-out approach is used to consume a web service that already exists in another application. The WSDLs and XML Schema Definitions (XSDs) of the service to be called will need to be available in the ES Repository of SAP PO.

Figure 14.2    The Java Client Proxy Consuming a Web Service
The outbound service interface available in the ES Repository can then be used to generate a client Java proxy to consume the external service. The generated proxy is often referred to as the client proxy, with the word "client" referring to the fact that the proxy consumes a service and therefore acts as a client. It's also referred to as a consumer proxy, outbound proxy, or sender proxy.
It's important to distinguish between a deployable proxy and a standalone proxy. A deployable proxy is a client proxy that can be deployed in SAP NetWeaver AS Java. It can therefore be consumed by an EJB and a servlet that run on the same Java application server. A standalone proxy, on the other hand, runs on the application side, away from the server. It's mostly used for test purposes in SAP NetWeaver Developer Studio. In this chapter, we'll only address the deployable proxy.









14.3    Technical Implementation
In this section, we'll explore aspects of the development environment to be used to develop proxies. A detailed step-by-step guide to developing Java server and client proxies is also presented.
14.3.1    Development Environment
To develop a Java proxy, we'll need to use SAP NetWeaver Developer Studio as the integrated development environment (IDE). We explored SAP NetWeaver Developer Studio in Chapter 2, Chapter 6, and Chapter 10. One of the first steps is to configure your SAP NetWeaver Developer Studio environment as follows:


SAP NetWeaver AS Java This configuration points to the SAP PO server.
                

Enterprise Service Browser This configuration points to the ES Repository.
                

Details about configuring SAP NetWeaver Developer Studio were presented in Chapter 6, Section 6.1.2.
While implementing a Java proxy, you'll need to switch SAP NetWeaver Developer Studio to the Development Infrastructure perspective. In this perspective, you'll need to create a number of development components (DCs). The DCs to be created for a Java proxy can be of two types: EJB and EAR. Let's describe what these types of DCs are used for.
Enterprise Java Bean Development Component
An EJB DC is used to gather one or multiple enterprise beans into a single deployable unit. After being compiled, it can be deployed to the server in the form of a Java Archive (JAR) file. An EJB DC must always be referenced by an Enterprise Application Archive (EAR) DC.

Figure 14.3    Structure of the EJB Development Component Project
Figure 14.3 shows the structure of the project that an EJB DC generates. The following generated files are important to note:


List of enterprise beans The enterprise beans contain the Java source code and the logic of the functionality to be performed. They are located under the ejbModule folder and the corresponding namespaces.
                    

A deployment descriptor The ejb-j2ee-engine.xml file can be found in the META-INF folder. The file declares the content of the DC, defines the dependencies of the beans in the DC, and details how the Java beans are to be used at runtime. The file is defined in a XML format.
                    

Enterprise Application Archive Development Component
The EAR DC ties together the resources that are required to deploy a JEE enterprise application. It contains dependencies and references to other DCs that are combined together to form an EAR file. From the context of SAP NetWeaver, the DCs referenced by an EAR DC can include the following:


                        EJB module
                    

                        Enterprise application
                    

                        Web module
                    

                        External library
                    

In general, the folder structure of an EAR DC looks like the sample shown in Figure 14.4.

Figure 14.4    Structure of the EAR Development Component Project
This project structure is automatically created for you, and you don't need to bring any modifications to it. Among the files generated, an important one is application-j2ee-engine.xml in the META-INF folder. This is a deployment descriptor for the enterprise application that follows the J2EE specification. The file's main purpose is to associate J2EE modules to a specific EAR file.
14.3.2    Developing a Server Java Proxy
The best way to show how to implement a Java proxy is to use an implementation scenario as an example. Let's start by describing our scenario requirements. To better illustrate the implementation of Java server proxy concepts, we'll build a calculator. As part of our calculator, we'll need to implement the following four operators:


                    Addition
                

                    Subtraction
                

                    Multiplication
                

                    Division
                

Each of these operations has the same request message structure (see Table 14.1). Each operation needs two input parameters of the xsd:integer type.




                            Field Name
                        

                            Data Types
                        





operand1


xsd:integer




operand2


xsd:integer




Table 14.1    Field Names and Data Types of the Request Structure
The same applies for the structure of the response message (see Table 14.2).




                            Field Name
                        

                            Data Type
                        





result


xsd:integer




Table 14.2    Field Name and Data Type of the Response Message
Create an inbound service interface in your ES Repository by using the request and response message structures in Table 14.1 and Table 14.2 to easily follow the instructions and steps presented in the next sections. Figure 14.5 shows the inbound service interface that you need to create in the ES Repository.
The next sections will provide a step-by-step guide to building a server proxy that will provide the calculator operations we just described.

Figure 14.5    Inbound Service Interface to be Used for the Generation of the Server Proxy
Create an Enterprise Java Bean Development Component
First, you need to create an EJB DC to hold the Java source code for the logic of the calculator service. The steps to create a new EJB DC are as follows:


                        Open SAP NetWeaver Developer Studio, and select the Development Infrastructure perspective.
                    

                        Expand the LocalDevelopment node and the MyComponents software component (SC).
                    

                        Right-click on the MyComponents SC, and select New.
                    

                        From the menu that appears, select Development Component.
                    

                        On the next screen, select EJB Module under the Java EE node. Then, click on Next.
                    

                        On the next screen, fill in the vendor name and the name of the DC (see Figure 14.6 1). Then, click on Finish.
                    

                        When asked to switch to the Java EE perspective, click on No 2.
                    


Figure 14.6    Last Steps to Create an EJB DC
After completing the preceding steps, the EJB DC is ready. However, you need to create an EAR DC before proceeding to the EJB implementation.
Create an Enterprise Application Archive Development Component
It's time to create an EAR DC to hold the Java server proxy application. This is the DC that will need to be deployed to the SAP PO server. Follow these steps:


                        From SAP NetWeaver Developer Studio, right-click on the MyComponents SC, and select New. From the menu that appears, select Development Component.
                    

                        On the next screen, select Enterprise Application under the Java EE node. Then, click on Next.
                    

                        On the next screen, fill in the vendor name and the name of the DC (see Figure 14.7 1). Then, click on the Next button.
                        
Figure 14.7    Naming the EAR DC and Setting Up Its Dependencies


                        Leave all the default field values untouched, and click on Next.
                    

                        On the next screen, select the dependency for the EAR DC. For this scenario, you only need to select the EJB DC 2.
                    

                        Click on the Finish button.
                    

                        You're then prompted to switch to the Java EE perspective. Accept by clicking on Yes (Figure 14.8).
                    

                        You're then taken to the main development view for proxies.
                    


Figure 14.8    Option to Switch to the Java EE Perspective
In the next sections, we'll import the WSDL of the inbound service interface that will form the basis on which the proxy will be generated.
Import the Service Interface
Now that the DCs of the EJB and EAR projects have been created, it's time to import the inbound service interface from the ES Repository. An inbound service interface is used because the proxy needs to act as the service provider. Be aware that as a prerequisite to importing the service interface, SAP NetWeaver Developer Studio must have been configured to point to the ES Repository. To do so, follow these steps:


                        From the Java EE perspective, expand the EJB DC (calculator_ejb in this example), and navigate to the ejbModule node.
                    

                        Right-click on ejbModule, and select the Import option from the context menu (Figure 14.9 1).
                        
Figure 14.9    First Steps of Importing a Service Interface from the ES Repository


                        On the next screen, select the WSDL option under the Web Services node 2. Then, click on Next to proceed with the wizard.
                    

                        You're then prompted to specify the source of your WSDL. You can choose from among Enterprise Service Repository, Remote Location/File System, or Services Registry radio buttons. For simplicity, use the ES Repository. Click on Next to proceed. You'll need to authenticate yourself (Figure 14.10 1).
                    

                        On the next screen, select the desired inbound service interface from the ES Repository (Figure 14.10 2).
                    

                        Click on Finish.
                    


Figure 14.10    Selecting the Inbound Service Interface from the ES Repository
The selected inbound service interface is then imported and available in the EJB DC, under the ejbModule node or at the bottom of the project, as shown in Figure 14.11. Now, it's time to move to the next task of generating a server proxy.

Figure 14.11    The Imported Inbound Service Interface in the Project
Generate the Server Proxy
Now that the WSDL of the inbound service interface is available in the project, it's time to generate Java code based on its WSDL. During this generation process, a number of Java classes are created to represent all the data types.
In addition, a method is created for each operation in the inbound service interface. These methods form the entry points for the Java server proxy. This is where you'll need to write the source code to perform the logic of the server proxy. Follow these steps to generate the server proxy from the imported WSDL:


                        Right-click on the imported WSDL, and select Web Services • Generate Java Bean Skeleton.
                    

                        On the next screen, move the slider to the Assemble service level (Figure 14.12).
                        
Figure 14.12    Seting the Configuration of the Web Service to Assemble Service


                        Other than moving the slider in the upper section of the screen to the Assemble service level, the rest of the values should remain untouched (keep the default values). Just in case, however, check that the values are set as indicated in Table 14.3.
                        


Attribute
Value




Web service type
Top-down Java Bean web service


Server
SAP server


Level of server generation
Assemble service


Web service runtime
SAP NetWeaver


Client type
No client



Table 14.3    Settings for Web Service Configuration Values


                        Follow the wizard, leaving all default values. You'll then see a pop-up prompting you to update the provided WSDL with endpoints; select Don't Update WSDL. Because you've imported the WSDL from the ES Repository, there are no endpoints assigned to the service. In SAP PO, the endpoints are only available from the directory and not in the ES Repository.
                    

                        Follow the rest of the wizard by selecting Next and leaving the proposed default values.
                    

                        On the last screen of the wizard, when asked to select one or more options for JAXB global customizations, select all options (see Figure 14.13).
                        
Figure 14.13    Global Customizations Options


                        Click Finish.
                    

                        If there are some name conflicts in the generated objects, then you'll be prompted with a message. In such a case, click on the Resolve Collisions button to resolve the collisions (see Figure 14.14).
                        
Figure 14.14    Screen to Resolve Collisions


                        Click on the OK button to proceed to the Java code generation. Be aware that the generation of source code might be slow and run for a couple of seconds, depending on the resources of your computer.
                    

Implement the Calculator Service
After the Java source code for the proxy has been generated in the previous steps, it's time to add some logic. Notice that the generated source code is placed in the package that matches the namespace of the inbound service interface used for the generation (Figure 14.15).
Figure 14.15 shows that a package named com.rojoconsultancy.book.demo.calculator was created. This package matches the namespace of the WSDL, which is http://rojoconsultancy.com/book/demo/calculator.
In the Java package, a class is generated for all involved message types and data types. In addition, for every element of the XSD data type, a Java class attribute is created with the corresponding Java data types.

Figure 14.15    Java Classes Generated for the Server Proxy
The main class from which we need to add our logic always ends with the suffix ImplBean.java. Looking at the list of classes presented in Figure 14.15, our implementation will need to be added in the class called CalculatorSyncInboundImplBean.
Figure 14.16 shows what the CalculatorSyncInboundImplBean class looks like when it has been freshly generated. Note that there is a Java method for every operation in the inbound service interface. A code snippet of a demonstration implementation is represented in Listing 14.1.
@RelMessagingNW05DTOperation(enableWSRM = false)public com.rojoconsultancy.book.demo.calculator.CalculatorResponse add(com.rojoconsultancy.book.demo.calculator.CalculatorAddRequest MT_CalculatorAddRequest)throws com.rojoconsultancy.book.demo.calculator.FaultMessage_Exception {                     BigInteger operand1 = null,operand2 = null;//Retrieve input parametersif(MT_CalculatorAddRequest!=null){operand1 = MT_CalculatorAddRequest.getOperand1();operand2 = MT_CalculatorAddRequest.getOperand2();}//Build response messagescom.rojoconsultancy.book.demo.calculator.CalculatorResponse result = new CalculatorResponse();result.setResult((operand1.add(operand2)).doubleValue());return result;}
Listing 14.1    Snippet of Source Code for the Add Implementation

Figure 14.16    CalculatorSyncInboundImplBean Class Generated with Empty Method Implementation
Build and Deploy the EAR DC to the SAP PO Server
After writing the source code of your service logic in the different Java methods, it's time to compile and deploy the EAR DC to the server. To do so, follow these steps:


                        Right-click on the EAR DC, and select Development Component • Build from the menu (see Figure 14.17).
                    

                        You'll then see a pop-up prompting you to select the DCs to be built; make sure to select both EJB and EAR DCs (see Figure 14.18).
                    

                        Click on OK. It might take a few seconds to compile the DCs.
                    

                        Go back to the EAR DC. Right-click on it, and select Development Component • Deploy from the menu.
                    


Figure 14.17    Building Both EJB and EAR DCs

Figure 14.18    Selecting Both EJB and EAR DCs
Configure the Deployed Service from SAP NetWeaver Administrator
After successfully deploying both DCs in the previous steps, you need to perform some configurations for the developed web service to become available for use. One of the first steps is to find the web service that you just deployed.
Follow these steps to apply the required settings:


                        Go to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                        Once logged in, navigate to the SOA tab and the Application and Scenario Communication subtab.
                    

                        On the new page, click on the Single Service Administration link. The new page that opens allows you to search for deployed web services.
                    

                        From the Single Service Administration tab, you need to input the name of the inbound service interface that was used to generate the Java server proxy in the earlier steps. In this case, search for the term "Calculator_Sync_Inbound" (Figure 14.19).
                        
Figure 14.19    Selecting the Inbound Service Interface from the Single Service Administration in SAP NetWeaver Administrator


                        After filling in the search term in the Find text field, click on the Go button to trigger the search. Select the returned entry, as shown in Figure 14.19.
                    

                        Go to the Configuration tab, and click on the New button to start a new configuration (Figure 14.20).
                        
Figure 14.20    Configuration Tab of the Single Service Administration Application


                        A wizard launches. The first step of the wizard is the General step, in which you can opt to rename the service's endpoint. If you don't have any special requirement for that, then just keep the default settings. Click on the Next button to proceed to the next step.
                    

                        The next step of the wizard is the Security step (see Figure 14.21) where there are a lot of configurable options. You can configure a number of security settings of the web service, including the following:
                        

Transport Protocol Configure whether you prefer to provide the server proxy as a web service based on HTTP or HTTPS. By default, HTTP is selected.
                            

Authentication Configure how the consumer users should authenticate. The User ID/Password and Logon Ticket checkboxes are selected by default.
                            

Message Security Configure whether the incoming message needs to be signed or encrypted. By default, none of these settings are selected.
                            


Figure 14.21    Security Step during the Configuration of the New Server Proxy


                        Click on Next to move to the Web Service Addressing step. For simplicity's sake, leave the default settings as is.
                    

                        Click on the Next button to provide Transport Settings details. The default values provided for this screen are sufficient for most requirements, so it's optional to change these settings.
                    

                        Click on the Finish button to complete the web service configuration.
                    

As Figure 14.22 shows, when the configuration is finished, you'll have a new entry in the Service Endpoint list. Be aware that you can configure more than one endpoint and make each one behave differently.

Figure 14.22    Completed Web Service Configuration
Test the Deployed Service from SAP NetWeaver Administrator
Now, you're ready to test your newly created and configured server proxy. Follow these steps:


                        Select the WSDLs tab.
                    

                        From this tab, select the WSDL line of your choice and click on the Test button (see Figure 14.23). A new wizard will start to allow you to run tests.
                    


Figure 14.23    Testing the Web Service Created Using the Java Server Proxy
Be aware that if you have multiple endpoints configured, then you'll also end up with more than one WSDL in this tab. Furthermore, you can download the WSDL of the server proxy web service to your local machine via the ZIP Download button.

Note
During a real-life implementation, it's advisable to expose a server proxy service via the Advanced Adapter Engine Extended (AEX). It's better to have an ICO or iFlow consume the server proxy and to let the consumers call the ICO/iFlow service instead of directly exposing your server proxy to consumers (see Figure 14.24).

Figure 14.24    Consuming the Server Proxy via the ICO or iFlow

14.3.3    Developing a Client Java Proxy
Similar to the server proxy section, we'll use an example scenario to easily guide you through the explanation of the steps involved when creating a client proxy.
Let's assume that you want to create a Java client proxy to consume a currency web service that is publicly provided by WebserviceX.NET. The WSDL of the web service can be found at http://www.webservicex.net/currencyconvertor.asmx?WSDL.
As Listing 14.2 shows, the request message of the service takes in the FromCurrency and ToCurrency attributes as input parameters.
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"  xmlns:web="http://www.webserviceX.NET/"><soapenv:Header/><soapenv:Body><web:ConversionRate><web:FromCurrency>USD</web:FromCurrency><web:ToCurrency>EUR</web:ToCurrency></web:ConversionRate></soapenv:Body></soapenv:Envelope>
Listing 14.2    Example Request Message for the Currency Convertor Service
As shown in Listing 14.3, the web service responses provide the conversion rate between the two currencies provided in the request message.
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><soap:Body><ConversionRateResponse mlns="http://www.webserviceX.NET/"><ConversionRateResult>0.7716</ConversionRateResult></ConversionRateResponse></soap:Body></soap:Envelope>
Listing 14.3    Example Response Message for the Currency Convertor Service
You should call the external service via the AEX, so use the following approach:


                    Import the definitions of the external web service in your ES Repository as external definitions.
                

                    Create an ICO or iFlow to call the external service.
                

                    Build the client proxy based on the ICO or iFlow. Your client proxy calls the ICO or iFlow, which in turn calls the external service. See a graphical representation of this situation in Figure 14.25.
                


Figure 14.25    Client Proxy Calling the External Service via the ICO or iFlow
The next sections will provide a step-by-step guide to building a client proxy to consume an external web service.
Import the WSDL of the External Web Service in the ES Repository
Follow these steps to make the WSDL of the external service available in the ES Repository:


                        Download the WSDL to your local file system.
                    

                        Open the ES Repository, and create a namespace that matches the external service. This namespace can be found in the WSDL.
                    

                        Import the WSDL as an external definition, as shown in Figure 14.26.
                        
Figure 14.26    Importing the WSDL of an External Web Service as an External Definition in the ES Repository


                        Follow the rest of the wizard to select the WSDL file that you saved in your local file system.
                    

                        Create an outbound service interface that uses the imported WSDL.
                    

Create EJB and EAR Development Components
Create both EJB and EAR DCs to hold the Java client proxy. The steps involved in creating an EJB or EAR DC were described when creating the Java server proxy in Section 14.3.2. To create these DCs, use the following details:


                        EJB DC
                        

                                DC name: currencyconv_ejb


                                Vendor: rojoconsultancy.com
                            



                        EAR DC
                        

                                DC name: compositeapp_ear


                                Vendor: rojoconsultancy.com
                            



Make sure to link compositeapp_ear to currencyconv_ejb. This will ensure that when the compositeapp_ear DC is deployed, the currencyconv_ejb DC is also automatically deployed.
Import the Service Interface
To import the WSDL, follow these steps:


                        Open the EJB DC. Expand the project, right-click on the ejbModule node, and select Import.
                    

                        In the pop-up that appears, select the WSDL option. Click on Next to follow the wizard.
                    

                        On the next screen, select Enterprise Service Repository. You'll need to authenticate yourself.
                    

                        The next screen prompts you to select the desired outbound service interface from the ES Repository (see Figure 14.27). This is the outbound service interface that represents the external service to be called. For our example, select the CurrencyConvertor_Sync_Out service interface.
                    

                        Click on Finish.
                    


Figure 14.27    Importing the Currency Convertor Outbound Service Interface in the EJB DC
Generate the Client Proxy
Now that the outbound service interface is available in the project, it's time to generate Java code based on its WSDL. During this generation process, a number of Java classes are created to represent all the data types.
In addition, a method is created for each operation in the outbound service interface. Follow these steps to generate the client proxy from the imported WSDL:


                        Right-click on the imported WSDL, and select Web Services • Generate Client (see Figure 14.28).
                    

                        On the next screen, move the slider to the Assemble client level (Figure 14.29).
                        
Note
Except for moving the slider in the upper section of the screen to the Assemble client level, the values should be left set to their defaults.


Figure 14.28    Menu Option to Generate the Client Proxy Based on a WSDL

Figure 14.29    Set the Configuration of the Web Service to Assemble Client


                        Follow the wizard, leaving all default values. A pop-up prompts you to update the provided WSDL with endpoints; select Do Not Update WSDL. Because the WSDL has been imported from the ES Repository, there are no endpoints assigned to it. In SAP PO, the endpoints are only available from the directory and not in the ES Repository.
                    

                        Follow the rest of the wizard by clicking on Next and leaving the default values.
                    

                        On the last screen, when asked to select one or more options for the JAXB global customizations, check all options.
                    

                        Click on Finish.
                    

Note that the generated source code is placed in the package that matches the namespace of the outbound service interface used for the generation (see Figure 14.30).

Figure 14.30    Java Classes Generated for the Client Proxy
Provide a Wrapper Class for the Java Client Proxy
The generated Java client proxy can't be called yet as a web service from SAP NetWeaver; first, you'll need to add a wrapper Java class in front of the client proxy. This new wrapper class will then expose the functionality of the client proxy as a web service.
In addition to providing functionality as a web service, the purpose of this wrapper will be to create an abstraction layer between your own code and the generated code.
The steps required to add the wrapper are as follows:


                        Add a new package in your project. This package is intended to hold the wrapper bean. For simplicity, add the suffix ".wrapper" to your existing package. This means that your new package will be called net.webservicex.wrapper.
                    

                        Create a session bean to wrap the generated code of the client. Right-click on the newly created package, and choose New • Session Bean (EJB 3.x) (see Figure 14.31).
                        
Figure 14.31    Creating a Session Bean to Host the Wrapper Code


                        A new wizard starts; fill in the details as shown in Figure 14.32.
                    

                        Follow the wizard, and keep all the default values unchanged. At the end of the wizard, click on Finish.
                    


Figure 14.32    Filling in Details of the Session Bean to Wrap the Client Proxy
In the newly created bean, you'll need to implement your wrapper for the methods that exist in the class named CurrencyConvertorSyncOut.Java. An easy way to achieve that is to add a method in your new session (CurrencyConvertorClient) with the same signature. Listing 14.4 shows an example implementation.
package net.webservicex.wrapper;import javax.ejb.Stateless;import javax.xml.ws.WebServiceRef;import net.webservicex.ConversionRateResponse;import net.webservicex.CurrencyConvertorSyncOut;import net.webservicex.CurrencyConvertorSyncOutService;/*** Session Bean implementation class CurrencyConvertorClient*/@Statelesspublic class CurrencyConvertorClient implements CurrencyConvertorClientLocal {@WebServiceRef(name = "CurrencyConvertor_Sync_Out")CurrencyConvertorSyncOutService currencyConvertorService;/*** Default constructor.*/public CurrencyConvertorClient() {// TODO Auto-generated constructor stub}@SuppressWarnings("null")public net.webservicex.ConversionRateResponse currencyConvertorSyncOut(net.webservicex.ConversionRate request){    ConversionRateResponse currencyConvertorResponse = null;    CurrencyConvertorSyncOut port = null;try {currencyConvertorService.getPort(CurrencyConvertorSyncOut.class);        } catch (Exception e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        //Call the client proxycurrencyConvertorResponse = port.currencyConvertorSyncOut(request);    return currencyConvertorResponse;}}
Listing 14.4    Source Code for the Wrapper Class of the Client Proxy
From the source code shown in Listing 14.4, note the following:


                        Make sure to implement the wrapper in the CurrencyConvertorClient class (known as the implementation class) and not in the CurrencyConvertorClientLocal (known as the interface).
                    

                        The annotation @WebServiceRef is used to define a reference to a web service, and it's an injection target. It can be used to inject both service and proxy instances. The name after this annotation can be found in the CurrencyConvertorSyncOutService class.
                    

                        A variable needs to be declared to point to the CurrencyConvertorSyncOutService.
                    

                        An instance of the port object CurrencyConvertorSyncOut needs to be created. Furthermore, the port object will need to be retrieved or initialized from the Service object. The port object can be used to call the different client methods. Finally, the output of the method call can be returned as the response of the Java server proxy.
                    

Build and Deploy the EAR DC to the SAP PO Server
After completing the implementation of the wrapper class, it's time to compile and deploy the EAR DC to the server. The procedure to build and deploy was explored in Section 14.3.2.
Configure the Deployed Service from SAP NetWeaver Administrator
For the deployed wrapper class to properly work, we need to perform some configurations in SAP NetWeaver Administrator. Follow these steps to apply the needed settings:


                        Go to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                        Once logged in, navigate to the SOA tab and the Application and Scenario Communication subtab.
                    

                        On the new page, click on the Single Service Administration link. The new page that opens allows you to search for deployed web services.
                    

                        Select Consumer Proxies, and search for the client proxy (see Figure 14.33).
                        
Figure 14.33    Consumer Proxies Configuration in the Single Service Administration Application

Note
Note that, by default, a configuration of the XI 3.0 type already exists. If your ICO or iFlow uses the XI 3.0 protocol in its sender communication channel, then you'll need to edit the logical ports and maintain the sender component, as shown in Figure 14.34. This sender component needs to be the same as the one used in the ICO or iFlow.

Figure 14.34    Maintaining the Sender Component Value for an XI 3.0 Connectivity to the AEX



                        If you'd prefer to use plain Simple Object Access Protocol (SOAP), click on the New button (above the Logical Port section), as shown in Figure 14.34. This will launch a new wizard and allow you to select SOAP Transport Binding (see Figure 14.35).
                        
Figure 14.35    New Client Proxy Configuration Using SOAP as Transport Binding


                        Follow the wizard. When asked for an endpoint to the WSDL, provide the WSDL obtained from the ICO or iFlow. You'll need to provide a WSDL that contains an endpoint, and you might also need to add login credentials.
                    

                        Follow the rest of the wizard until it completes.
                    

Congratulations! You've successfully completed the development and configuration of your first consumer or client proxy.









14.4    Building an Orchestration
You're now familiar with the notions of server and client proxies. Imagine a scenario that requires you to create a composite service calling multiple web services. This scenario can be classified as an orchestration. There are obviously other ways to achieve this goal, but Java proxies can also be used to build a composite service. One of the main disadvantages of using a Java proxy for an orchestration is that you'll need to write Java code for it instead of configuring it in a graphical manner, but when it comes to performance, you won't be disappointed with Java proxies.
To build a composite service, use the following general steps:


                Create a client proxy for each web service to be consumed by the orchestration.
            

                Create a server proxy to orchestrate all of the individual client proxies.
            

                As Figure 14.36 illustrates, from the Java server proxy, you can add the necessary logic to orchestrate different client proxies. These client proxies are called via their wrapper classes (as described in Section 14.3.3).
            


Figure 14.36    Orchestrating Different Client Proxies from the Server Proxy
For a clear separation of the different clients and the server proxy, it's advisable to create an EJB DC for each of them. Based on Figure 14.36, you'll need to create four DCs: three for the client proxies and one for the server proxy. Refer to the exercise in this chapter for a step-by-step guide to creating an orchestration or composite service using Java proxies, which you can find in the online download.









14.5    Exercise: Implementing Java Proxies
This exercise centering on Java Proxies builds on the scenario initiated in Chapter 6. In that scenario, you built an iFlow to convert the price quoted in USD to various currencies. This iFlow called an external web service that provides currency conversion rates. It took two currency input parameters and returned an exchange rate as a response.
Now, you need to extend the service with a third input parameter to hold the amount to be converted. Table 14.4 presents the list of input parameters that the new proxy needs to hold.




                        Input Parameter
                    

                        Data Type
                    

                        Example
                    





                        Source currency
                    

xsd:string


                        USD
                    



                        Target currency
                    

xsd:string


                        EUR
                    



                        Amount
                    

xsd:double


                        100
                    



Table 14.4    Input Parameters for the Proxy
After calling the proxy, it needs to return the equivalent amount converted to the target currency (Table 14.5).




                        Input Parameter
                    

                        Data Type
                    

                        Example
                    





                        Converted amount
                    

xsd:double


                        87
                    



Table 14.5    Output Parameter for the Proxy
As a result, you've decided to build a Java proxy to implement the required functionality.
14.5.1    Exercise Solution Approach
Because you already have an iFlow that returns a conversion rate based on two currency input parameters, you can leverage that iFlow. Your new proxy should act as a wrap around the existing iFlow. The new proxy should then work as follows:


                    Upon the arrival of the new request message (with three input parameters), the two currency inputs are extracted.
                

                    The two extracted currency inputs are then used to call the iFlow service (this service was provided as part of the Chapter 6 exercise).
                

                    Upon receiving the response from the iFlow (a conversion rate), you'll need to multiply it by the third input of the original message (the amount to be converted). As a formula, the logic can be represented as follows:
Converted amount = conversion rate × amount


To achieve this goal, perform these high-level steps:


                    Create a Java client proxy to call the existing currency conversion service (from the iFlow).
                

                    Create a Java server proxy to host the implementation.
                

                    Build the logic, and let the server proxy orchestrate the client proxy.
                

Each of these steps will be detailed in the next section, using a step-by-step solution approach.

Note
Be aware that the implementation of this exercise requires an understanding of and a background in Java development.

14.5.2    Exercise Step-by-Step Solution
This section will further explore the solution by detailing each step, including how to do the following:


                    Create a Java client proxy
                

                    Create a Java server proxy
                

                    Build an orchestration logic
                

                    Deploy the solution
                

                    Configure the deployed service
                

Create a Service Interface in the Enterprise Services Repository
You need to create an inbound service interface to be used for the Java server proxy generation. You need to create the underlying data type and message interface. The request and response structures need to be built to match Table 14.4 and Table 14.5. You can use the names specified in Table 14.6 for the data type, message type, and service interface.




                                ES Repository Object
                            

                                Name
                            





                                Request data type
                            

DT_AmountConversionRequest




                                Request message type
                            

MT_AmountConversionRequest




                                Response data type
                            

DT_AmountConversionResponse




                                Response message type
                            

MT_AmountConversionResponse




                                Inbound service interface
                            

SIIS_AmountConversion




Table 14.6    Details of the ES Repository Object to be Created
Note that the service interface needs to be of the inbound type because that is required for the Java server proxy.
After working through the book exercises so far, you're already familiar with how to create the different ES Repository objects, so we won't go over that portion again here.
Create the Java Client Proxy
The first step is to create a Java client proxy. This proxy acts as a wrapper to the service provided by the iFlow to call the external web service. However, you need to start by creating the EJB DC that will host the client proxy. Creating a client proxy requires couple of steps including:


                        Creating an Enterprise Java Bean development component
                    

                        Importing a service interface
                    

                        Generating a client proxy
                    

                        Providing a wrapper class
                    

                        Exposing public parts
                    

Each one of these steps will be explored next.
Create an Enterprise Java Bean Development Component
The steps involved to create a new EJB DC are as follows:


                            Open SAP NetWeaver Developer Studio, and select the Development Infrastructure perspective.
                        

                            Expand the LocalDevelopment development configuration node.
                        

                            Then expand the MyComponents SC.
                        

                            Right-click on the MyComponents SC, and select New. From the menu that opens, select Development Component. On the next screen, select the EJB Module under the Java EE node. Then, click on the Next button (see Figure 14.37).
                            
Figure 14.37    Creating a DC of Type EJB


                            On the next screen, fill in the vendor name and the name of the development component (see Figure 14.38). Click on Finish.
                        

                            When asked to switch to the Java EE perspective, click on Yes.
                        

It's now time to add the WSDL of the outbound service interface that your proxy will call.

Figure 14.38    Details of the Client Java Proxy DC
Import the Service Interface
Now that the EJB DC is in place, it's time to import the outbound service interface that was previously created in the ES Repository. This is the same outbound service interface that was used for the iFlow in the Chapter 6 exercise. Follow these steps:


                            From the Java EE perspective, expand the EJB DC (conversionrateclient_ejb in this case), and navigate to the ejbModule node.
                        

                            Right-click on ejbModule, and select the Import option from the context menu (see Figure 14.39).
                            
Figure 14.39    Importing the Outbound Service Interface


                            On the next screen, select the WSDL option under the Web services node. Then, click on Next to proceed with the wizard.
                        

                            On the next screen, select Enterprise Service Repository. You'll need to authenticate yourself.
                        

                            Select the desired outbound service interface from the ES Repository on the next screen (see Figure 14.40).
                            
Figure 14.40    Picking the Outbound Service Interface from the ES Repository


                            Click on Finish.
                        

Now that the outbound service interface is available in the project, you can autogenerate Java classes based on its WSDL that will act as a Java client proxy.
Generate the Client Proxy
During this generation process, a number of Java classes are created to represent all the data types. In addition, a method is created for each operation in the outbound service interface. Follow these steps to generate the client proxy from the imported WSDL:


                            Right-click on the imported WSDL, and select Web Services and then Generate Client (see Figure 14.41).
                        

                            On the next screen, move the slider to the Assemble client level.
                            
Figure 14.41    Generation of the Java Client Proxy from the Imported WSDL


                            Follow the wizard, leaving all default values as is. You'll see a pop-up prompting you to update the provided WSDL with endpoints; select Do Not Update WSDL. Because the WSDL has been imported from the ES Repository, there are no endpoints assigned to it. In SAP PO, the endpoints are only available from the directory and not in the ES Repository.
                        

                            Follow the rest of the wizard by clicking on Next and leaving the default values as is.
                        

                            On the last screen, when asked to select one or more options for the JAXB global customizations, select all options.
                        

                            Click on Finish.
                        

A number of Java packages and classes will be created. You're now ready to create a wrapper class to expose the functionality of the Java client proxy.
Provide a Wrapper Class for the Client Proxy
The generated Java client proxy can't yet be called as a web service from Java server proxy. You need to add a wrapper Java class in front of the client proxy. The wrapper class will then expose the functionality of the client proxy as a web service, and this web service can in turn be called by the server proxy later on.
The steps required to add a wrapper are as follows:


                            Add a new package in your project. For simplicity's sake, add the suffix ".wrapper" to your existing package. As a result, the new package will be called com.readersparadise.scm.procurement.erp.wrapper (see Figure 14.42).
                        

                            Create a session bean to wrap the generated code of the client. Right-click on the newly created package, and choose New and then Session Bean (EJB 3.x) (see Figure 14.42).
                            
Figure 14.42    Creating a Package or Session Bean to Host the Wrapper Code


                            A new wizard opens. Fill in the details of the wrapper class, as specified in Figure 14.43.
                        

                            Follow the wizard, and keep all the default values unchanged. At the end of the wizard, click on Finish.
                        


Figure 14.43    Details of the Session Bean to Wrap the Client Proxy
As a result, two classes are created: CurrencyConversionClient and CurrencyConversionClientLocal. In the newly created CurrencyConversionClient bean, you need to implement your wrapper for the method that exists in the SIOSReadersParadisePortal.Java class and which resides in the com.readersparadise.currency.portal package.
The content of the SIOSReadersParadisePortal.Java class is presented in Listing 14.5. This class contains a method called siosReadersParadisePortal. This generated method is responsible for calling or triggering the service call of the client proxy. You'll now wrap this method with your own method to be provided in your newly created CurrencyConversionClient.
package com.readersparadise.currency.portal;/** * Service Endpoint Interface (generated by SAP WSDL to Java generator). */@javax.jws.WebService(name = "SIOS_ReadersParadisePortal", targetNamespace = "urn:readersparadise.com:currency:portal")@javax.jws.soap.SOAPBinding(parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE, style = javax.jws.soap.SOAPBinding.Style.DOCUMENT, use = javax.jws.soap.SOAPBinding.Use.LITERAL)public interface SIOSReadersParadisePortal {  /**   * Java representation of web method [SIOS_ReadersParadisePortal].   */  @javax.jws.WebMethod(operationName = "SIOS_ReadersParadisePortal", action = "http://sap.com/xi/WebService/soap1.1")  @javax.jws.WebResult(name = "ConversionRateResponse", targetNamespace = "http://www.webserviceX.NET/", partName = "parameters")  public net.webservicex.ConversionRateResponse siosReadersParadisePortal(@javax.jws.WebParam(name = "ConversionRate", targetNamespace = "http://www.webserviceX.NET/", partName = "parameters") net.webservicex.ConversionRate parameters);}
Listing 14.5    Source of the SIOSReadersParadisePortal.Java Class
Now, add a new method in your newly created wrapper bean (CurrencyConversionClient). For simplicity's sake, give this new method the same name and signature as the one presented in Listing 14.5. The resulting implementation of the wrapper class is presented in Listing 14.6.
package com.readersparadise.scm.procurement.erp.wrapper;import javax.ejb.Stateless;import javax.xml.ws.WebServiceRef;import net.webservicex.ConversionRateResponse;import com.readersparadise.currency.portal.SIOSReadersParadisePortal;import com.readersparadise.currency.portal.SIOSReadersParadisePortalService;/** * Session bean implementation class CurrencyCoversionClient */@Statelesspublic class CurrencyCoversionClient implements CurrencyCoversionClientLocal {    @WebServiceRef(name = "SIOSReadersParadisePortal")    SIOSReadersParadisePortalService currencyConvertorService;    /**    * Default constructor.     */    public CurrencyCoversionClient() {        // TODO Auto-generated constructor stub    }    public net.webservicex.ConversionRateResponse siosReadersParadisePortal(net.webservicex.ConversionRate request)    {        ConversionRateResponse currencyConvertorResponse = null;        SIOSReadersParadisePortal port = null;        try {            currencyConvertorService.getPort(SIOSReadersParadisePortalService.class);        } catch (Exception e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        //Call the client proxy        currencyConvertorResponse = port.siosReadersParadisePortal(request);        return currencyConvertorResponse;    }}
Listing 14.6    Implementation of CurrencyConversionClient.Java
Furthermore, to be able to access the wrapped method from outside, you need to list these methods in the CurrencyConversionClientLocal interface class, as shown in Listing 14.7.
package com.readersparadise.scm.procurement.erp.wrapper;import javax.ejb.Local;@Localpublic interface CurrencyConversionClientLocal {    public net.webservicex.ConversionRateResponse siosReadersParadisePortal(net.webservicex.ConversionRate request);}
Listing 14.7    Implementation of the CurrencyConversionClientLocal Bean
Expose Public Parts for Client Development Component
For the request and response messages of the client DC (conversionrateclient_ejb) to be accessed from outside (server proxy), you need to expose the relevant (request and response) classes using public parts. To expose the classes as public parts, follow these steps:


                            Open SAP NetWeaver Developer Studio, and select the Development Infrastructure perspective.
                        

                            Expand the LocalDevelopment development configuration node.
                        

                            Expand the MyComponents SC.
                        

                            Select the conversionrateclient_ejb client DC. The properties of the SC are displayed on the right side.
                        

                            Choose the Public Parts tab.
                        

                            Right-click on the Client node, and choose the Manage Entities option (see Figure 14.44).
                            
Figure 14.44    Managing the Reference of Entities


                            Select the Java Package node and then the relevant package in which the request/response structure is located (in this case, webservicex; see Figure 14.45).
                        

                            Click on the Finish button.
                        

The classes contained in the net.webservicex package can now be used by external classes with the help of the public part mechanism.
You're now ready to create a Java server proxy.

Figure 14.45    Selecting the Package to be Exposed with the Public Part
Create the Java Server Proxy
You need to create a Java server proxy that will hold and host the conversion logic and the orchestration of the Java client proxy. The steps required to create a Java server proxy will be explored next, including the following:


                        Creating an enterprise Java Bean development component
                    

                        Creating dependencies
                    

                        Importing a service interface
                    

                        Generating the server proxy
                    

Create an Enterprise Java Bean Development Component
The steps involved to create a new EJB DC are as follows:


                            Open SAP NetWeaver Developer Studio, and select the Development Infrastructure perspective.
                        

                            Expand the LocalDevelopment development configuration node.
                        

                            Expand the MyComponents SC.
                        

                            Right-click on the MyComponents SC, and select New. From the next menu, select Development Component. On the next screen, select the EJB Module under the Java EE node. Click on Next.
                        

                            On the next screen, fill in the vendor name and the name of the DC (see Figure 14.46). Click on Finish.
                            
Figure 14.46    Details of the Server Proxy to Host Implementation


                            When asked to switch to the Java EE perspective, click on No.
                        

Create Dependencies
For the newly created server DC to be able to use the functionalities exposed by the client DC, you need to define dependencies between them. Follow these steps:


                            Stay in the Development Infrastructure perspective, and select the server DC. The properties of the SC are displayed on the right side.
                        

                            Choose the Dependencies tab.
                        

                            Click on the Add button. You'll see a new pop-up screen where you need to select the client DC (see Figure 14.47).
                            
Figure 14.47    Adding Dependencies on the Server DC to the Client DC


                            Click on the Finish button.
                        

Import the Service Interface
Now that the EJB DC is in place, it's time to import the inbound service interface that was created in the ES Repository. To do so, follow these steps:


                            From the Java EE perspective, expand the EJB DC (conversionserver_ejb in this case) and navigate to the ejbModule node.
                        

                            Right-click on ejbModule, and select the Import option from the context menu.
                        

                            On the next screen, select the WSDL option under the Web services node (see Figure 14.48). Click on Next to proceed with the wizard.
                            
Figure 14.48    Select the Type of Object to be Imported


                            On the next screen, select Enterprise Service Repository as your WSDL source. Click on Next.
                        

                            Navigate through the ES Repository, and select the inbound service interface that you previously created (see Figure 14.49). Click on the Finish button.
                        


Figure 14.49    Selecting the Appropriate Inbound Service Interface
The newly imported service interface is now available within the DC. It can be seen under the ejbModule node of the project structure. It's now time to autogenerate some skeleton Java source code.
Generate the Server Proxy
To generate skeleton Java code from the imported WSDL file, follow these steps:


                            Right-click on the imported WSDL, and select Web Services • Generate Java bean skeleton.
                        

                            On the next screen, move the slider to the Assemble client level (see Figure 14.50).
                        

                            Follow the wizard, and leave all default values intact.
                        

                            You'll see a pop-up prompting you to update the provided WSDL with endpoints; select Do Not Update WSDL. Because you imported the WSDL from the ES Repository, there are no endpoints assigned to the service. In SAP PO, the endpoints are only available from the directory and not in the ES Repository.
                            
Figure 14.50    Set the Configuration of the Web Service to the Assemble Client Level


                            Follow the rest of the wizard by clicking on Next and leaving the proposed default values.
                        

                            On the last screen of the wizard, when asked to select one or more options for JAXB global customizations, select all options (see Figure 14.51).
                            
Figure 14.51    Global Customizations Options


                            Click on the Finish button.
                        

                            If there are some name conflicts among the generated objects, then you'll be prompted with a message. If this happens, click on the Resolve Collisions button.
                        

                            Click on the OK button to proceed to the Java code generation.
                        

Now, several Java classes have been created. Figure 14.52 shows the new structure of the project with the new files.

Figure 14.52    Generated Java Classes for the Server Proxy
Build the Logic and Orchestration
In the previous sections, both the server and client proxies were created and the source code skeleton generated. Now, you need to add some logic to the server proxy. Looking at the DC that contains the server proxy (conversionserver_ejb), you see that it contains a main class called SIISAmountConversionImplBean that represents the main entry point and is supposed to hold the logic.
Note that the name of the class to which the logic implementation needs to be added always ends with the suffix "ImplBean". Listing 14.8 shows you what this generated class looks like.
package com.readersparadise.scm.procurement.erp;import javax.ejb.Stateless;import javax.jws.WebService;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.SessionHandlingDT;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.TransportGuaranteeDT;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.TransportGuaranteeEnumsLevel;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.AuthenticationDT;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.AuthenticationEnumsAuthenticationLevel;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.RelMessagingNW05DTOperation;@AuthenticationDT(authenticationLevel = AuthenticationEnumsAuthenticationLevel.BASIC)@TransportGuaranteeDT(level = TransportGuaranteeEnumsLevel.NONE)@SessionHandlingDT(enableSession = false)@WebService(portName = "SIIS_AmountConversion_Port", serviceName = "SIIS_AmountConversion_Service", endpointInterface = "com.readersparadise.scm.procurement.erp.SIISAmountConversion", targetNamespace = "urn:readersparadise.com:scm:procurement:erp", wsdlLocation = "META-INF/wsdl/com/readersparadise/scm/procurement/erp/SIIS_AmountConversion/SIIS_AmountConversion.wsdl")@Statelesspublic class SIISAmountConversionImplBean {    @RelMessagingNW05DTOperation(enableWSRM = false)    public com.readersparadise.scm.procurement.erp.DT_AmountConversionResponse siisAmountConversion(com.readersparadise.scm.procurement.erp.DT_AmountConversionRequest MT_AmountConversionRequest)throws com.readersparadise.scm.procurement.erp.FTMTechnicalFault {     return null;    }}
Listing 14.8    Generated Source Code of the Standard Implementation Class
Note that the class in contains a method called siisAmountConversion. This method name matches the name of the operation in the inbound service interface from which it was generated (see Figure 14.53).

Figure 14.53    Inbound Service Interface Used for the Java Server Proxy Generation
Populate SIISAmountConversionImplBean with the required logic. A possible implementation is provided in Listing 14.9.

Note
This is a simplistic implementation. In a real-life implementation, you'll need to add more exception handling.

package com.readersparadise.scm.procurement.erp;import javax.ejb.EJB;import javax.ejb.Stateless;import javax.jws.WebService;import net.webservicex.ConversionRate;import net.webservicex.ConversionRateResponse;import net.webservicex.Currency;import com.readersparadise.scm.procurement.erp.wrapper.CurrencyCoversionClientLocal;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.SessionHandlingDT;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.TransportGuaranteeDT;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.TransportGuaranteeEnumsLevel;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.AuthenticationDT;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.AuthenticationEnumsAuthenticationLevel;import com.sap.engine.services.webservices.espbase.configuration.ann.dt.RelMessagingNW05DTOperation;@AuthenticationDT(authenticationLevel = AuthenticationEnumsAuthenticationLevel.BASIC)@TransportGuaranteeDT(level = TransportGuaranteeEnumsLevel.NONE)@SessionHandlingDT(enableSession = false)@WebService(portName = "SIIS_AmountConversion_Port", serviceName = "SIIS_AmountConversion_Service", endpointInterface = "com.readersparadise.scm.procurement.erp.SIISAmountConversion", targetNamespace = "urn:readersparadise.com:scm:procurement:erp", wsdlLocation = "META-INF/wsdl/com/readersparadise/scm/procurement/erp/SIIS_AmountConversion/SIIS_AmountConversion.wsdl")@Statelesspublic class SIISAmountConversionImplBean {    @EJB CurrencyCoversionClientLocal currencyClient;    @RelMessagingNW05DTOperation(enableWSRM = false)    public  com.readersparadise.scm.procurement.erp.DT_AmountConversionResponse siisAmountConversion(com.readersparadise.scm.procurement.erp.DT_AmountConversionRequest request)throws com.readersparadise.scm.procurement.erp.FTMTechnicalFault {        //Retrieve input parameters        double amount = request.getAmount();        String sourceCurrency = request.getSourceCurrency();        String targetCurrency = request.getTargetCurrency();        //Call the external service        ConversionRate conversionRate = new ConversionRate();        if(sourceCurrency!=null)            conversionRate.setFromCurrency(Currency.valueOf(sourceCurrency));        if(targetCurrency!=null)            conversionRate.setToCurrency(Currency.valueOf(targetCurrency));                ConversionRateResponse conversionRateResp = currencyClient.siosReadersParadisePortal(conversionRate);        //Create an empty response        DT_AmountConversionResponse response = new DT_AmountConversionResponse();        if(conversionRateResp!=null)        {            response.setConvertedAmount(conversionRateResp.getConversionRateResult());        }                return response;    }}
Listing 14.9    Simple Implementation Example for the Server Proxy
Now that you've completed the proxy implementation, it's time to create the EAR DC.
Create an Enterprise Application Archive Development Component
It's now time to create an EAR DC to hold the Java server proxy application. This is the DC that will need to be deployed to the SAP PO server.


                        From SAP NetWeaver Developer Studio, right-click on the MyComponents SC, and select the New option. From the menu that opens, select the Development Component option.
                    

                        On the next screen, select Enterprise Application under the Java EE node. Click on Next.
                    

                        On the next screen, fill in the vendor name and the name of the DC (see Figure 14.54). Click on the Next button.
                        
Figure 14.54    Details of the EAR DC


                        Leave all the default fields untouched, and click on Next.
                    

                        On the next screen, select the dependency (or referenced projects) for the EAR DC. For this scenario, you only need to select conversionrateclient_ejb and conversionrateserver_ejb.
                    

                        Click on the Finish button.
                    

Build and Deploy
After completing the implementation of the wrapper class, it's time to compile and deploy the EAR DC to the server. Follow these steps:


                        Right-click on the EAR DC, and select Development Component and then the Build option from the menu (see Figure 14.55).
                    

                        You'll see a pop-up prompting you to select the DCs to be built; be sure to select both the EJB and the EAR DCs.
                    

                        Click on OK. It might take a few seconds to compile the DCs.
                    

                        Go back to the EAR DC. Right-click on it, and select Development Component and then the Deploy option from the menu.
                    

Now that all the deployed proxies are deployed to the server, it's time to perform some SOA configuration.

Figure 14.55    Build and Deploy the EAR Development Component
Configure the Deployed Service from SAP NetWeaver Administrator
For the deployed proxy to work properly, you need to perform some configurations on the client and server proxies.
Client Proxy Configuration
Start with the client proxy, which needs to point to the runtime endpoint of the iFlow. Follow these steps to apply the required settings:


                            Go to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                            Once logged in, navigate to the SOA tab and then the Application and Scenario Communication subtab.
                        

                            On the new page, click on the Single Service Administration link. The new page allows you to search for deployed web services.
                        

                            Select Consumer Proxies tab, and search for the client proxy (see Figure 14.56). You need to search for the outbound service interface that was used to generate the client proxy (in this case, SIOS_ReadersParadisePortal).
                            
Figure 14.56    Consumer Proxies Configuration in the Single Service Administration Application


                            If you prefer to use plain SOAP, then click on the New button (above the Logical Port section; see Figure 14.56). This will launch a new wizard that will allow you to select SOAP Transport Binding (see Figure 14.57).
                            
Figure 14.57    New Client Proxy Configuration Using SOAP Transport Binding


                            Follow the wizard. When asked for an endpoint for the WSDL, provide the WSDL obtained from the iFlow. You need to provide a WSDL that contains an endpoint. You might also need to add login credentials.
                        

                            Follow the rest of the wizard until it's completed.
                        

The configuration of the client proxy is now complete!
Server Proxy Configuration
Now, it's time to configure the server proxy. Follow these steps:


                            In SAP NetWeaver Administrator, navigate to the SOA tab and then the Application and Scenario Communication subtab.
                        

                            On the new page, click on the Single Service Administration link. The new page allows you to search for deployed web services. Make sure to remain in the Service Definitions tab.
                        

                            Enter the name of the inbound service interface that was used to generate the Java server proxy earlier. In this case, search for "SIIS_AmountConversion", as shown in Figure 14.58.
                            
Figure 14.58    Select the Inbound Service Interface from the Single Service Administration in SAP NetWeaver Administrator


                            After filling in the search term in the Find text field, click on the Go button to trigger the search. You then need to select the returned entry (see Figure 14.58).
                        

                            Go to the Configuration tab, and click on the New button to start a new configuration.
                        

                            A wizard will be launched in which the first two steps are General and Security. Proceed with the wizard until the last step.
                        

                            Click on the Finish button to complete the web service configuration.
                        

Congratulations! You're now ready to run and test your proxy. A WSDL file of the server proxy can be downloaded from the WSDLs tab (see Figure 14.59).

Figure 14.59    Downloading the WSDL or Testing the Service









14.6    Summary
In this chapter, we explored the different notions of Java proxies. Now, you're familiar with concepts such as client proxies and server proxies, as well as when they can be used. A step-by-step guide was provided to help you build your first client and server proxies.
The chapter extended the notions of proxies by explaining how a combination of server and client proxies can be used for building a composite service.
The next chapter will focus on the subject of administering and monitoring message processing in SAP BPM.








15    Administration and Monitoring Message Processing in SAP BPMTrust, but verify.                                                                                                  —Ronald ReaganAfter you've successfully developed, deployed, and configured processes in SAP Business Process Management (SAP BPM), the business will be ready to use and trigger them. After the processes are running, you'll need to use SAP BPM's monitoring capacity to continuously maintain and administer SAP BPM to fix erroneous situations that arise and to prevent such situations in the future.Part of SAP Process Orchestration (SAP PO) maintenance also includes regularly running some housekeeping jobs. Monitoring and administering your SAP BPM processes will form the main focus of this chapter. In this chapter, we'll look at what's required to properly manage, track, and detect issues in running processes and tasks in your SAP PO server. Monitoring these processes is part of the ongoing job of maintaining and improving your organization's IT environment.
15.1    Monitoring
SAP PO provides a number of monitoring tools via SAP NetWeaver Administrator. Each of those tools, which will be explored in the next sections, can be used for different purposes. Be aware that to access these tools, you need to have the right user authorizations and roles. Most of these tools require the common roles listed in Table 15.1. If a particular tool requires different or additional roles and authorizations, it will be mentioned in the relevant sections further in the chapter.




                        Role
                    

                        Description
                    





 NWA_SUPERADMIN


                        Gives rights to perform all necessary administrative actions on processes, including suspending, completing, and canceling them
                    



SAP_BPM_SuperAdmin


                        Has same access rights as the NWA_SUPERADMIN role but can also recover process instances that failed
                    



SAP_BPM_SuperDisplay


                        Gives access to view detailed information of processes, including their context data and history
                    



NWA_READONLY


                        Gives access to details of all running process instances
                    



SAP_BPM_Navigation


                        Gives rights to perform all necessary administrative actions on a subset of process instances (for which the user is an owner), including suspending, completing, and canceling
                    



Table 15.1    Necessary Roles to Access SAP BPM Monitoring Tools
15.1.1    SAP Business Process Management System Overview
The SAP BPM system overview tool forms part of the availability and performance monitoring (see Figure 15.1). The tool gives a high-level overview of the following information:


                    Process server availability
                

                    Number of process instances running on each server node
                

                    Configuration of the instance memory threshold


                    Whether the process engine is properly running
                

                    Number of process instances in each different status (Error, Failed, Suspended, Completed, Canceled, and In Progress)
                

                    Number of tasks in each different status (Error, Suspended, Completed, Canceled, Ready, and In Progress)
                

The roles listed in Table 15.1 apply for this tool. To access the SAP BPM system overview tool, follow these steps:


                    Log in to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                    Navigate to the Availability and Performance Management tab. Then, select BPM System Overview to access the tool.
                

You'll arrive at the page shown in Figure 15.1.

Figure 15.1    SAP BPM System Overview Monitoring Tool
15.1.2    Process Repository
The Process Repository is an application within SAP NetWeaver Administrator that enables administrators to view all of the deployed SAP BPM development components (DCs), versions of the components, and related process and task definitions in order to start process instances and download resources.
The roles listed earlier in Table 15.1 apply for this tool. To access the Process Repository, follow these steps:


                    Log in to SAP NetWeaver Administrator.
                

                    Navigate to the Configuration tab.
                

                    Select the Processes and Tasks subtab.
                

                    Click on the Process Repository link to go to the screen shown in Figure 15.2.
                

For more details about how to use each functionality available in the Process Repository, refer to Chapter 11, Section 11.2.1.

Figure 15.2    Process Repository Overview with List of Components
15.1.3    Process Management
Process Management is the main tool to be used for managing and monitoring all SAP BPM process instances running on the SAP PO server. This is a one-stop shop that enables administrators to perform the following tasks:


                    Access details of a process instance.
                

                    View the process instance's flow.
                

                    View the process definition flow.
                

                    View the history of process instance activities.
                

                    View details of the process instance's context.
                

                    Navigate to tasks that are related to the current process.
                

                    Perform administrative actions on a process.
                

The roles listed earlier in Table 15.1 apply for this tool. To access the Process Management tool, follow these steps:


                    Log in to SAP NetWeaver Administrator.


                    Navigate to the Operations tab.
                

                    Select the Processes and Tasks option.
                

                    Choose the Manage Processes link. A new page will load with a list of processes with an error status (see Figure 15.3).
                


Figure 15.3    The Main Page for Managing Processes
Let's look at some of the process management tool's features in more detail.
Access Process Instance Details
From the main Manage Processes page (refer to Figure 15.3), you can filter processes based on their status and many other different filtering criteria. On the top-left side of the page, from the Show dropdown (see Figure 15.4 1), you can choose between the following options:


All Running Processes Includes the list of processes currently running that have an In Progress status. These processes aren't yet completed.
                    

Error and Failed Processes This list of processes encountered problems that require corrective actions to be taken by the administrator. This category of processes needs to be given special attention and continuous monitoring.
                    

Furthermore, the tool provides the ability to filter processes based on other attributes for more advanced process filtering functionality. To access this filtering, click on the Advanced link at the top right of the page 1. You'll see another page, which provides many filtering options 2. For example, from this page, you can select all process instances that were started within a particular time frame.

Figure 15.4    Advanced Filtering: Filtering Processes Based on Attributes
You can see more details of any given process by performing the following steps:


                        Select the desired process instance from the list.
                    

                        Select the Details tab at the bottom of the screen to view all relevant details. Figure 15.5 shows the following process attributes:
                        

Process Instance ID A GUID that uniquely identifies a process instance.
                                
Figure 15.5    Details of a Process Instance


Subject Describes what the process is about. The subject can be specified during design time while developing the process.
                            

Description Describes what the process does or is used for.
                            

Archived A Boolean value representing whether or not the process instance has been archived.
                            



View the Process Definition Flow
You can view details about the process definition by going to the Process Definition tab. From here, you can view information such as title, definition ID, version ID, and the description of your process (Figure 15.6 1).

Figure 15.6    Getting the Definition of a Process and Displaying Its Definition Flow
You can also see the Business Process Model and Notation (BPMN) representation of the process by clicking on the Show Process Definition Flow link 2.
View the History of the Process Instance Activities
The History tab lists the details of all the activities of the SAP BPM instance. This tab can be thought of as an activity log. From the Show dropdown, you can view a Basic, Medium, or Advanced level of logs. From the history logs, you can see whether a particular event failed and view the description of the error that occurred (see Figure 15.7).

Figure 15.7    History of Process Instance Activities
View Details of the Process Instance's Context Data
In the Context Data tab, an administrator can inspect and analyze the values of the data objects of a particular process instance. Being able to inspect the data object values provides useful insight and information while troubleshooting your process.
You can see which values started the process and how the data changed in the different steps. Figure 15.8 shows an example.

Figure 15.8    Inspection of the Context Data of a Process Instance
Perform Administrative Actions on a Process
After selecting a particular process instance, you can perform some administrative tasks on it. These actions include suspending, resuming, and canceling process instances, which you select from the Actions button (see Figure 15.9).

Figure 15.9    Actions to be Performed on a Process Instance
15.1.4    Task Management
Task Management is the main application to be used for managing and monitoring all SAP BPM tasks running on the SAP PO server. From this application, an administrator can perform the following actions:


                    View tasks.
                

                    View deadlines.
                

                    View the history of a task.
                

                    View task owners.
                

                    Nominate users or delegate tasks to other users.
                

The roles listed earlier in Table 15.1 apply for this tool. To access Task Management, follow these steps:


                    Log in to SAP NetWeaver Administrator.


                    Navigate to the Operations tab.
                

                    Select the Processes and Tasks option.
                

                    Click on the Manage Tasks link.
                

From this screen, you can use an advanced feature to filter the different tasks based on various attributes (see Figure 15.10). These attributes include the following:


                    Statuses (Assigned, In Error, Escalated, or Suspended)
                

                    Archived or active tasks
                

                    Created dates of tasks
                

                    Task's owner
                

                    Lifecycle status (Inactive, Ready, In Progress, Completed, or Canceled)
                

                    Different types of priorities
                


Figure 15.10    Managing All SAP BPM Tasks from Task Management
To access the Advanced Task Management screen, click on the Advanced link on the top-right side of the screen.
15.1.5    SAP BPM Inbox
SAP BPM Inbox is an HTML5 (SAPUI5)-based application that can be thought of as SAP BPM's mailbox. It was introduced in SAP NetWeaver 7.31 SP 04. All tasks that are assigned to a user will be accumulated in that user's SAP BPM Inbox, and it can therefore be considered a central access point for SAP BPM-related tasks. It's a good alternative to the universal worklist (UWL), which was the main task repository option in older SAP BPM versions. SAP BPM Inbox has a big advantage compared to the UWL because it's designed to support multiple devices, including smartphones and tablets. SAP BPM Inbox is a modern application that performs much faster than the UWL.
From SAP BPM Inbox, you can perform the following activities on tasks:


Filter Filter tasks based on different statuses (Open, Completed, Overdue, or Escalated). You can also filter tasks that have been assigned to you.
                

Open View the details of tasks to perform different actions on them, such as to complete or cancel tasks.
                

Claim If you're one of the potential owners of a task, then you can assign a task to yourself to become the actual owner.
                

Release When a task has been reserved for you, you can use this option to release it.
                

Forward Forward or delegate a task to a colleague or another user.
                

By default, SAP BPM Inbox isn't configured, so you need to perform the following activities to customize it to your environment and needs:


                    Log in to SAP NetWeaver Administrator.
                

                    Navigate to the Configuration tab.
                

                    Select the Infrastructure subtab.
                

                    From there, click on the Java System Properties link.
                

                    Select the Applications tab. A table lists all applications deployed on the SAP PO server.
                

                    Filter for the application called tc~bpem~base~ear in the Name column.
                

                    Select this application to see its properties displayed at the bottom of the screen.
                

                    Filter for the http.baseurl property under the Name column.
                

                    Click on the Modify button, and change the default value (http://hostname: 50000) by replacing the hostname and port number to suit your environment (see Figure 15.11).
                    
Figure 15.11    Configuring the SAP BPM Inbox in SAP PO


                    Don't forget to use the Set and Save buttons to store your new settings.
                

                    After completing the preceding steps, you're ready to access the SAP BPM Inbox via http://<hostname>:<port>/bpminbox. Replace <hostname> and <port> accordingly. You'll see a screen similar to the one shown in Figure 15.12.
                


Figure 15.12    SAP BPM Inbox Application
To access the SAP BPM Inbox, the following roles must be added to the UME user's profile:


UnifiedInboxUserRole Allows the user to view the list of tasks and their details in the SAP BPM Inbox.
                

com.sap.bpem.Enduser Enables users to manage and work on the task.
                

Note that these two roles are the only ones required for the SAP BPM Inbox. All other roles listed in Table 15.1 aren't required.
Some organizations opt to use an alternative tool called the Unified Inbox. The Unified Inbox tool has a broader scope than just SAP BPM tasks. It can be used as a centralized task center for different SAP and non-SAP workflow and BPM engines. The Unified Inbox provides an API to connect to non-SAP system and a standard connector for SAP BPM and SAP Business Workflow.
The Unified Inbox topic is beyond the scope of this book, but it's useful to be aware of it.
15.1.6    Business Logs
The Business Logs tool is used to analyze business events of SAP BPM processes. It triggers events every time there are changes in the lifecycle of business processes. From this application, you can view all event logs grouped under categories, events, containers, times, and dates (see Figure 15.13).
The roles listed earlier in Table 15.1 apply for this tool. To access the Business Logs tool, follow these steps:


                    Log in to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                    Navigate to the Troubleshooting tab.
                

                    Choose the Processes and Tasks subtab.
                

                    Select the Business Logs option. You'll see the page shown in Figure 15.13. You can view more details on each of the listed events by selecting its entry in the table.
                    
Figure 15.13    SAP BPM Process Business Lifecycle Logs


15.1.7    SAP BPM Action Monitor
SAP BPM Action Monitor enables the monitoring of queues throughout the cluster. All SAP BPM actions relating to events such as intermediary messages or human tasks uses queues and can be monitored from the SAP BPM Action Monitor. You can see which actions are queued, failed, or disabled (see Figure 15.14).
The roles listed earlier in Table 15.1 apply for this tool. To access SAP BPM Action Monitor, follow these steps:


                    Log in to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                    Navigate to the Troubleshooting tab.
                

                    Select the Processes and Tasks subtab.
                

                    On the new page, click on the BPM Actions link.
                    
Figure 15.14    SAP BPM Action Monitor


On the new page (see Figure 15.14), the following information is displayed:


BPM Queue Summary This section presents an overview with the total number of actions that are currently queued, failed, or disabled. You can click on any of these total numbers to have them filtered in the bottom section of the screen (BPM Queue Content).
                

BPM Queue Settings This section contains details of server settings about parameters such as polling interval, number of actions polled per process, and maximum number of attempts. Be aware that the settings of these attributes can dramatically impact the performance on your processes. Refer to Chapter 11, Section 11.9 to learn more about how to tune SAP BPM-related performance parameters.
                

BPM Queue Content From this section, you can filter the actions based on their statuses. Actions with a Disabled status can be reset back to a Queued status via the Reset button.
                

15.1.8    Process Troubleshooting
The Process Troubleshooting application is used to track and trace the components. Various aspects of the SAP PO server can be monitored, including the following:


                    Availability of its components
                

                    Status of the SAP BPM cluster nodes
                

                    Start and stop of different applications on the server
                

The roles listed earlier in Table 15.1 apply for this tool. To access the Process Troubleshooting application, follow these steps:


                    Log in to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                    Navigate to the Troubleshooting tab, and then select the Processes and Tasks subtab.
                

                    Click on the Process Troubleshooting link.
                

15.1.9    Rules Business Logs
Even though this tool is related to SAP Business Rules Management (SAP BRM), it's relevant to mention it in the context of monitoring business processes. As you're aware from Chapter 11 and Chapter 13, you can embed an SAP BRM rule in an SAP BPM DC or project. In such a case, you might need to deal with the Rules Business Logs while troubleshooting your SAP BPM process.
The Rules Business Logs application (see Figure 15.15) enables the administrator to view the business logs for the execution steps of a ruleset. As an SAP BRM rule runs in the SAP PO server, it creates logs containing details and information about activities or events performed by the rule. These logs are called business logs and are internally created with the help of the Galaxy Business Logging Framework.
The roles listed in Table 15.1 apply for this tool. To view Rules Business Logs, follow these steps:


                    Log in to SAP NetWeaver Administrator via http://<hostname>:<port>/nwa.


                    Navigate to the Troubleshooting tab, and then select the Processes and Tasks subtab.
                

                    Click on the Process Troubleshooting link.
                    
Figure 15.15    Rules Business Logs Application


You'll see the page shown in Figure 15.15. From here, you can specify a time period and retrieve all the relevant business logs. After selecting a particular entry, you can see more details about the log entry at the bottom of the screen.
15.1.10    SAP BPM Analytics Dashboard
The SAP BPM Analytics Dashboard enables its users to analyze and run reports of SAP BPM processes and tasks. You can filter processes and tasks based on the following periods: today, yesterday, last 7 days, and last 30 days.
The dashboard graphically presents statistics of the processes and tasks based on different status categories. For processes, the relevant statuses include the following:


In Progress


Completed


In Error


For the tasks, the relevant statuses include these:


Open


In Progress


Completed


Failed


The SAP BPM Analytics Dashboard can be accessed via the link http://<hostname>:<port>/bpmanalytics. An impression of how the main page looks like can be seen in Figure 15.16.

Figure 15.16    Monitoring Processes and Tasks with the SAP BPM Analytics Dashboard
To access this dashboard, the roles listed in Table 15.1 need to be added to the user's profile, as well as the following roles:


DISPLAY_ALL


Everyone


Note that the dashboard will only be populated with data of the processes and tasks that the user is authorized to see. These processes and tasks include the ones for which the user is an administrator.
From the SAP BPM Analytics Dashboard, a link is provided to directly jump into the Process Management tool (Section 15.1.3) and Task Management tool (Section 15.1.4). Details of processes (under each status) can be viewed by clicking on the View Details link below the Top Processes chart. Likewise, task details (under each status) can be viewed by clicking on the View Details link below the Top Tasks chart.









15.2    Administration
SAP NetWeaver provides a wide range of applications to facilitate the administration of the SAP PO server. This section briefly touches on two aspects of SAP NetWeaver administration that are relevant to maintaining and troubleshooting SAP BPM processes. Chapter 18 will discuss other aspects relevant for administration and housekeeping in more detail.
15.2.1    Process Data Archiving
The XML Data Archiving Service (XML DAS) is used to archive process instances, tasks, and all their data (e.g., data objects, attachments, etc.). The archived data is stored in XML format. Using the XML DAS, it's possible to configure and schedule archiving jobs (to write and delete) from the Java Archiving Cockpit.
The roles listed in Table 15.1 apply for this tool. Furthermore, to perform the relevant archiving tasks, you need to add the following additional roles to your user's profile:


XMLDASSecurityRole


SAP_ARCH_SUPERADMIN


To access and configure the Java Archiving Cockpit, follow these steps:


                    Log in to SAP NetWeaver Administrator.
                

                    Navigate to the Operations tab.
                

                    Select the Processes and Tasks subtab.
                

                    Click on the Manage Processes link.
                

                    Select the SAP BPM instances that you would like to archive, and choose the Archive button on the top menu to navigate to the Java Archiving application.
                

                    Note that when Java Archiving opens, it's already prefilled with the process instance ID. After filling in all the other relevant data, click on the Start Write Session button (see Figure 15.17).
                


Note
Be aware that process instances without a Completed or Canceled status can't be archived, so the Archiving button will be disabled if the selected process instance has an In Progress or Suspended status.


Figure 15.17    Java Archiving Cockpit Prefilled with the SAP BPM Process Instance ID

Note
SAP recommends archiving entries of the business log that are older than two months. The archiving session needs to be performed on a daily basis.

15.2.2    Log Viewer
The Log Viewer (Figure 15.18) application enables administrators or developers to view details of logs and traces that have been written by different applications running on the SAP PO server. These logs can be handy in troubleshooting issues and errors that have occurred in the server. The Log Viewer can be accessed via http://<hostname>:<port>/nwa/logs.

Figure 15.18    Log Viewer Application to Retrieve Traces and Logs
The roles listed in Table 15.1 apply for this tool. The application can also be accessed by performing the following steps:


                    Go to SAP NetWeaver Administrator on your server.
                

                    Select the Troubleshooting tab.
                

                    Select the Logs and Traces subtab.
                

                    Click on the Log Viewer link.
                

You'll see a screen similar to the one presented in Figure 15.18.
From the Log Viewer main page, you can perform the following actions:


                    Filter and search logs by message, category, location, and application.
                

                    Select any log entry and view its details.
                

                    Access other related logs (log related by request or session) from any given log entry.
                

                    Download the content of the logs to your local file system.
                

You can also access developer-specific traces, also called developer traces. To access developer traces, follow these steps:


                    Go to SAP NetWeaver Administrator on your server.
                

                    Select the Troubleshooting tab.
                

                    Select the Logs and Traces subtab.
                

                    Click on the Log Viewer link.
                

                    From the Log Viewer main page, select the View link on the top-left side of the screen.
                

                    From the resulting dropdown, select Open View and then Developer Traces.
                










15.3    Summary
No one wants to build a castle that only lasts one day. After spending a lot of time building a process to help the business reach its goal, you'll want to ensure that the business continues to enjoy the process benefits for a long time. A castle requires regular checks and maintenance work to be kept in top condition. The same applies for your SAP PO server, which requires maintenance in the form of monitoring the running processes and servicing the server.
This chapter explored the different tools and applications that can be used in SAP PO for monitoring purposes. Every one of these tools was discussed and its purpose and use explained. After reading this chapter, you should be able to monitor all running processes in your SAP PO server.
Activities to be performed by an administrator, such as data archiving and investigating logs and developer traces, have also been touched on.
The next chapter will explore ways of migrating your existing processes, built using cross-component Business Process Management (ccBPM), from SAP PI to SAP PO.








16    Migrating ccBPM from SAP PI to SAP POChange is the law of life. And those who look only to the past or present are certain to miss the future.                                                                                                 —John F. KennedyIf you're reading this chapter, the chances are high that you're coming from a dual stack (ABAP/Java) SAP Process Integration (SAP PI) installation and that you've heard about the new features offered by SAP Business Process Management (SAP BPM) as part of SAP Process Orchestration (SAP PO). Most likely, you've implemented service orchestration workflows using cross-component Business Process Management (ccBPM) integration processes, and you're planning or at least considering moving those existing ccBPM integration processes to the new Java-only stack of SAP PO.If that is the case, then you're at the right place in this book to start preparing for that challenging task. We believe this chapter is definitely one of the highlights of this book because it outlines a frequent challenge encountered by many SAP NetWeaver integration developers and architects when adopting SAP PO as their new application and business process integration platform.This chapter will take you through the journey of analyzing, redesigning, and re-creating those existing ccBPM flows using the new generation of SAP BPM tools as delivered by SAP PO.
16.1    Motivation for Migration
SAP BPM is the process orchestration tool used to model and execute integrated processes in SAP PO. ccBPM as part of the ABAP stack of SAP PI is no longer supported under the Java-only stack of SAP PO, which means that, at some point, all existing ccBPM integration processes (only supported in SAP PI dual-stack installations) will need to be migrated to SAP BPM. Before we get into the details, let's first briefly discuss the motivation behind a new method of business process orchestration in SAP NetWeaver and recap some of the main differences between ccBPM and SAP BPM.
In earlier releases of SAP PI (before SAP PO became officially available), many SAP customers (and in particular SAP PI developers) faced many technical limitations and functional difficulties imposed by the lack of a flexible and open business process orchestration platform, not to mention the total absence of basic business process management features, such as a user-friendly design environment to model and analyze business processes and a business rules engine (BRE) in SAP PI. Back then, if you had to support stateful message processing (i.e., persisting the status of an integration process on the integration server) or do something more exciting than just passing a message through SAP PI from point A to point B, then you did not have much choice but to use the heavy and slow ccBPM.
Although you could design and execute most common system-to-system automated processes with the features delivered by ccBPM, those features weren't sufficient to support more complex and sophisticated business processes that required a high degree of user interaction and reusability of user or organizational management information on the SAP backend systems. Perhaps not a direct technical limitation of the tool, but one important aspect that prevented transparency and smooth communication between IT and business stakeholders about the process logic in their integration processes, was the lack of a standard way of modeling those integration processes according to a common and almost natural language that could be understood by business and IT process experts.
As you might recall from Chapter 9, ccBPM integration processes are based on the SAP Business Workflow engine, which is also internally used by many SAP modules. Considering that SAP PO is a Java-only installation, you have few options beyond moving your current ccBPM integration processes to SAP BPM. In addition to having different process engines, both platforms also use different ways of modeling their business process diagrams (BPDs). In the case of ccBPM, Business Process Execution Language for Web Services (BPEL4WS) is used as a graphical modeling language to describe interactions between systems by means of messages via web services. SAP BPM, on the other hand, uses Business Process Model and Notation (BPMN 2.0) as the common modeling language for visualizing and executing BPDs.
Some big advantages of BPMN 2.0 when compared with BPEL4WS are definitely its flat learning curve and easy accessibility and applicability by IT and business process stakeholders. These advantages automatically deliver other positive side effects, such as common understanding of business processes by IT and non-IT and the fact that documented business processes diagrams aren't static process pictures any longer but now become alive, representing the real business process as executed during runtime by the SAP BPM engine.
Here is the definition of each:


BPEL4WS Directly derived from its parent standard, the Business Process Execution Language (BPEL), which was originally introduced around 2004 after IBM, SAP, Microsoft, and other big software houses joined forces to conceive a new standard for modeling executable processes using web services for interchanging data within and across the enterprise.
            

BPMN 2.0 Generic standard that defines a set of different flow elements to help process owners, business analysts, and IT professionals understand, analyze, design, and execute business processes in a common way and according to their specific (functional or technical) requirements at different levels of detail. Read more about how BPMN 2.0 is supported in SAP PO in Chapter 9.
            

BPEL4WS's main goal is to represent an integrated process from a technical perspective, using web services as the main method of information interchange between its actors. That's in contrast to BPMN 2.0, in which the modeling of a BPD is from a business perspective—that is, top down rather than bottom up, as in BPEL4WS.
Perhaps the most fundamental difference between BPEL4WS and BPMN 2.0 is that BPEL4WS follows a diagram design model based on a block structured graph type, whereas BPMN 2.0 process diagrams are more flexible and don't follow a block structure flow type. However, there are good examples of SAP BPM-driven projects in which both standards coexist and are applied in the areas in which they excel. For instance, business analysts will do the modeling part of the processes using BPMN 2.0 notation, and developers will take care of manually translating those BPMN 2.0 models into their BPEL4WS representations. We don't advise such a method as your first choice, but it's a feasible alternative and way of working that can be applied if needed in specific situations.
Having said that, it's clear that from a technological perspective, an automatic migration tool that makes it possible to move from ccBPM into the new generation of SAP BPM integration flows simply doesn't make sense.









16.2    Migration Approach
As discussed in the introduction of this chapter, we've seen that it isn't possible nor feasible to fully automate existing ccBPM integration processes 1:1 into their equivalent BPMN 2.0 representations in SAP PO BPDs, which means that we have to apply a different approach to execute the migration of integration processes.

Note
We assume that you're planning to execute the migration procedure with both systems available—that is, the old SAP PI (dual-stack) and the new SAP PO (Java single-stack) installations. This is a prerequisite for the steps we'll explain in the next sections. We call this a side-by-side or parallel migration approach.

Before we continue with the migration steps, let's first take a quick look at Table 16.1, which provides an overview of the main differences between ccBPM and SAP BPM.




                        Comparison Area
                    

                        ccBPM
                    

                        SAP BPM
                    





                        Installation and availability
                    

                        Runs only on ABAP stack; SAP PI dual-stack (ABAP/Java) was available since the early versions of SAP Exchange Infrastructure (SAP XI) 3.0.
                    

                        Runs on Java-only single stack; available from SAP PO 7.3. EHP 1 and SAP Composition Environment 7.1 EHP 1 onwards.
                    



                        Support of open standards
                    

                        Very limited, mainly proprietary SAP standards.
                    

                        Widely supported, XML standards, Java, and SAP BPM open standards.
                    



                        Support of system- and human-centric processes
                    

                        Original ccBPM focus was system-to-system, but basic human-interaction functionality was later added by SAP.
                    

                        Both human- and system- centric processes are supported, and mixes of both types of process orchestration can be accomplished.
                    



                        Versioning and transport mechanism across different environments
                    

                        Same methods as for other SAP PI classic objects—that is, via export/import options and enhanced Change and Transport System (CTS+) transport integration.
                    

                        SAP NetWeaver development infrastructure required for proper versioning and transport support via CTS+.
                    



                        Modeling environment
                    

                        Modeling of integration processes is done from Enterprise Services Builder (ES Builder) from the Enterprise Services Repository (ES Repository) using a proprietary palette of modeling objects.
                    

                        Design of BPDs is done in SAP NetWeaver Development Studio based on Eclipse and applying BPMN 2.0 standard modeling objects.
                    



                        Contains SAP Business Rules Management (SAP BRM) functionality
                    

                        No SAP BRM functionality included; business rules need to be accessed as web services via SAP PI or using other techniques, such as external calls (Remote Function Calls [RFC]/Java Database Connectivity [JDBC]) via mapping steps in the process flow.
                    

                        When SAP PO is installed, the SAP BRM component is also enabled as a companion of SAP BPM. SAP BRM includes a complete suite of tools to design, develop, execute, and monitor business rules. Business rules can be embedded as part of the process or accessed as independent web services.
                    



                        Integration between SAP PI and process engines
                    

                        Integration between SAP PI and its business process engine (BPE) is done using abstract interfaces. Underlying communication protocol is SAP XI Simple Object Access Protocol (SOAP) protocol over HTTP/S.
                    

                        SAP PO uses SAP XI 3.0 protocol over HTTP/S to exchange messages between the Advanced Adapter Engine Extended (AEX) and the SAP BPM component. Non-SAP XI protocol can also be used, but you don't get guaranteed delivery of Quality of Service (QoS) for that type of interface.
                    



                        Required skills and complexity of technology
                    

                        Besides the SAP PI classic skills, a ccBPM developer also must have specific skills for modeling and developing integration processes, defining correlations, configuring variable context, performing error handling in ccBPM, and so on. Previous experience with SAP Business Workflow can be extremely beneficial when debugging ccBPM flows on the ABAP stack.
                    

                        SAP BPM runs on the Java stack of SAP PO, which automatically means that as developer, you need to have a good to strong level of Java knowledge. In addition, SAP BPM skills such as understanding, analyzing, and modeling BPMN and non-BPMN flow diagrams are required.
                    



                        Performance


                        The performance of ccBPM integration processes has always been a concern for most customers implementing ccBPM. It's certainly not one of the positive features of this technology.
                    

                        When compared to ccBPM, the performance gain for similar processes can improve 8 to 10 times faster when running under SAP BPM. Of course, it all depends on the size of messages, complexity of mappings, and so on, but, in general, a performance gain should be observed.
                    



Table 16.1    Comparing ccBPM to SAP BPM
You should have now a better overview of what to expect from SAP BPM when compared to its predecessor, ccBPM.
We'll now provide you with step-by-step instructions for how to analyze and translate existing ccBPM integration processes into their equivalent BPDs in SAP BPM. We'll explain where, with what, and how to perform the migration procedure by following an effective, verifiable, and low-risk strategy.
Figure 16.1 depicts four main steps for migrating ccBPM integration processes to SAP PO.

Figure 16.1    Process Steps Migration Procedure
16.2.1    Analyze the As-Is Integration Processes
The first step you must consider when planning the migration of existing ccBPM integration processes into SAP BPM is to have a clear overview of what needs to be migrated to SAP BPM, which means understanding how those integration processes look from the inside, what kind of (integration) business logic has been implemented inside the various process steps, and what types of service orchestration they support.
One of the important things you'll also have to decide is whether you want to migrate existing integration processes in phases or all in one go. For instance, you could prioritize them by business criticality, business area, or complexity, or perhaps you want to do it all at once in one big bang approach. Regardless of the strategy you choose, the preparation steps remain the same.
Let's now examine the different aspects to be analyzed during this first step and at the same time discuss how and where to perform the complete ccBPM analysis in your existing SAP PI (dual stack) environment.
As-Is Cross-Component Business Process Management
Go to the ES Repository in the source system (SAP PI), and open your existing ccBPM integration processes to analyze each of them internally. Make sure you answer the following questions when doing the analysis for each of the ccBPM processes:


                        What type of abstract service interface originally triggers the process—that is, synchronous or asynchronous?
                    

                        Is it a system-centric only or human-centric only business process or a mix of both?
                    

                        Does it support a long-running (e.g., it can take hours/days/weeks/months to finish) process, or does it support a near-real-time (finishes within seconds/minutes) process?
                    

                        How many receiver steps does this ccBPM process have—one or multiple?
                    

                        Does it support different message types?
                    

                        Does it perform intermediate calls to external web services before the process finishes?
                    

                        Are there any process variables maintained at the process or container level? If yes, are they of simple (string, Boolean, numeric, etc.) or complex (e.g., containing multiple messages) types?
                    

                        Does the process contain any decision logic—that is, switch steps, loops, or so on? If yes, then find out on what parameters the logic performed at runtime is based.
                    

                        How is exception or error handling currently done? Does the process automatically inform an administrator or user group about runtime issues using embedded process alerts, workflow tasks, or emails?
                    

                        Does the integration process handle big volumes of messages? Are there any binary files or attachments passed along?
                    

Ask your administrator for current performance logs, in which you can see whether the process is or is not performing well currently. After this analysis task, you'll have collected valuable information about the internal process logic of each ccBPM integration process and how it's currently implemented, and you'll have documented the results of the analysis and identified any specific type of critical or complex integration logic that might require additional attention when performing the migration to SAP BPM.
With the collected information, you can start making an estimate about possible process changes or improvements in the new SAP BPM implementation and the effort needed to develop those processes.
Big Bang or Phase-Based Migration
At this point, you may want to decide whether you want to go for multiple phases or a big bang migration strategy for all of your ccBPM integration processes. Both strategies are valid, depending your situation. For instance, there might be situations in which you have a limited number of integration processes and don't need to split them into different phases. Or, perhaps your current SAP PI installation will be upgraded to SAP PO; in that case, you don't have much choice but to migrate everything at once. However, if you have the flexibility, time, and budget, then our advice is to go for the phase-based migration approach. You can start by picking one or two existing ccBPM processes (e.g., a simple and a complex integration process) and work them out through the migration process. That will give you the opportunity to get used to the new SAP PO environment and all the other new things that you'll encounter in SAP PO. Furthermore, your developers will get the opportunity to learn the new way of working in SAP PO and will get the chance to come up with best practices and lessons learned after the first migration phase.
After you've completed the migration of your first integration processes to SAP PO, you should be able to decide which migration approach you'll follow for the remaining ccBPM scenarios—that is, a phase-based or big bang approach.
16.2.2    Translate and Redesign
In the first migration step (Section 16.2.1), we checked the existing migrated integration processes and analyzed their contents and specific configuration as set in SAP PI (e.g., how they were modeled using the BPEL4WS notation), and we checked the different process steps and what type of process logic has been applied to support their associated orchestration processes.
The second part of the procedure is a critical step in the migration that you need to perform when you're moving away from ccBPM and start carefully building the new SAP BPM domain. At this stage of the migration procedure, you'll put into practice some of the new required SAP BPM skills when developing orchestration processes in SAP BPM. We're talking about the exercise of translating the existing ccBPM integration processes into their corresponding BPMN 2.0 representations. In the next sections, we'll unveil how you should proceed.

Tip
You should prepare your System Landscape Directory (SLD) software components (SCs) (software component versions [SWCVs], development components [DCs], dependencies, etc.) and perform SAP NetWeaver development infrastructure configuration before executing this step. Otherwise, you'll have to export or import your local DCs manually from SAP NetWeaver Developer Studio into the real ones in the SLD or in SAP NetWeaver development infrastructure at a later stage.

Figure 16.2 shows a representation of what could be the final result after performing the translation of an existing ccBPM integration process into a BPMN 2.0 process diagram.

Figure 16.2    Translating ccBPM into BPMN 2.0
As you can see, we've provided a mapping (shown as arrows) between the old ccBPM objects and their equivalents in SAP BPM's BPMN 2.0 palette.
Table 16.2 gives a complete overview of the different ccBPM objects and their equivalent flow objects in the BPMN 2.0 environment. You can use this table when doing the redesign and translation of your integration ccBPM processes as a reference guide. Chapter 9 also provides more information and detailed explanation about the BPMN 2.0 standards and its flow objects as supported in SAP BPM.




                            ccBPM Step (BPEL4WS)
                        

                            SAP BPM (BPMN 2.0)
                        






                            Start
                        


                            Start event (with or without message as trigger)
                        




                            Receive
                        


                            Intermediate event (message)
                        




                            Send
                        


                            Automated activity
                        




                            Transformation
                        


                            Mapping activity or automated activity
                        




                            Container operation
                        


                            Data object (with or without mapping/transformation)
                        




                            Switch
                        


                            Gateway (different types)
                        




                            Loop
                        


                            Gateway and activity
                            (Generally, you use a gateway to support the looping functionality; however, all activities also have their own looping option, which allows you to model multiple parallel instances of the activity in the process model.)
                        




                            User decision
                        


                            Human activity
                        




                            Wait
                        


                            Intermediate event (timer)
                        




                            Control
                        


                            Notification or end event
                        



Table 16.2    ccBPM to BPMN 2.0 Reference Guide
As you may have noticed in the reference guide (Table 16.2), there are some ccBPM objects mapped to more than one equivalent flow object in SAP BPM's BPMN 2.0 palette, which means that there might be different ways of modeling your current process logic in SAP BPM to obtain the same result.

Tip
It's crucial that you keep in mind the following core design principle when redesigning the process model and doing the basic process logic translation: the new SAP BPM BPD, including its process orchestration logic, must deliver at least the same process functionality or better than its predecessor implemented in the ccBPM version.
If you encounter challenges or blocking issues while doing the business process redesign that might prevent you from meeting that core principle, then you should seek feasible alternatives and, if necessary, outsource those specific blocking components to a different layer in the SAP BPM application (e.g., Java custom logic or business rules), or consider moving some process logic to the backend system if applicable.

16.2.3    Export and Reuse Enterprise Services Repository Objects
The third step of the migration procedure involves creating a clear overview and making a preselection of the following:


                    Which SAP PI repository objects can be directly migrated without changing them?
                

                    Which objects can be migrated but require some adaptation?
                

                    Which objects need to be re-created from scratch?
                

                    Which objects will be discarded in the new SAP PO solution?
                

Based on that information, you can then estimate the design and configuration time requirements needed to execute the complete migration.
You can save valuable time during this task when you know that most SAP PI repository objects are supported in SAP PO, except for ccBPM integration processes, abstract interfaces, and any ABAP mappings.
This procedure consists of an export from the source repository of SAP PI containing the existing design objects you want to migrate and an import to the target repository in SAP PO.

Note
Where relevant, you can also perform a normal transport between the two ES Repository installations. This approach does require additional CTS+ configuration.

Before you start, make sure that you've created all required SWCVs with their corresponding namespaces in the target SLD and ES Repository.
The export procedure is as follows:


                    From the old SAP PI (dual-stack) system, go to the Enterprise Service Repository home page, and click on the Enterprise Service Builder link.
                

                    Go to http://<hostname>:<port>/dir where <hostname> and <port> correspond to the SAP PI host—for example, http://sappi.rojoconsultancy.com:50000/dir.


                    Navigate to Tools • Export Design Objects. You should see a window like the one displayed in Figure 16.3.
                    
Figure 16.3    Exporting ES Repository Objects


                    Select the Software Component Version in which the objects exist that you want to export, and choose Transport Using File System in the Mode dropdown menu.
                

                    The export file will be created with the extension .tpz, and depending on your choice, it will be created either on the SAP PI server (from where you perform the export) or on a local folder on your client PC. You can enable that functionality simply by selecting the Download File to Client checkbox.
                

Table 16.3 provides an overview of the export and import folders. If you don't select the Download File to Client checkbox, then you'll need the corresponding operating system-level authorizations on the SAP NetWeaver Application System to retrieve the exported .tpz files.




                            Type
                        

                            ES Repository Folder
                        





                            Export
                        

<systemdir>/xi/repository_server/export




                            Import
                        

<systemdir>/xi/repository_server/import




Table 16.3    ES Repository Export/Import Folders
On the next screen, you can select which design objects you want to include in your export file based on different criteria. We recommend that you select Individual Objects from the Object Set dropdown menu, unless you're sure you can reuse all design objects in one single namespace or SWCV (see Figure 16.4).

Figure 16.4    Selecting Individual ES Repository Objects

Adding Fault Message Types to Existing Service Interfaces
Although existing service interfaces can be reused in SAP PO, you should consider reconfiguring them in terms of adding default fault message types to their service definitions. That will allow you to support exception handling using boundary events when modeling your new processes in SAP BPM. This recommendation doesn't apply for outbound asynchronous service interfaces.


Abstract Interfaces in SAP PO
You might also have noticed that the Abstract option in SAP PO for declaring service interfaces hasn't completely disappeared from the Category dropdown menu in the ES Builder (see Figure 16.5). This might be confusing because you know that this type of interface category isn't supported (it's only needed for ccBPM scenarios) or needed anymore in SAP PO or AEX Java-only systems. You shouldn't try to reuse this deprecated capability in non-ccBPM scenarios in SAP PO because it might result in unpredictable runtime behavior. Surprisingly, if you carry on and activate the abstract interfaces, you'll be able to configure this type of service interface and activate it in any Integrated Configuration (ICO). Currently, there is no restriction or validation message during the activation process that warns you about this faulty choice.

Figure 16.5    Abstract Service Category in SAP PO

16.2.4    Migrate and Adapt Configuration Scenarios
We dealt with the ES Repository objects in the previous migration step, so now it's time to concentrate on the configuration time objects, which are maintained in the Integration Directory.

Note
We're assuming in this step that you're migrating ES Repository objects from SAP PI versions not older than 7.1. If you're migrating from an older version, then you might need to re-create some objects manually, especially for communication channels, due to a change in the adapter metadata version.

SAP PO provides a wizard-based tool for the migration of existing integration directory content, including communication channels and configuration scenarios that can be directly migrated to ICOs. The Integration Directory Migration tool automatically detects all available SAP PI and SAP PO directory instances in your environment. In the Integration Directory Migration tool, you select which configuration scenarios you want to migrate from which system to which system and how you want to move or rename the objects. Furthermore, this Migration tool also supports a mass change functionality that can be applied to communication channels and configuration scenarios—for instance, to rename all or specific directory objects while performing the directory migration.
Integration Directory content from previous releases of SAP XI, SAP PI, and SAP PO (i.e., 3.0, 7.0, 7.1, 7.11, 7.3, 7.31, 7.4, and 7.5) is supported by the tool. To use the Migration tool, follow these steps:


                    Access the tool from the pimon URL: http://<hostname>:<port>/pimon, where <hostname> and <port> match the target system, which can be SAP PO, AEX, or Advanced Adapter Engine (AAE) running under a dual-stack system—for example, http://sappo.rojoconsultancy.com:50000/pimon (see Figure 16.6).
                    
Figure 16.6    Migration Tool in SAP NetWeaver Administrator


                    Click on the Migration Tool link from Configuration and Administration tab. You should now see a screen like the one shown in Figure 16.7.
                    
Figure 16.7    Integration Directory Migration Tool Main Page

Tip
The Integration Content Migration tool can be directly accessed and launched via http://<Hostname>:<Port>/webdynpro/resources/sap.com/tc~pi~tools~dirmig~wd/DirectoryCockpit.

Figure 16.8 shows the first of the five-step Scenario Migration procedure, where the source and target system are selected.
                    
Figure 16.8    Scenario Migration


                    In the System Name dropdown, select the SAP PI source system from which the tool must read the configuration scenarios to be migrated.
                

                    Select the Use Secure URL checkbox if secure communication applies.
                

                    Enter the SAP PI User Name and Password for the source system; the user must be authorized to use the Directory API for display purposes.
                

                    Provide the SAP PO User Name and Password for the target system, and click on Next.
                

                    On the following screens, you can select on which criteria you want to migrate the existing configuration scenarios to SAP PO (see Figure 16.9).
                


Figure 16.9    Selecting the Scenario Migration Criteria
For more detailed information and guidance about how to use the Migration tool, refer to Chapter 8, Section 8.4.2, where the usage of this tool is extensively covered.
The tool also offers other useful features, such as mass editing or movement of communication channels and renaming existing configuration objects before creating them in the new SAP PO environment.
You create your own renaming rules based on suffixes added to the old configuration object names or by applying more specific value mappings to the migrated configuration objects. The renaming rules functionality is accessible via the Configuration link in the Integration Directory Migration tool (see Figure 16.10).

Figure 16.10    Migration Tool Renaming Rules









16.3    Recommendations
Based on our own experience in several ccBPM to SAP BPM migration projects, we would like to share the following useful tips and tricks with you:


Modeling and redesigning business processes


                        The direct involvement of the business and process stakeholders is very important when modeling or improving business processes. You should actively involve both parties from an early stage of the migration, especially if you're planning to redesign the existing ccBPM integration processes. As we know, SAP BPM isn't just an IT tool but rather an enabler to achieve the short- and long-term goals set by the business.
                    

                        Always design and model your business processes following the correct design patterns, standards, and naming conventions applicable for BPMN 2.0.
                    

                        Introduce naming conventions to be applied in SAP BPM, including SAP BPM and SAP BRM objects.
                    

                        Start modeling your processes from a happy flow perspective, that is, the default path your business process is expected to follow under normal circumstances. Then, start adding more details and process logic to it, such as exception handling, reporting steps, and so on.
                    

                        When modeling a business process that collects multiple intermediate messages (with the same or different message types), use an event-based gateway in combination with a timer or any other logical condition to avoid endless loops in your process.
                    

                        Remember that to support exception handling in SAP BPM using boundary events linked to automated activities, your service interfaces must contain a fault message type associated with its service definition.
                    



Skill set and way of working


                        Consider the fact that the skill set required in an SAP BPM project is different from that for ccBPM projects. Developers will need to have a basic understanding of Java-based toolsets and Java programming.
                    

                        The implementation team will need to be familiar with BPMN modeling and principles.
                    

                        Given that BPMN is a more business-friendly modeling annotation (as opposed to the BPEL used in ccBPM), involve the business in your SAP BPM implementation.
                    

                        Because SAP BPM has a better user-centric capability than ccBPM, consider improving the existing process during your migration by providing better functionalities for human-based tasks.
                    

                        Consider extending your current ccBPM error handling. Because SAP BPM offers more features to handle errors, you don't necessarily need to translate one on one, but you can improve it.
                    

                        Consider setting up a transport strategy to include Java-based development. As an example, you can consider setting up CTS+ as a common transport platform.
                    

                        Extend or develop a naming convention to include SAP BPM-related objects.
                    



Infrastructure


                        You'll need a Java-based development infrastructure, including SAP NetWeaver Developer Studio. You'll need to keep up the SAP NetWeaver Developer Studio version with your current SAP NetWeaver server version. As the server is upgraded with new versions, you'll need a good rollout strategy for SAP NetWeaver Developer Studio to ensure a consistent developer setup.
                    

                        We strongly recommend installing SAP NetWeaver development infrastructure to facilitate source controls and concurrent development by multiple team members.
                    

                        Given that your Java-based development artifacts might depend on SAP PI objects (ES Repository or Integration Directory), consider developing an approach that ensures SAP BPM objects aren't transported without the service interfaces that they depend on.
                    

                        Set up an authorization matrix to ensure that the different developers or the administrator will have all required SAP BPM roles to perform their activities.
                    

                        If you're using SAP NetWeaver development infrastructure, consider setting up the required SAP BPM dependencies for your SCs in the SLD.
                    

                        Don't underestimate the preparation of the complete infrastructure required for SAP BPM—for instance, SAP NetWeaver development infrastructure, SAP NetWeaver Developer Studio, and so on.
                    

                        Consider tuning SAP BPM performance-related parameters, as described in Chapter 11.
                    

                        Proper preparation is also needed for user management, especially if you're planning to use SAP BPM for human-centric processes. This includes users, groups, roles, and authorizations in the user management engine (UME).
                    

                        Even with this great book about SAP PO, sometimes you just won't find all the answers you need. In that case, you can also try to find answers at SAP's community for SAP BPM at www.sap.com/community/topic/process-orchestration.html, where you'll find interesting forums, helpful blogs, and useful resources related to SAP BPM.
                    












16.4    Summary
When it comes to supporting both system-centric and human-centric process orchestration, SAP PO is currently the top choice for organizations with an SAP rich landscape. That evolution also marks the end of the ABAP era for SAP PI because no further developments or enhancements are expected to happen around ccBPM. Ultimately, ccBPM will completely disappear, together with its ABAP stack companion, to allow SAP PO to support stateful and stateless integration scenarios all from the same lightweight and single Java stack.
With the information we have provided in this chapter, you should now be able to plan and execute an effective ccBPM to SAP PO migration project. You know which aspects of your existing integration processes need to be analyzed, which preparation steps you have to perform in SAP PO before you can start building up new SAP BPM flows, and that you have to start actively involving the business and process stakeholders in your process redesign plans before you start realizing them.
In the next chapter, we will move to the last part of this book, and discuss some of the more advanced SAP PO and SAP Cloud Platform components.








Part IVAdvanced Concepts







17    SAP Cloud Platform Integration for SAP PO"I don't need a hard disk in my computer if I can get to the server faster . . . carrying around these non-connected computers is byzantine by comparison."                                                                                                             - Steve JobsAs of SAP Process Orchestration (SAP PO) release 7.5, with SAP's latest cloud integration platform, SAP Cloud Platform Integration, it's possible to reuse and leverage artifacts developed in your SAP Cloud Platform Integration tenant SAP PO. SAP PO is now equipped with a small and lightweight SAP Cloud Platform Integration runtime engine. Therefore, it's possible to deploy, run, and manage the cloud integration content artifacts (e.g., integration flows, value mappings, and security artifacts) in SAP PO.The purpose of this chapter isn't to cover SAP Cloud Platform Integration as an integration platform, but to explain how it integrates with SAP PO. If you want to learn more about SAP Cloud Platform Integration, refer to the book SAP HANA Cloud Integration by Bilay, Gutsche, and Stiehl (SAP PRESS, 2016 www.sap-press.com/3979).This chapter focuses on explaining how the cloud integration content artifacts of SAP Cloud Platform Integration can be leveraged in SAP PO. We cover the following topics in the next sections:

            How to enable cloud integration content
        

            How to download, deploy, and consume services
        

            How to perform monitoring
        
Note that this feature isn't automatically made available as you install SAP PO 7.5.We'll begin by discussing how to enable cloud integration content in SAP PO.
17.1    Enable Cloud Integration Content in SAP PO
To use cloud integration content in your SAP PO instance, the following prerequisites need to be in place:


                You must have an SAP Cloud Platform Integration tenant.
            

                You must enable the integration gateway component in SAP PO (discussed later in this section).
            

                You must ensure that the user performing the installation has the roles mentioned in Table 17.1.
                



                                Role Name
                            

                                Description
                            





NWA_SUPERADMIN


                                Provides authorization to view, modify, and import trust certificates in SAP NetWeaver Administrator.
                            



NWA_READONLY


                                Provides authorization to view and display monitoring data in SAP NetWeaver Administrator.
                            



SAP_XI_ADMINISTRATOR


                                Provides authorization to view, modify, and deploy security artifacts in the Cloud Integration Content Management Cockpit.
                            



SAP_XI_CONFIGURATOR


                                Provides authorization to view, modify, and deploy cloud integration content in the Cloud Integration Content Management Cockpit.
                            



Table 17.1    Roles Required to View, Deploy, and Monitor Cloud Integration Content


Enabling the integration gateway component is a prerequisite to using the cloud integration content. The integration gateway can be enabled using the Central Technical Configuration (CTC) wizard, as follows:


                Go to the SAP NetWeaver Administrator at link http://<hostname>:<port>/nwa.
            

                From that page, navigate to Configuration • Scenarios • Configuration Wizard.
            

                From the Configuration wizard, find the PI Cloud Integration Content, as shown in Figure 17.1.
            

                Select the PI Cloud Integration Content entry from the table, and click on the Start button. This will start the wizard to enable the SAP Process Integration (SAP PI) cloud integration content.
                
Figure 17.1    Executing the CTC Wizard for PI Cloud Integration Content


After the wizard is completed, the Status column will be changed to Finished successfully.









17.2    Reusing Cloud Integration Content
After all the prerequisites mentioned in the previous section are in place, follow these high-level steps:


                Download the cloud integration content bundle from your SAP Cloud Platform Integration tenant.
            

                Deploy the cloud integration content in SAP PO.
            

Let's now explore each one of these steps in detail.
17.2.1    Download Cloud Integration Content
To make your SAP Cloud Platform Integration flows available in SAP PO 7.5, you must download them first by following these steps:


                    Log in to your SAP Cloud Platform Integration tenant.
                

                    If the content that you want to make available on SAP PO isn't yet available in your Design space, first copy it from the Discover section. If you already have it on your design space, proceed to step 4.
                

                    In the Discover section, search the desired content, and copy it to your design space by clicking on the Copy button on the top-right corner of the page as shown in Figure 17.2.
                    
Figure 17.2    Copying the Content to the Design Space


                    Go to your Design space, and search the copied or concerned content. After finding it, perform the required configuration in terms of communication channels.
                

                    Open the concerned Integration Flows (iFlow), and select the appropriate product profile depending on the version of your SAP PO installation, as shown in Figure 17.3.
                    
Notes
It's important to choose the Product Profile that matches the version of SAP PO that you've installed on premise. The Product Profile selection performs a check to ensure that the artifacts used in the IFlow are compatible with your SAP PO version.


Figure 17.3    Selecting the Product Profile to Match Your SAP PO Installation


                    Use the Export button to export the content of the package in a ZIP file, as shown in Figure 17.4.
                


Figure 17.4    Export the Content to Your Local Computer as a ZIP File
The cloud integration content can now be deployed in SAP PO.
17.2.2    Deploy the Cloud Integration Content
After you've successfully downloaded the cloud integration content to your local file system; it's now time to deploy it to your SAP PO by following these steps:


                    Log in to the landing page of your SAP PO via the link.
                

                    From there, navigate to the Cloud Integration Content link, also known as the Cloud Integration Content Management Cockpit. You then land on a page similar to Figure 17.5. From the Cloud Integration Content Management Cockpit, all deployed cloud integration content is displayed.
                    
Figure 17.5    Cloud Integration Content Management Cockpit

Note
You can also access the Cloud Integration Content Management Cockpit directly via http://<hostname>:<port>/IGWGBDeploy/Admin.



                    Select the Deploy button as shown in Figure 17.5. You're then presented with a pop-up screen allowing you to select the previously downloaded ZIP file with integration content (see Figure 17.6).
                


Figure 17.6    Deploying Integration Content from a ZIP File

Notes
Two approaches can be used to deploy integration content from SAP Cloud Platform Integration in SAP PO: via the file system or directly connecting to your tenant. In our example, we've chosen to use the file system. If you prefer using the direct connection to the cloud tenant, you don't need to download the file to your local file system.

If your sender and receiver channels use any security artifacts; you can also deploy them using the SECURITY ARTIFACTS tab. If your sender and receiver channels use any endpoints, these are automatically deployed in the END POINTS tab. Both tabs are shown in the menu section of Figure 17.6.

Calling Services on SAP PO
One of the questions that arise is how to consume services that have been deployed to your SAP PO installation based on SAP Cloud Platform Integration content. This is especially relevant for services exposed based on Simple Object Access Protocol (SOAP) or IDoc, for instance.
For iFlows using the IDoc or SOAP (Web Services Reliable Messaging) adapters in their sender side, you can call them using the URL with the format http(s)//<hostname>:<port>/igwcxf/services/<address>.
Note that the <address> is the relative endpoint address that is used to listen to incoming requests, which is provided during configuration of the communication channel in the iFlow.










17.3    Monitoring
This section describes the tool made available to monitor the integration gateway component and messages related to the deployment of cloud integration content. Both monitoring aspects are described next.
17.3.1    Monitoring the Integration Gateway Component
Use this monitoring feature to ensure that the integration gateway component—responsible for the functionality of the SAP Cloud Platform Integration runtime engine in SAP PO—functions properly. Furthermore, this monitoring component serves the following purposes:


                    To get an overview of the status of the integration gateway component
                

                    To call the configuration data of integration gateway component
                

                    To use a self-test to check whether the runtime components are functioning correctly
                

                    To check whether the integration gateway is active on system
                

                    To check whether the secure keystore is available
                

                    To check whether all integration gateway applications are running without errors
                

                    To check whether all cloud integration content is running without errors
                

The integration gateway component monitor can be accessed as follows:


                    Go to the page with the URL http://<hostname>:<port>/dir.


                    From that page, select the Component Monitor link.
                

                    You're presented with a page containing all the components available on your server. Select the Integration Gateway row from the table as shown in Figure 17.7.
                


Figure 17.7    Monitoring the Availability of the Integration Gateway

Note
You can refresh the result and overall status of the health of the component using the Repeat Ping and Repeat Self-Test buttons at the top of the page shown in Figure 17.7.

17.3.2    Monitoring Messages Related to the Deployment of Cloud Integration Content
The message monitoring can be used to follow and track the statuses of messages flowing in your SAP PO server as a result of interfaces that relate to the deployed cloud integration content. Furthermore, you can find errors that have occurred and determine their cause of errors.
To access the message monitoring, follow these steps:


                    Go to the page with the URL http://<hostname>:<port>/pimon.
                

                    Navigate to the links Adapter Engine and Message Monitoring, respectively.
                

                    From this page, select the Cloud Integration Content tab as shown in Figure 17.8. From this tab, it's possible to filter messages based on various metadata criteria.
                


Figure 17.8    Impression of the Cloud Integration Content
To view detailed logs about any messages, select the concerned row, and message details are displayed at the bottom part of the page as shown in Figure 17.8.









17.4    Summary
In this chapter, we took a look on how to leverage SAP Cloud Integration content in SAP PO, which has been made available with SAP PO 7.5. We also discussed the different aspects, including enabling, deploying, running, and monitoring the messages. After reading this chapter, you're now able to perform all necessary tasks to run your SAP Cloud Platform Integration artifacts in your SAP PO installation. In the next chapter, we'll look at some additional useful components that can be used in your SAP PO landscape.








18    Additional Components for SAP Process OrchestrationMake everything as simple as possible, but not simpler.                                                                                                    —Albert EinsteinSAP Process Orchestration (SAP PO) is entirely based on the SAP NetWeaver Application Server for Java (SAP NetWeaver AS Java) and comes equipped with more tools than just SAP Business Process Management (SAP BPM), SAP Business Rules Management (SAP BRM), and the Advanced Adapter Engine Extended (AEX). These other components cover other needs that are complementary to the functionalities provided by SAP PO. In this chapter, we'll explore some of these components and applications that will be useful in your daily activity as an integration expert using SAP PO, including the following:

            Component model
        

            SAP NetWeaver development infrastructure


            SAP Composite Application Framework (SAP CAF)


            Service Registry
        

            Enhanced Change and Transport System (CTS+)

Each of these components has an extensive set of features and could fill a book of its own. The goal of this chapter is to specify how they can be used within the context of SAP PO. The chapter will therefore only focus on relevant highlights and tips for these components.Be aware that most of these components are disabled by default and that you can enable them from SAP NetWeaver Administrator's Functional Unit Configuration UI. The chapter will also explore the important concept of the component model in SAP NetWeaver.
18.1    Component Model
The component model is a development approach that allows and encourages developers to divide their software project into different components instead of putting everything in one big software component (SC). The component model concept is used for almost every development performed with SAP NetWeaver Developer Studio. It's especially important to understand it when using the SAP NetWeaver development infrastructure.
Breaking the software into multiple components makes it easier to read, follow, and understand the developed software. With the component model approach, it's possible to have reusable units expose some of their functionalities publicly via public parts (discussed in more detail in Section 18.1.5). The component model is built into the inner workings of the SAP NetWeaver AS Java. Figure 18.1 shows how products, SCs, and development components (DCs) relate to each other in the component model.

Figure 18.1    Structure of Component Model, Including Products, Software, and DCs
The next sections look at each of these objects in more detail.
18.1.1    Product
A product is an installable unit of software that includes a logical bundling or grouping of multiple SCs and is the highest object in the software catalog hierarchy. A product has a version and is maintained in the System Landscape Directory (SLD). We also discussed products when we explored the SLD in Chapter 3; please refer there for more details.
18.1.2    Software Components
SCs are grouped under a product, which means that you'll need to have a product available before you can create a SC. This is especially true if you're using SAP NetWeaver development infrastructure, in which case you need to create the SC in the SLD. We'll explore SAP NetWeaver development infrastructure later in Section 18.2. For now, we'll focus on SCs from a local development—without using SAP NetWeaver development infrastructure.
To create a local SC, follow these steps:


                    Open SAP NetWeaver Developer Studio.
                

                    Change the perspective to Development Infrastructure.
                

                    Open the LocalDevelopment development configuration.
                

                    Right-click on the empty space of the Component Browser, and choose New • Software Component (Figure 18.2).
                    
Figure 18.2    Creating a New Software Component from SAP NetWeaver Developer Studio


                    Specify the Name of the SC vendor. Note that the Source SC radio button is selected (Figure 18.3).
                    
Figure 18.3    Details of the SC


                    Click on the Next button to proceed with the wizard.
                

                    On the next screen, you can select the SCs on which the one being created depends. By default, all of them are selected, and we suggest that you leave it as such.
                

                    Click on Next to specify the version details of your SC, such as release, support package, and patch level. You can change these values if you wish, but it's optional. For now, keep the default values.
                

                    Click on Finish.
                

You've successfully created your local SC. The newly created SC can be seen by expanding the LocalDevelopment node.
18.1.3    Development Component
A development component (DC) packages a number of development objects and has an interface that defines which one of its development objects and functionalities can be viewed and used from the outside. The rest of its objects and functionalities are only accessible internally (from within the DC).
Development objects contained in the DC are generally referred to as the source. A development object can be anything: a Java class used in a Java proxy, a Business Process Model Notation (BPMN) diagram used in SAP BPM, a decision table in SAP BRM, and so on—almost any development artifact. These development objects are generally organized in namespaces or Java packages within the DC. A DC has a type, which is used to determine the kind of development objects that are allowed to be created in it. A DC is created from SAP NetWeaver Developer Studio, which only allows you to create the DC types that can be deployed in SAP NetWeaver AS Java. See Figure 18.4 for a high-level overview of possible DC types.

Figure 18.4    Possible DC Types within SAP NetWeaver Developer Studio
To create a new DC from your local development configuration, follow these steps:


                    Right-click on the desired SC, and choose New (see Figure 18.5).
                

                    From the resulting submenu, select Development Component.
                

                    On the next screen, specify the type of DC to be created. When choosing a particular DC type, only development objects of that DC type can be developed. Refer to Figure 18.4 for the list of available DCs to choose from.
                

                    After selecting the desired DC, click on the Next button to proceed with the wizard.
                

                    Provide the details of the DC to be created, including the name and a vendor.
                

                    Click on the Finish button to complete the development configuration.
                    
Figure 18.5    Creating a New DC in Your SC


18.1.4    Dependencies among Development Components
As previously stated, a development can expose its functionalities via the concept known as a public part, a mechanism by which you can publicly expose a list of development objects (e.g., classes or even all Java packages). Other DCs can then use these functionalities. Dependencies among the different DCs don't need to be static and can change or be totally removed after their creation. In cases of removal of dependencies, it's important to ensure that functionalities dependent on the removed dependencies are no longer used and needed.
To establish a dependency between two DCs, the following conditions need to be satisfied:


                    The DCs in question need to belong to the same parent SC. Alternatively, the two SCs need to have dependencies explicitly declared.
                

                    The DC to be used must not be part of the exclusion in the Access Control List  (ACL), which can be used on a DC to restrict the components that can use it. Only the components used in the ACL are entitled to specify a dependency to the component. An access control can be defined from the Permissions tab of the SC properties.
                

                    The types of both DCs must be compatible.
                

A DC can use another DC's functionality by pointing to its public interface. To add a dependency to a DC, follow these steps:


                    From SAP NetWeaver Developer Studio, switch to the Development Infrastructure perspective.
                

                    Select the desired DC from the left side of the screen. An overview of the DC's properties is shown on the right side of the screen.
                

                    Select the Dependencies tab, as indicated by Figure 18.6.
                    
Figure 18.6    DC Dependencies
                    In the left panel of Figure 18.6, you can see the list of all existing dependencies that this DC currently has. You can select any of these dependencies and see the dependency details. For any given dependency, you can specify the following dependencies details by selecting the appropriate checkboxes:
                    

Design Time Mostly used during development time by means of a development editor and means that your DC needs functionalities or objects of another DC during the implementation.
                        

Deploy time This type of dependency requires that the used DC already exists in the runtime system (SAP PO). If the DC doesn't exist in the PO runtime, then the deployment will fail.
                        

Runtime Used when one DC depends on another DC during runtime.
                        



                    Click on the Add button. You're then prompted with a new pop-up screen containing a list of SCs and DCs to select from (Figure 18.7). This screen allows you to filter for the desired DC. After finding the correct DC, tick its checkbox and click on the Next button.
                    
Figure 18.7    Selecting a DC as a Dependency


                    On the next screen, you can choose from among Design Time, Deploy Time, or Runtime dependency types by ticking the desired checkboxes. Then, click on the Finish button (see Figure 18.8).
                

                    In some cases, you might be asked to synchronize the dependencies. It's advisable to accept the suggestion to keep all dependencies in sync.
                


Figure 18.8    Selecting the Dependency Type

Note
Just like DCs can have dependencies toward each other, it's also possible to define dependencies between SCs. For a DC to have a dependency toward a DC residing in a different SC, the two parent SCs need to have entered dependencies as a prerequisite.

18.1.5    Public Parts
The inner workings, functions, and objects of a DC are completely invisible to the outside world by default. A public part of a DC can be seen as its interface. It exposes a number of development objects and functions visible to other DCs. You can create more than one public part per DC. The only requirement is to uniquely name the public parts. Figure 18.9 shows a diagram of DCs that have dependencies to other DCs with the help of public parts (here represented by "PP").

Figure 18.9    Enabling Visibility and Dependencies Using Public Parts between Different DCs
When creating a public part of a DC, you'll need to define its purpose or usage. The following two public part purposes exists:


Compilation The classes and functions exposed via the public part will be used during the compilation of the DCs that use it.
                

Assembly The classes and functions exposed via the public part will be packaged in the assemblies or archives of the DCs that use it.
                

To create or add a public part to an existing DC, follow these steps:


                    From SAP NetWeaver Development Studio, go to the Development Infrastructure perspective.
                

                    Select the desired DC (from the left pane of the screen).
                

                    Select the Public Parts tab.
                

                    Click on the Add button to create a new public part.
                

                    On the subsequent screen, specify the details of the new public part, especially the name and purpose attributes.
                

                    Click on the Finish button. The newly created public part is then added to the list of public parts (see the public part named pp_person in Figure 18.10).
                

                    Right-click on the public part, and select the Manage Entities option (see Figure 18.10).
                    
Figure 18.10    Adding Different Entities or Development Objects to a Public Part


                    A new screen appears with options to select the development objects to be exposed via the public part. Depending on the type of DC at hand, you'll be presented with different types of development objects to choose from.
                

                    Expand the node of the desired category (Java Class, Java Package, Java Package Tree, File, Folder, or Folder Tree) for it to be exposed via the public part. For simplicity's sake, assume that you want to expose a Java class in your public part. Expand the Java Class node, and then select the desired Java class.
                

                    After selecting the desired entity to expose via the public part, click on the Finish button. The entities are now added to the public part and can be accessed by other DCs. Figure 18.11 shows a public part and the entities that it exposes.
                


Figure 18.11    Public Part Populated with Entities That Are Able to be Accessed by the Outside World









18.2    SAP NetWeaver Development Infrastructure
SAP NetWeaver development infrastructure (often referred to as NWDI) is an SAP-proprietary version-management tool for Java development. Using SAP NetWeaver development infrastructure increases the productivity of software developers in a number of ways:


Securing the source code No one wants to lose development work by accident only to find out that there are no backups. SAP NetWeaver development infrastructure enables you to centrally store your source code in a remote location.
            

Facilitates teamwork Enables multiple developers to work simultaneously. Each developer will get a copy of the source code on his local machine.
            

Accesses the history of every source file You can go back to the previous versions and compare between the different versions, thus achieving version management.
            

Prevents source code conflicts SAP NetWeaver development infrastructure locks used source files. It also provides a very useful check-in and check-out mechanism.
            

Integrated with the SLD This integration facilitates the reusability of SLD objects, such as SCs.
            

Natively integrates with CTS+ to facilitate transports SAP NetWeaver development infrastructure then acts as the source repository to directly export SCs to the CTS+ to perform transport activities toward the next environment.
            

Increases quality of the source code delivered SAP NetWeaver development infrastructure ensures that only source code without compilation errors is checked in the repository.
            

Different aspects of these advantages will be touched upon as we explore the various SAP NetWeaver development infrastructure component and services.
Technically, SAP NetWeaver development infrastructure can be installed on any SAP NetWeaver AS Java-based installation, which also means that you can enable SAP NetWeaver development infrastructure in the same installation that runs SAP PO. However, it's not recommended to do so. It's better to use a separate installation for SAP NetWeaver development infrastructure.
SAP NetWeaver development infrastructure can be reached by following these steps:


                Go to http://<hostname>:<port>/nwa.
            

                Select the Configuration tab.
            

                Select the Infrastructure subtab.
            

                On the resulting page, click on the Development Infrastructure link.
            

                Alternatively, you can reach it directly via http://<hostname>:<port>/devinf/main.


The main SAP NetWeaver development infrastructure page that can be reached via these steps is shown in Figure 18.12.

Figure 18.12    SAP NetWeaver Development Infrastructure Landing Page
SAP NetWeaver development infrastructure is made of three main components that are well integrated:


                Change Management Services (CM Services) 


                Design Time Repository (DTR)
            

                Component Build Service (CBS)
            

As Figure 18.13 depicts, SAP NetWeaver Developer Studio is used to develop the source code and check-in the source in the SAP NetWeaver development infrastructure. CM Services can be used to export an SC in the form of a Service Component Architecture (SCA) file. The resulting file can then be deployed in any SAP PO runtime environments.

Figure 18.13    SAP NetWeaver Development Infrastructure and Its Components
The components of SAP NetWeaver development infrastructure and the roles that they play are explored in the next sections.
18.2.1    Change Management Services
CM Services is a component of SAP NetWeaver development infrastructure that holds together development configurations. A development configuration is a grouping of SCs under which DCs and development objects will be created. A development configuration created in the CM Services can then be imported from SAP NetWeaver Developer Studio.
As of SAP NetWeaver 7.3, CM Services can be used with two different options:


CTS system With this setup, the configuration uses CTS+ as the transport mechanism.
                

Standalone With this type of setup, CM Services has no integration with CTS+. It therefore requires manual actions (e.g., the export functionality) to extract data from it. In the same manner, development objects can be important to any development configuration using the manual import functionality.
                

CM Services provides a variety of services, which we explore in the next sections.
Development Configuration Management
The development configuration service's main purpose is to provide the functionalities to create and maintain the different development configurations in the CM Services. A development configuration represents a view of a developer on the development infrastructure. The configuration puts together a number of the SCs to be developed.
For every development configuration, you can specify the following settings:


System Landscape Directory Specify the URL of the SLD to be used as a source of SCs for use in the different development configurations. The format to be used to point to the SLD is http://<hostname>:<port>.


Runtime System Specifies the SAP PO system to which the developed components can be deployed after a successful compilation of the SC in the CBS.
                    

Export and Import Settings If a standalone development configuration is used, then SAP NetWeaver development infrastructure gives you the option to specify a path to an outbound directory (also called an outbox) where the Export Service can put exported files. It's also possible to specify a path to an inbound directory (also called an inbox) where the Import Service searches for the files that can be imported in SAP NetWeaver development infrastructure.
                    

Transport Settings If a CTS system development configuration is used, then these settings specify how the changes performed on objects need to be exported to CTS+ (also called export mode).
                    

Repository and Build Tool Location You can specify the location of the repository and build tool to be used. Note that these two entries are required. Without specifying the location of the DTR or CBS, you can't add SCs to the development configuration. In general, the repository location needs to point to the DTR. The URL uses the format http(s)://<hostname>:<port>/dtr. Furthermore, the build tool location needs to point to the CBS location. The URL to be provided needs to use the format http(s)://<hostname>:<port>.


Auto-Deployment When checked, this option enables SAP NetWeaver development infrastructure to automatically deploy the software to the specified runtime system every time the CBS performs a successful DC build and a deployable file has been produced. It's also possible to exclude some SCs from being deployed to the specified runtime systems.
                    

Software Component Definition Provides the facility to add and remove SCs to be included in the development configuration. These SCs can be filtered and retrieved from the SLD.
                    

You can create a development configuration from CM Services. Be aware that before you can create a new development configuration, you need to ensure that the SAP NetWeaver development infrastructure has been enabled, is properly configured, and is running. Furthermore, it's especially important that SAP NetWeaver development infrastructure is linked to an SLD.
To create a new development configuration, follow these steps:


                        From the SAP NetWeaver development infrastructure landing page, click on the CM Services link to jump to the Development Configuration Management page (see Figure 18.14).
                    

                        From the resulting page, click on Create New if you're using standalone CM Services.
                        
Figure 18.14    Main Page of Development Configuration Management


                        For CM Services integrated with CTS+, select CTS System from the Filter dropdown. If there are no links with CTS+, then select Standalone from the dropdown. To keep things simple, in this guide, we assume that you're using the Standalone option.
                    

                        Maintain the Name and Caption fields for your new development configuration (Figure 18.15).
                        
Figure 18.15    Specifying the Name and Caption of the New Development Configuration


                        Select the Software Component Definition tab.
                    

                        From this tab, click on the Add SC button to add SCs (Figure 18.16). The Software Component Definition tab enables you to add SCs from the SLD to the development configuration.
                        
Figure 18.16    The Software Component Definition Tab of a Development Configuration
                        After clicking on the Add SC button, a new pop-up appears with the list of SCs in the SLD (see Figure 18.17).
                        
Figure 18.17    Adding a New SC to the Development Configuration from the SLD


                        After selecting the desired SC from the page displayed in Figure 18.17, click on the Add button.
                    

                        Repeat the preceding two steps for every SC that you want to add to your development configuration.
                    

                        When finished, click on the Close button.
                    

                        Click on the Save button (top-left corner of Figure 18.18) to ensure that your changes are stored in the development configuration.
                    


Figure 18.18    Saving the Development Configuration after Adding SCs
You're now ready to advance to your next task: importing the newly created development configuration into SAP NetWeaver Developer Studio, as follows:


                        Open SAP NetWeaver Developer Studio.
                    

                        Switch to the development infrastructure perspective.
                    

                        Right-click on the empty space of the Component Browser, and select New • Development Configuration (see Figure 18.19).
                        
Figure 18.19    Adding a New Development Configuration in SAP NetWeaver Developer Studio


                        You'll see a new screen, from which you can select from among the following options (see Figure 18.20):
                        

Import from System Landscape Directory (SLD) This option needs to be used if you decide to use a development configuration that exists in CM Services. Note that for this option to work, you must have configured to point to the SLD in SAP NetWeaver Developer Studio. This configuration setting can be found under the Windows and Preference menus of SAP NetWeaver Developer Studio.
                                
Figure 18.20    Options Available to Create a Development Configuration


Import from Development Configuration File This option can be used when you don't have direct access to CM Services and have exported the development configuration from it using its export functionality. This option allows you to import the development configuration from a file.
                            

Create from Scratch This option can be used to create a local development configuration on the local file system from which SAP NetWeaver Developer Studio runs.
                            

                        In this case, select the Import from System Landscape Directory (SLD) option.
                    

                        When prompted, log in to SAP NetWeaver development infrastructure.
                    

                        After a successful login, you can select the desired development configuration from CM Services, and click on the Next button. The loading of the development configuration might take a few seconds.
                    

                        On the next screen, specify the name that the development configuration should have in SAP NetWeaver Developer Studio. Notice that even though the development configuration in SAP NetWeaver Developer Studio points to the one in SAP NetWeaver development infrastructure, it doesn't necessarily need to have the same name; the developer can choose to rename it (see Figure 18.21).
                        
Figure 18.21    Renaming the Development Configuration While Importing It to SAP NetWeaver Developer Studio


                        Click on the Finish button to complete the import process of the development configuration. The imported development configuration is now available locally from SAP NetWeaver Development Studio.
                    

The development configuration is ready to be used. New DCs can now be created from the included SCs, as described in Section 18.1.3.
Synchronize Service
Imagine that you find yourself in a situation in which the SAP NetWeaver version running on SAP NetWeaver development infrastructure is different from the one running on SAP PO, meaning that the development environment has a different SP version than the deployment environment (see Figure 18.22). You might then face compatibility issues when deploying.

Figure 18.22    SAP NetWeaver Development Infrastructure with Two Development Configurations for Two SAP PO Runtime Systems
Figure 18.22 depicts a hypothetical situation in which the SAP NetWeaver development infrastructure contains two different development configurations. Each development configuration is intended to be deployed to a different SAP PO runtime system; one runtime system uses SP 05 and the other SP 09.
As a consequence, you'll want DEV CONF1 to be created with dependencies to SP 05-related SCs and DEV CONF2 to have dependencies of SP 09-related SCs. If the dependencies used in the development configuration don't match the SAP PO runtime system, then you'll face issues during deployment. After an upgrade of your target runtime system, you might end up with a different version than the one used in the development configuration in SAP NetWeaver development infrastructure.
In such situations, the Synchronize Service of CM Services comes in handy. CM Services facilitates the synchronization of the SAP NetWeaver development infrastructure with the SAP PO runtime system to which the development will need to be deployed. If the runtime system is upgraded, then the Synchronize Service is used to resynchronize the dependencies with the new versions available in the runtime.
To synchronize your development configuration with a runtime system, follow these steps:


                        Go to the Development Configuration Management page.
                    

                        From this page, select Synchronize Service from the Related Links dropdown menu (see Figure 18.23).
                        
Figure 18.23    Launching the Synchronize Service Option from the Related Links Menu


                        A new page pops up with the Synchronization Service application.
                    

                        Select the development configuration that you want to synchronize (see Figure 18.24).
                        As Figure 18.24 shows, all the SCs included in the development configuration are listed. In addition, the versions of these SCs in SAP NetWeaver development infrastructure and the runtime system are displayed. In the Difference column on the far right, you can see whether there are differences between the versions in these two systems. This column contains the following symbols:
                        

                                Red circle: Versions different in the SAP NetWeaver development infrastructure and the runtime system. Import to the SAP NetWeaver development infrastructure required.
                            

                                Green square: No differences detected.
                            

                                Yellow triangle: Could be a required SC that isn't needed at the SAP NetWeaver development infrastructure build time (to decide, check SAP documentation).
                            

                        SCs with a different version (red) generally signal the need for synchronization.
                        
Figure 18.24    Updating the Dependencies of a Development Configuration Using the Synchronization Service


                        Click on the Next button at the bottom of the screen to proceed with the wizard.
                    

                        On the next screen, you're asked to provide the inbox path where the SCA files of the SCs to be upgraded are located. Select Include Subdirectories in case some SCA files aren't included in the root folder but are in subdirectories. In general, you'll use the path containing the SCA files used to upgrade the target runtime system.
                    

                        On the next screen, you're presented with a list of SCs and action recommendations. A recommended action for whether to skip or import the SC is automatically made by the system. You can change the recommendation action to suit your needs. When ready, go to the next screen. Note the Actions column (shown in Figure 18.25).
                    

                        On the next screen, click on the Synchronize button to start updating the development configuration with new SC archives.
                        
Figure 18.25    Recommended Action to Synchronize SCs


Export Service
After you've successfully performed some development activities, you need to release the content of the relevant SCs to deploy them to the desired target SAP PO runtime system. The Export Service of CM Services can be used to export the content of an SC. The Export Service exports content in the form of SCA or software deployment archive (SDA) files.
If the development configuration was created in as a standalone CM Service, then the export archive file (SCA or SDA) generated by the Export Service will need to be exported and saved on your local machine. These archive files can then be deployed to the target runtime system using SAP NetWeaver Developer Studio or Java Support Package Manager (JSPM).
These archive files can also be imported into another SAP NetWeaver development infrastructure system using the Import Service (the Import Service will be discussed in more detail further ahead).
If the development configuration was created in CM Services integrated with CTS+, then things will work in a slightly different manner. Because there is a direct connection to CTS+, the exported archive file is automatically added to a CTS+ transport request.

Note
Note that when exporting via the Export Service, only entire SCs are exported. You can't only export the changed part of the SC.

To access the SAP NetWeaver development infrastructure Export Service, follow these steps:


                        Go to the Development Configuration Management page.
                    

                        Select Export Service from the Related Links dropdown menu (see Figure 18.26). A new page pops up and launches the Export Service.
                        
Figure 18.26    Accessing the Export Service from the Development Configuration Management Page

Note
Note that you can access the Export Service page directly by going to http://<hostname>:<port>/webdynpro/dispatcher/sap.com/tc~di~cts~config~webui/Export.

                        After launching the Export Service main page, you're presented with a wizard allowing you to export a particular development configuration.
                    

                        Select the development configuration that contains the SC you want to export via the Export Service (Figure 18.27). Click on the Next button.
                        
Figure 18.27    Select the Development Configuration with the Desired SC


                        On the next screen, you're presented with a list of all the SCs present in the development configuration. You can select one or multiple SCs to export. When finished, click on the Next button.
                    

                        On the next screen, you can specify some export option attributes (see Figure 18.28). You can set preferences in the following options:
                        

Support Package Level and Patch Level  These numbers specify the version of the SC. You can freely specify the number using the Set Support Package Level to checkbox.
                            

Include Source/Archives  Tick the checkboxes to include the source and archives in the resulting SCA file. By default, the Include Archives option is selected.
                            

Stop on Error  Includes options to specify whether or not the export task should be interrupted in case of errors.
                            


Figure 18.28    Specifying Export Options for the SCs


                        After specifying the export options, click on the Next button.
                    

                        In the subsequent screen, a summary of the settings is presented. Click on the Export button. It might take a few seconds to export the file. Depending on whether the development configuration is connected to CTS system or standalone, the following different behaviors will pertain:
                        

CTS system With this option, the exported SCA file will be automatically added to a transport request.
                            

Standalone With this option, you'll be provided with a link to download the exported SCA file to your local file system. This file can then be manually deployed to the target runtime SAP PO system.
                            



History Service
The History Service gives an overview and audit trail of activities that have been performed. These include current and old exports, imports, and synchronizations.
From the Development Configuration Management page, the History Service page can be accessed by selecting History Service from the Related Links dropdown menu. From this page, you can specify filtering criteria such as dates and areas (as shown at the top of Figure 18.29).

Figure 18.29    History Service Main Page
Import Service
The Import Service facilitates the import of a development configuration's SCA file into the system. From the Development Configuration Management page, the Import Service page can be accessed by selecting Import Service from the Related Links dropdown menu. This service is intended to be used as an alternative to the Synchronize Service and is mostly intended for expert users.
18.2.2    Design Time Repository
The DTR is an SAP NetWeaver AS Java-based repository that facilitates the versioning and management of different files and source codes. Nearly all types of objects created during design time using SAP NetWeaver Developer Studio can be centrally stored and versioned using the DTR. The DTR is an extensive tool, and we could use a whole chapter to explore it. However, this section aims to give a few highlights and tips that will prove useful for your SAP BRM, SAP BPM, and Java proxies development, especially if you're using them in conjunction with SAP NetWeaver development infrastructure.
The DTR is a modern tool that comprises two main parts:


Server side The server side resides within the SAP NetWeaver development infrastructure server and is placed on a machine that is remote to the developer's machine, resulting in advantages such as the ability to centrally backup and the concurrency, reliability, and scalability of a server. The server side can be accessed via the web client application found by pointing your browser to http://<hostname>:<port>/dtr.


Client side Developers using the DTR will need a client to access its functionality. A DTR client is part of SAP NetWeaver Developer Studio. Having a local client that runs on the developer machine facilitates the consumption of fewer resources on the SAP NetWeaver development infrastructure server and speeds up development. The DTR client uses the Web Distributed Authoring and Versioning (WebDAV) and DeltaV standards to access files stored in the DTR server and can be accessed by switching to the Design Time Repository perspective within SAP NetWeaver Developer Studio. This perspective offers the ability to access the DTR browser and to navigate through its folders. You can also view all open and closed activities.
                

The DTR comes equipped with a number of key features that provide an improved development experience, increased quality of developed software, and decreased development time. Some of these features include the following:


                    A mechanism is available to check in and check out source code. As source code are changed or newly created using SAP NetWeaver Developer Studio, a new open activity is automatically created. An open activity groups all the changes made locally in SAP NetWeaver Developer Studio. The changed objects are automatically locked in the DTR server. As Figure 18.30 demonstrates, the activity can then be checked in to the DTR server. Furthermore, the changes included in the activity can also be reverted if you change your mind about them.
                



                    Multiple versions of development artifacts can be managed at the same time.
                

                    The development objects stored in the DTR are organized in two workspace folders (Active and Inactive).
                    
Figure 18.30    Checking In an Open Activity to the DTR via SAP NetWeaver Developer Studio


                    Version conflicts can be detected and resolved via methods such as merging. As shown in Figure 18.31, the option to resolve conflicts can be accessed via the context menu of a file by selecting Team • Resolve Conflict. From there, you have different options and ways to resolve the conflict.
                


Figure 18.31    Options to Resolve Conflicts from SAP NetWeaver Developer Studio


                    Changes performed on development objects can be grouped with activities that then enable tracking and tracing.
                

It can be argued that given the criticality of the data stored in your SAP NetWeaver development infrastructure server, it should be treated as a productive system. It has a productive state for the developers. If the SAP NetWeaver development infrastructure server goes down, then development activities can't be performed. You might therefore consider treating it like a productive machine and performing all activities that a production environment deserves—such as backups.
When development objects used in SAP NetWeaver Developer Studio are maintained in the DTR, each development object is marked with an icon with a special meaning. See Figure 18.32 for a legend of the different icon meanings.

Figure 18.32    Legend of the Icons Used in the DTR
18.2.3    Component Build Service
The CBS is a JEE application built on top of a database and has the main purpose of facilitating the central building and compiling of source code checked in via the DTR. The CBS also stores the archives used in the different DCs. The CBS is well integrated with the DTR, CMS Services, and Transport Control System.
The CBS distinguishes between the concepts of inactive and active statuses of development objects. As the changed source code are checked in via the DTR, the CBS automatically triggers a central compilation or build of the changed source. Upon a successful build, the status is changed from Inactive to Active.
When a DC uses or depends on another DC, it always uses the version available in the Active status. This is a useful mechanism that prevents the propagation of errors in the active version of the application.
As Figure 18.33 depicts, the following client applications can send build requests to the CBS:


                    CM Services
                

                    SAP NetWeaver Developer Studio
                

                    CBS Web UI (a Web Dynpro-based user interface that allows its users to access the functionalities provided by the CBS)
                


Figure 18.33    Architecture of the CBS and Its Relation to Other SAP NetWeaver Development Infrastructure Components
Upon the arrival of the different build requests from the different clients, the requests are intercepted by an application called the CBS Request Receiver, which places them in a queue. The CBS JEE service application picks up the requests from the queue and executes their build or compilation tasks. Note that the build executions of the different requests can be performed in a parallel manner.
To perform the build operation, the CBS picks up the relevant source code files from the DTR (inactive workspace) and copies them to a temporary folder on the server's file system. This temporary directory is commonly known as the build directory. In the next step, an application known as the CBS Build Controller initiates the actual build or compilation of the source code based on the specifics of the type of component at hand. It's possible to inspect the CBS and its buildspace by accessing the CBS Web UI via http://<hostname>:<port>/devinf.
From there, click on the Component Build Service (CBS) link. You'll see a page like the one shown in Figure 18.34.

Figure 18.34    CBS Overview of the Buildspaces

Note
Alternatively, you can access the CBS Web UI by using the direct link http://<hostname>:<port>/webdynpro/dispatcher/sap.com/tc.CBS.WebUI/WebUI.

From the CBS overview page (Figure 18.34), a helicopter view of all existing buildspaces is presented. In addition, you can find out the following information from the page:


                    Total number of build requests that are currently queued
                

                    Total number of build requests that are currently being processed
                

                    Failed build requests
                

                    Total number of DCs that makes up a particular buildspace
                

                    Whether the DC is broken
                

                    Whether the DC has an Active status
                

If a buildspace contains broken DCs (from the CBS overview), then you can find more details by clicking on the link of the buildspace in question. You'll then see a new screen with details of the buildspace and the DCs that it contains. Each DC is presented with its status. You can click on the broken DC (with a red dot) to see some log details.









18.3    SAP Composite Application Framework
SAP CAF facilitates the modeling of business objects and the building and running of composite services. This section won't detail all there is to know about SAP CAF. Instead, it will briefly focus on its use and highlight some of its features. SAP CAF offers the following capabilities:


                Model business objects.
            

                Specify application logic.
            

                Develop simple services.
            

                Compose services and service mash-ups.
            

                Call and expose web services.
            


Example
To illustrate the use of SAP CAF in a simple manner, assume that you want to quickly put a composite application in place to manage the details of your organization's employees. With SAP CAF, you can very quickly model and design an employee business object and its attributes. SAP CAF then automatically creates a database table to store the employees' details and also makes different services available to enable the business objects' data to be accessed. This type of services is known as entity services because it provides access to the business object or entity. These services can also be converted into web services with the click of a button.

The next section will show you how you can perform the following tasks:


                Model a business object.
            

                Generate different methods on the business object.
            

                Expose these methods as web services.
            

18.3.1    Design Time Aspects
SAP NetWeaver Developer Studio provides a Composite Application perspective from which you can model the different required business objects. We'll go over the main tasks in the following subsections.
Before modeling a business object, you'll need a DC to hold your development objects. The DC will need to be of the composite application type. It's important to note that as you create a DC of the composite application type, SAP NetWeaver Developer Studio automatically creates five other DCs to support SAP CAF developments: a dictionary, Enterprise Java Bean (EJB) module, metadata, and enterprise and user management engine (UME) permissions DCs. Together, these different DCs provide support for database, persistence, application logic, and service layers for the SAP CAF application. Figure 18.35 shows an example SAP CAF project called caf_demo, which contains the five different DCs that have automatically been created.

Figure 18.35    DCs Created as Part of an SAP CAF Development
Furthermore, a caf.core project is also created and contains important data types and services that are delivered by SAP and can be incorporated into your composite application. After DCs have been created, you can switch to the Composite Application perspective to create different business objects.
Business Objects
From the Composite Application perspective of SAP NetWeaver Developer Studio, you can create and model a business object, which represents a business entity that will play a role in your composite service. The framework automatically creates database (dictionary) tables that match the structure of the modeled business object.

Note
Business Object Modeler is an editor available in SAP NetWeaver Developer Studio. From this tool, you can define different aspects of a business object. These aspects include the fields and attributes that define it. You can also define relationships to other business objects. These relationships work exactly like defining foreign keys between tables in a rational database.

A business object can be created from SAP NetWeaver Developer Studio by following these steps:


                        From the Composite Application perspective of SAP NetWeaver Developer Studio, expand your project, and from the context menu of the Business Objects node, select New • Business Object.
                    

                        Provide a name for your business object. The newly created business object is now available under your project tree.
                    

                        Double-click on the newly created business object to open the Business Object Modeler. On the new screen that opens, select the Structure tab (see Figure 18.36).
                        
Figure 18.36    Default Structure of a Newly Created Business Object and Its Fields


                        Click on the Edit Main Structure button to edit the fields of the business object.
                    

                        On the subsequent screen, you can add multiple fields to your business object. Assuming you're modeling an employee business object, you'll want to add fields for first name, surname, and so on. As Figure 18.37 indicates, you'll need to select the data types of the field from the primitive package of the caf.core project (on the left of the screen).
                        
Figure 18.37    Populating the Business Object Fields Using the Structure Editor


                        Select the arrow in the middle of the screen to move data types from left to right. Looking at the Figure 18.37, you'll need to use the left-pointing arrow.
                    

                        The newly created attribute comes with the name newAttribute1. Rename it to a more meaningful name.
                    

You can repeat the preceding steps for as many business objects as you need to fulfill your business requirement.
It's important to be aware that the fields specified for a business object and relationships defined between the different business objects will serve to generate database tables and foreign keys.
Entity Services
An entity service exposes the functionality of the business object. A list of entity services are automatically created by SAP CAF with every business object. To view the list of entity services created, you can expand the business object in the project structure, or select the Operations tab in the Business Object Modeler. As Figure 18.38 depicts, you can add your own additional operations (via the Add button) and specify their input and output parameters.

Figure 18.38    List of Standard Operations in a Business Object
In the background, these operations are generated in Java using EJBs. To see the generated beans, select the Implementation tab in the Business Object Modeler, and click on the link for the Java bean. Note that the generated EJB uses the name format <BO name>BeanImpl.Java.
The list of operations included by default for any given business object are presented in Table 18.1.




                                Operation
                            

                                Description
                            





create


                                Inserts one new record in the database table generated by SAP CAF. It automatically generates a primary key for the entry. This operation doesn't need an input structure. It therefore creates an entry with only the standard input structures filled in.
                            



createMultiple


                                Insert data into the business object table using the business object structure as input parameters. The operation can accept the insertion of multiple records at one time.
                            



delete


                                Deletes a record from the business objects table given a set of attributes as input and filtering criteria. This operation is mostly executed with the primary key as input.
                            



deleteMultiple


                                Works like the delete operation, but can take multiple business object records as input.
                            



findAll


                                Returns all entries of the business object's database table. Notice that this function doesn't have any input parameters.
                            



findByMultipleParamaters


                                Returns a list of business object entries from the database table based on some input parameter filtering criteria.
                            



read


                                Retrieves details of a business object entry in the database, given the primary key of a business object as input.
                            



update


                                Updates details of a business object entry in the database with the details provided in the input parameter.
                            



updateMultiple


                                Works like the update operation but has the capability of accommodating multiple business object entries.
                            



Table 18.1    Business Object Standard Operations
On top of these operations, features that are essential to a composite service (e.g., logging/tracing, persistence, and authorization) are automatically provided by the framework.
Application Service
An application service can be used to implement business logic for your composite application. The logic is implemented using EJB 3.0. As part of defining the business logic, an application service defines the overall behaviors of the application. The application service is the box that holds everything together.
The application service has dependencies to different business objects and external services that have to be used for the application. It's also possible to define custom operations from the application service layer. These operations can in turn encapsulate a number of business object functionalities and expose the composite service to the outside world. Custom business logic can be implemented for these operations.
As Figure 18.39 shows, an application service can be displayed in the diagram editor designer showing all entities that it depends on with all their relationships. The diagram also provides a palette that enables fast modeling via drag and drop of SAP CAF objects.

Figure 18.39    Application Service Diagram

Note
The EJBs' source code isn't always immediately updated with details of the new application service. You must select the SAP CAF project and choose the Generate option in the context menu to force a source code update. You can then implement the needed custom business logic within the method definition. See Figure 18.40 for an example of an EJB in which you need to add custom code in the section reserved for the custom operation.

You can provide an application service as a web service so that it can be consumed by external applications. To create a web service from an application service, choose the Expose Service as a Web Service option from the application service's context menu.

Figure 18.40    Example EJB with Implementation Open for Custom Logic
Now that your business objects and application services are ready, you can build and deploy your SAP CAF project to the SAP PO server.
18.3.2    Runtime Aspects
After a successful development, build, and deployment of your SAP CAF project, it's time to configure or run your service. If your SAP CAF project includes an external web service, then you'll need to configure the endpoints and destinations of the web service to point toward the correct runtime system. This type of configuration can be performed from SAP NetWeaver Administrator. From there, you'll need to navigate to different locations depending on the type of service to be consumed. For external RFCs, you add a new destination by navigating to the SOA and Technical Configuration tabs and then click on the Destinations link.
For external web services, configure the new endpoint by navigating to the SOA and Application and Scenario Communication tabs.
After configuring your SAP CAF project, you can access it via http://<hostname>: <port>/caf.
On the landing page, select the Service Browser link. From there, you can expand the tree on the left side and get to the business object of your choice to perform the needed operation (see Figure 18.41).
If the services were exposed as web services, then you can find the WSDL from SAP NetWeaver Administrator by navigating to SOA • Application and Scenario Communication. You then need to click on the Single Service Administration link.

Figure 18.41    SAP CAF Service Browser with a List of All Available Operations









18.4    Service Registry
The Service Registry is an SAP-proprietary application that represents the yellow pages of web services. It's based on the open standard commonly known as Universal Description Discovery and Integration (UDDI).
It plays an important role in your service-oriented architecture (SOA) strategy and provides a mechanism to register, publish, and discover web services. The services published in the Service Registry are classified and categorized in a manner that facilitates locating them easily. Some capacities of the Service Registry include the following:


                Publish an existing web service in your SAP landscape, including its metadata and endpoint.
            

                Classify and categorize the published service.
            

                Describe and retrieve published web services from the different SAP development tools, including SAP NetWeaver Developer Studio.
            

                Query and search existing published web services.
            

                Interoperate with other, non-SAP tools.
            

                Define custom classifications.
            

                Export and import the data contained in the Service Registry.
            

After locating a web service, you can gain access to its metadata and endpoint. The Service Registry can be accessed via http://<hostname>:<port>/sr. From this URL, you'll land on the Service Registry main page (shown in Figure 18.42).

Figure 18.42    Service Registry Landing Page
Be advised that the Service Registry isn't available by default in an SAP PO installation; it needs to be configured and made available from SAP NetWeaver Administrator.
Furthermore, if you have multiple SAP PO installations in the landscape, then you can decide to use one of the SAP PO installations as a central Service Registry. When using a central Service Registry, all other systems will need to be configured to publish their web services to it. A central Service Registry is a better option than having a number of local Service Registries attached to each SAP PO installation. The central Service Registry approach promotes consolidation and a common web service publishing and discovery point.
Because the Service Registry isn't activated by default, whether you want to activate it to be used as a local Service Registry or you prefer to point it to a central Service Registry, follow these steps:


                Log in to SAP NetWeaver Administrator on the local SAP PO system.
            

                Navigate to the tabs SOA • Application and Scenario Communication.
            

                Click on the Single Service Administration link.
            

                From there, choose the Consumer Proxies tab, and search for the keyword "ServicesRegistrySi".
            

                Select the ServicesRegistrySi entry from the search results table. After the selecting this entry; a screen is populated at the bottom.
            

                From this bottom screen, choose the Configuration tab.
            

                Select the ServicesRegistrySiPort entry under the Configurations tab (see Figure 18.43). A new screen section appears at the bottom with details of the ServicesRegistrySiPort entry.
                
Figure 18.43    Services Registry Configuration


                Set a value for the Web Service Endpoint URL field by clicking on the Edit button. The URL to be used should have the format http://<hostname>:<port>/ServicesRegistrySiService/ServicesRegistrySiPort.
                
Note
The <hostname> and <port> variables need to be replaced by the local or central machine details, depending on whether you intend to set up a local or central Service Registry.



                Select the Security tab, and change the authentication settings to HTTP Authentication and User ID/Password (Basic).
            

                Specify the username and password details, and click on the Save button.
            

You're ready to configure your SAP PO installation to point to the local or central Service Registry. When publishing a service, it will end up in the Service Registry. The steps required to publish a web service were explored in Chapter 5, Section 5.12.
SAP is currently introducing a more advanced tool that can be used as an alternative to the Service Registry, called SAP API Management. Refer to the appendix for a sneak peek of its capabilities.









18.5    Enhanced Change and Transport System
When you finish your development activities, it's time to transport your work to the next environment of your landscape, based on your transport path. A typical transport path through the system landscape might look like the one presented in Figure 18.44.

Figure 18.44    Typical Transport Path for SAP PO
Based on this transport path, development objects created in development will typically need to be migrated or transported to the next system in the path (i.e., the test environment).
In the case of an SAP PO system, the following types of developments objects will need to be transported through the landscape:


                SLD objects
            

                Enterprise Service Repository objects
            

                Integration Directory objects (including iFlows)
            

                SAP BRM objects
            

                SAP BPM objects
            

                Java proxy objects
            

These objects are all Java-based. In Chapter 3, the subject of transport was briefly discussed. It was highlighted that you could choose between two main transport approaches:


                The manual approach, using the file system's export and import functionalities
            

                The automated approach, using SAP NetWeaver development infrastructure in combination with CTS+
            

The manual approach has many disadvantages and opens the door for human errors. It's therefore strongly recommended to use CTS+ for transporting SAP PO objects. In this section, we'll focus on the automated approach with CTS+. Our goal isn't to show you how to set up and configure a CTS+ system but instead to explore how CTS+ can be combined with SAP PO to facilitate transports. CTS+ is also provided in SAP Solution Manager with the support of the CTS plug-in. The CTS+ functionalities are available from SAP Solution Manager 7.1 SP 10 and higher (integrated in Change Request Management [ChaRM] and Quality Gate Management [QGM]). The advantage of using CTS+ in your landscape is that it enables the handling of transports of both ABAP- and Java-based objects in a uniform manner.
18.5.1    SAP PI-Related Transports
SAP PI-related objects (e.g., SLD, ES Repository, and Integration Directory objects) can be transported through the landscape with the help of CTS+. After CTS+ has been successfully installed, you need to configure a few things in the SAP PO/SAP PI system. Bear in mind that we'll only be focusing on the tasks to be performed in the SAP PO/SAP PI system. The tasks to be performed on the CTS+ ABAP server won't be explored.
The following two main tasks will need to be performed on the SAP PO system:


                    Create a destination to the CTS+ server.
                

                    Configure CTS parameters.
                

Let's explore how to accomplish each of these tasks.
Create a Destination to the CTS+ Server
To create a new destination from SAP PO to the CTS+ ABAP-based system, follow these steps:


                        From SAP NetWeaver Administrator, navigate to the Configuration tab.
                    

                        Select the Infrastructure subtab. From there, click on the Destination link.
                    

                        On the destination screen, click on the Create button.
                    

                        On the next screen, specify the mandatory general data detailed in Table 18.2. Click on Next.
                    

                        On the next screen, fill in the connection and transport security settings to connect to the CTS+ server, and then click on Next.
                    

                        Specify the login details for the CTS+ system, and then click on Next.
                    

                        On the last screen, click on the Finish button.
                    





                                Variable
                            

                                Value
                            





Hosting System


                                The local Java system (SAP PO). Can be selected from the Extended Value selector.
                            



Destination Name


sap.com/com.sap.tc.di.CTSserver




Destination Type


RFC




Table 18.2    Data Values for the Creation of a Destination to the CTS Server
You're now finished with the creation of your destination. You can test the destination via the Ping Destination button. An example of what a CTS server destination looks like is presented in Figure 18.45.

Figure 18.45    CTS Server Destination Settings
Configure CTS Parameters
You now need to perform the configuration of the CTS parameters in SAP PO by following these steps:


                        From SAP NetWeaver Administrator in SAP PO, navigate to Configuration and then to the Infrastructure tab.
                    

                        From there, click on the Java System Properties link.
                    

                        On the next screen, select the Services tab, and filter for the value XPI Service.
                    

                        From the filtered results, select the XPI Service: AII Config Service entry.
                    

                        On the bottom screen, you'll need to filter for the value *core.cts* (see Figure 18.46).
                    

                        Change the values of the following parameters from false to true via the Modify button:
                        

com.sap.aii.ibrep.core.cts.enableCITransport


com.sap.aii.ibrep.core.cts.enableTransportWizard




                        After changing the values, use the Set and Save buttons to ensure that your changes will reflect on the server.
                    


Figure 18.46    Configuring CTS Parameters in SAP NetWeaver Administrator
Figure 18.46 shows the values of the different CTS-related attributes set to the Boolean true. After the values of the parameters discussed previously have been changed, then the transport using CTS mode will be enabled for all SAP PI Java-only objects.
18.5.2    Transports for Non-SAP PI Java Objects
To enable the transport of objects related to SAP BRM, SAP BPM, and Java proxies, you also need to configure and integrate both CTS+ and SAP NetWeaver development infrastructure as a prerequisite. CM Services was introduced with SAP NetWeaver 7.0 EHP 1. CM Services are used to facilitate the transport of SAP NetWeaver development infrastructure-based developments.
CM Services can be used in two modes:


                    Integrated with CTS+
                

                    Standalone (using the import and export functionalities)
                

In this section, we focus on the first option. In Section 18.2, we already explored SAP NetWeaver development infrastructure and the two main ways of creating development configurations. When using the first option (CM Services integrated with CTS+), the development configuration needs to be created under the CTS System category instead of the Standalone category under the Filter field dropdown.
For a development configuration to be integrated with CTS+, you maintain transport settings in the Local Settings tab of the development configuration (Figure 18.47), as follows:


Export Mode In this section, you can select between two main ways to transport: Source Export and Deployable Export.
                

Export Destination In this section, enter the name of the CTS server destination that was created in Section 18.5.1. The value should always be "sap.com/com.sap.tc.di.CTSserver", which tells CM Services to export the sources to the CTS+ system.
                


Figure 18.47    Transport Settings Options in CM Services
We need to provide more explanation on the two main export modes (source and deployable) for you to choose which one of these options best suits your situation. The next sections will explain the differences between these two options.
Source Export
CM Services enables the transport of sources by means of activity transport or SCA transports. These two approaches are relatively new concepts in SAP NetWeaver development infrastructure and can be very useful because they facilitate the transport of small transport units. Every time a change is made to the source code, a new activity is created to bundle the modified sources. This approach makes it possible to only transport the delta (changes made on particular sources). It therefore provides the flexibility to choose the level of granularity in your transports. This approach is also known as transport of activities.
The activities released from SAP NetWeaver Developer Studio are checked in the DTR and built using the CBS. After a successful build, the changes are sent and attached to a CTS+ request. This is generally a quicker and faster option because only the affected sources and their dependents are rebuilt, requiring limited time compared to rebuilding the entire SC.
With the source export option, it's also possible to select both SCs and activities. In cases where a lot of DCs have dependencies on the DC to be changed, a combination setting of SCs and activities might be better suited and faster in terms of build time.
It's important to be aware that with this approach a development configuration is needed for every target system included in the transport route because you're transporting sources.
Deployable Export
With the deployment export option, the whole SC is exported. No smaller level of granularity is used. All new changes made to the source are updated in the DTR and built in the CBS. There are no transport requests automatically created in the CTS+. After the changes have been performed, further manual actions need to be taken to push them to CTS+. You need to perform an export using the Export Service of SAP NetWeaver development infrastructure (via the SAP NetWeaver development infrastructure Export UI; Section 18.2.1).
Here, a deployable SCA is attached to the transport request. One important aspect to be stressed is that the exported archive file includes the content of the entire SC.
With the deployable export (as opposed to the source export), a development configuration is only required on the development environment, that is, the source SAP PO system.

Note
This approach expects a certain level of expertise. Because you need to manually export the affected SC, all dependent archives will also need to be exported. Therefore, a clear understanding of the interdependencies between the different SCs is needed.










18.6    Exercise: Create an SWCV
Imagine you're starting a new SAP BPM project, and as the SAP PO expert, you're responsible for executing all necessary preparation steps to support parallel team development in SAP NetWeaver Developer Studio, ensuring version control for the SAP BPM components and integration with CTS+ for transports across the SAP PO landscape.
In this chapter, you read about the component model concept that is applicable for software projects built on top of the SAP PO platform. As a result, you know that for this new SAP BPM project you have to create a new SWCV in SAP PO, including its dependencies in the SLD. After that, you also need to add the new SWCV to an existing development configuration in SAP NetWeaver development infrastructure. When you're done with these tasks, your team members will be able to work simultaneously on the same SWCV and apply version control to their developed components.
18.6.1    Exercise Solution Approach
Instead of following the standard method of creating new SWCVs directly from the SLD, we'll show you how to use a wizard in SAP NetWeaver Administrator to create the new SWCV, including all required dependencies with other SCs.
The wizard will also take you through the process of registering the new SC in the SLD. After completing the wizard, you'll add your brand-new SC to an existing (standalone) development configuration previously created in SAP NetWeaver development infrastructure. Finally, you'll be able to import the development configuration from the Development Infrastructure perspective in SAP NetWeaver Developer Studio. This last step isn't part of this exercise, but you can read about how to accomplish it in Section 18.2.
We assume the following to be true for the purposes of this exercise:


                    You have access with the required SLD and SAP NetWeaver development infrastructure rights to an SAP PO installation (sandbox or development system).
                

                    SAP NetWeaver Developer Studio is installed and configured locally on your development PC.
                

                    There is an existing standalone development configuration available in your SAP NetWeaver development infrastructure environment.
                

18.6.2    Exercise Step-by-Step Solution
We'll execute the following steps in this exercise:


                    Create a new SC using the Configuration Wizard in SAP NetWeaver Administrator.
                

                    Add the SC to development infrastructure on the Development Configuration Management page.
                

Create a New Software Component


                        Launch your SAP NetWeaver Administrator environment (go to http://<hostname:>port>/nwa).
                    

                        Select the Configuration tab, and then click on Scenarios.
                    

                        Click on Configuration Wizard (see Figure 18.48).
                        
Figure 18.48    SAP NetWeaver Administrator: Configuration


                        Choose All Configuration Tasks from the Show dropdown menu, enter "define" in the Find search field, and press (Enter) (Figure 18.49).
                        
Figure 18.49    Configuration Wizard


                        Select the Define New Software Component Version task, and click on Start if this is the first time you've run the task or on the Re-execute button if the task has been previously executed (Figure 18.50).
                        
Figure 18.50    Configuration Wizard: Execute Configuration Task


                        Provide a valid SLD URL and a valid User Name and Password for the selected SLD, as shown in Figure 18.51. Click on Next.
                        
Figure 18.51    Configuration Wizard: SLD Configuration


                        Define the Name, Vendor, and Release version of the new SWCV, and click on Next (Figure 18.52).
                        
Figure 18.52    Configuration Wizard: Define Software Component Version


                        Select Business Process Management Application 7.50 from the Application Template dropdown menu, and click on Next (Figure 18.53).
                    


Figure 18.53    Configuration Wizard: Select Application Template
After the previous step, the configuration wizard will take care of registering the new SWCV in the SLD. Wait until you see the screens shown in Figure 18.54 and Figure 18.55. After that, you can click on the View Log link to examine all executed tasks by the wizard, as shown in Figure 18.56.

Figure 18.54    Configuration Wizard: Registering the New SWCV in the SLD

Figure 18.55    Configuration Wizard: Finish Screen

Figure 18.56    Configuration Wizard: View Log
Add Software Component
Launch your SAP NetWeaver Administrator environment (go to http://<hostname>: <port>/nwa), and then follow these steps:


                        Select the Configuration tab, and then click on the Infrastructure link.
                    

                        Click on Development Infrastructure (Figure 18.57).
                    

                        Select Stand-alone from the Filter dropdown menu (Figure 18.58).
                    

                        Choose one of the Stand-alone entries from the available development configurations. In Figure 18.59, we've selected SOFTCONF_D. Click on Add SC.
                        
Figure 18.57    Development Infrastructure

Figure 18.58    Development Infrastructure: Edit Development Configuration



Figure 18.59    Development Infrastructure: Add SC


                        Select SC_PO_BOOK_BPM as the SC from the list shown, and click on the Add button (Figure 18.60).
                        
Figure 18.60    Development Infrastructure: Add Software Components


                        Save the changes you made in the development configuration (Figure 18.61).
                    


Figure 18.61    Development Infrastructure: Save Development Configuration
In Figure 18.62, you can see the final result of the saved development configuration. You've completed the configuration necessary to start building new SAP BPM DCs within the SAP NetWeaver Developer Studio platform. Well done!

Figure 18.62    Development Infrastructure: Development Configuration









18.7    Summary
This chapter started by exploring the concepts of the component model. It explained how the component model can be used to increase reusability and better organize your DCs during development activities. The chapter also provided an overview of other useful components and applications that can be used in combination with SAP PO. These components are extensive and could use a chapter of their own. The different sections of this chapter only highlighted certain features and how they can further enhance the functionalities provided by SAP PO. Within that context, we also reviewed the SAP NetWeaver development infrastructure and explored its features and how it can support SAP PO Java-based development activities using the DTR, CBS, and CM Services. We also briefly touched on subjects such as SAP CAF and the Service Registry.
Finally, we explored some aspects of transporting SAP PO development objects, including the need to integrate the CM Services and CTS+.
The next chapter of this book is about SAP PO landscape considerations. The chapter will focus on planning the setup and architecture of your new SAP PO installation.








19    Landscape Setup ConsiderationsPerfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.                                                                                —Antoine de Saint ExupérySimilar to when you build a new house, there must be a strong foundation to have a sustainable and reliable system landscape. As with many other systems, the usage, availability, and performance requirements of your SAP Process Orchestration (SAP PO) system will change as time goes by. As the organization evolves, new businesses are acquired, and new systems are added; it's important to set up the SAP PO system in such a way that it can be easily adjusted to new business requirements and needs without causing too many negative effects for the business. Of course, it's not always possible to avoid such effects, but they should be taken into account when setting up the system for the first time.In this chapter, we'll explore different topics that can help you make sure that the foundation of your SAP PO system is well maintained and keeps running smoothly.
19.1    Java System Configuration
An SAP PO system can be installed from scratch, or an existing Java-only installation can be turned into an SAP PO installation by enabling additional usage types for Advanced Adapter Engine Extended (AEX), SAP Business Process Management (SAP BPM), and SAP Business Rules Management (SAP BRM).
If you have an SAP BPM system already running, then you can easily install the additional AEX usage type to obtain an SAP PO installation. When you have AEX running, you can do the same with the additional SAP BPM usage type.

Note
SAP PO always runs in an integrated solution, which means that deployment in more than one system isn't supported. All three components SAP PO are deployed and activated into one single Java stack.

In the following sections, we'll look at different aspects of an SAP PO system. These aspects include topics such as hardware sizing, the internal architecture of a Java-only system, the different Java central services, and various parameters to consider when tuning your Java-only system.
19.1.1    Java Sizing and Setup Considerations
The sizing and setup of the Java system architecture depends on several factors. To size the SAP PO system in a proper way, two different sizing methods need to be used. The combined results of these two methods will define the number of required SAP Application Performance Standards (SAPS).
The AEX part of the SAP PO instance can be sized via the SAP Quick Sizer tool, which can be found at http://service.sap.com/quicksizer. The SAP BPM part of the SAP PO instance can be sized using the document found at http://service.sap.com/~sapidb/011000358700000454652010E.
You can opt to implement the Java system as a full redundant and high availability setup. However, such a choice brings high additional costs. It's important to consider whether there is a good business justification for these costs and which components should be set up in a high availability or redundant manner.
The most important questions to ask when setting up your technical architecture are as follows:


                    How many messages will be processed per day?
                

                    How many messages will be processed during peak times?
                

                    What is the maximum allowable downtime?
                

                    Will there be message exchange with third parties or only between systems of the owning company?
                

                    What is the criticality of the interfaces and business processes running within the SAP PO landscape?
                

In an SAP landscape, there can be several single points of failure (SPOFs). The following SPOFs are of concern for an SAP PO instance:


                    SAP Web Dispatcher


                    Java Central Services instance


                    Database
                


Note
Only the SPOFs that directly concern the SAP instance are described in this section. There are of course more SPOFs that can be identified in your entire landscape and architecture. Network, storage, equipment, and even a complete datacenter are just a few other examples that fall outside of your SAP instance.


Figure 19.1    Single Points of Failure
In Figure 19.1, the SPOFs are depicted with a dashed line. To remediate these SPOFs, the following setup measures can be used:


                    High availability web dispatcher setup


                    Parallel web dispatcher setup


                    High availability with standalone enqueuer
                

                    Load balancing
                

                    Database high availability
                

These setups will be explored in the next sections.
High Availability Web Dispatcher Setup
Figure 19.2 shows two web dispatchers. The primary web dispatcher will take care of all the incoming requests. In the case of a system failure, the high availability software will bring up the secondary web dispatcher, which will continue processing the request load.

Figure 19.2    High Availability Web Dispatcher Setup
Parallel Web Dispatcher Setup
You can set up two web dispatchers in parallel and place a separate load balancer in front of them, as shown in Figure 19.3. Alternatively, you can make use of Domain Name Service (DNS) round-robin load balancing, which means that the DNS will send an equal number of incoming requests to the web dispatchers that run on both hosts so that the load is equally spread across both web dispatcher instances.

Figure 19.3    Parallel Web Dispatcher Setup
Incoming requests will be processed round-robin style based on one of the web dispatchers. If one of the web dispatchers crashes, then the remaining one takes over. This setup is also convenient when performing maintenance on productive instances. By simply putting one of the web dispatchers out of the load balancing, changes can be executed without interrupting the business. In this case, risk time should be taken into account instead of downtime. Risk time means that for this period of time, the redundancy is lost. The system is completely up and running for the business but without redundancy.
High Availability with Standalone Enqueue
As Figure 19.4 demonstrates, the high availability enqueue server consists of a standalone enqueue server and an enqueue replication server. The enqueue server is a critical component in the SAP landscape because it holds the lock table. Without the possibility to set locks, the system can't function. The replication of the enqueue runs on another host and contains a replica of the lock table.

Figure 19.4    High Availability with Standalone Enqueue
If the standalone enqueue server fails, then it will be started by the high availability software on the secondary node. The replicated lock table stored on the replication server will be transferred to the newly started enqueue process, and a new lock table will be created from it.
Load Balancing
Load balancing should also be given special attention. As its name suggests, load balancing ensures that the load is equally distributed across the different instances in the landscape. An SAP Java instance can only retrieve HTTP(S) requests that have been sent to its own hostname and port number combination. In a setup in which multiple application servers are being installed (very common in mid-size and large systems), a load balancer therefore should be installed in front of the Java instances. This approach has the following advantages:


                        All connections will go to one central entry point, which keeps the system configuration transparent.
                    

                        A load balancer introduces flexibility in terms of easily being able to scale the system up or down. Because all connections are via the same hostname and port combination, you can easily add or remove instances from the system landscape without impacting current interface scenarios or user access.
                    

                        The load balancer introduces the ability to offload data or requests to a specific server based on URL prefixes and other desired criteria. Therefore, if one instance in the landscape is configured to handle requests that match specific criteria, these requests will be redirected by the load balancer to the specified instance.
                    

                        The load balancer also provides the ability to temporarily remove an instance from the landscape for (urgent) maintenance without impacting the system availability.
                    

                        When making use of SSL certificates signed by a certificate authority, it's advantageous to have only one unique hostname (central load balancer) that retrieves all requests.
                    

When it comes to choosing a type of web dispatcher to use, you can choose between hardware and software load balancers. However, in most cases, it's sufficient to use the SAP Web Dispatcher.
As Figure 19.5 shows, the SAP Web Dispatcher can also be used as a reverse proxy to be placed in the demilitarized zone (DMZ) in business-to-business (B2B) scenarios. By placing a web dispatcher in the DMZ of your network, you can provide access from your SAP PO system to the outside world in a safe and secure way.

Figure 19.5    Web Dispatcher Placed in DMZ
Database High Availability
There are different ways to make the database highly available. A common method involves making use of a standby database or database clustering. Log shipping makes sure that all the changes made in the primary database will be replicated to the standby database. The log shipping process basically applies all database changes to the target standby database. If the primary database fails, then the standby database takes over. Figure 19.6 shows an example of a high availability database.

Note
SAP supports the use of several database platforms. Each database flavor has its own high availability options. Make sure you consult the available SAP and database vendor documentation in relation to the supported high availability options.


Figure 19.6    High Availability Database
19.1.2    Java System Architecture
Within an SAP Java instance, it's recommended to have at least two server processes configured. These server processes are most commonly known as nodes. If you have two or more server processes, then SAP provides a built-in redundancy within the Java instance. If a node crashes, then only the processes and active connections running on that particular server node will be terminated. The remaining server node will take over all new requests and activities. Usually, the crashed server node will be automatically restarted by the startup and control framework.
If you only have one server process configured, then all connected sessions and connections will be terminated, and the system won't be accessible until the node has been restarted. This is obviously an undesirable situation that results in a full system outage.
As Figure 19.7 shows, each server node has its own Java virtual memory. This memory allocation is dedicated for a particular server node and not shared across multiple server nodes.

Figure 19.7    Java System Architecture
When sizing the Java instance, make sure that the sum of the memory allocated for the server nodes plus the memory required for the operating system (and optionally also for other running applications or databases) fits with the physical memory of the server. Allocating swap space on the operating system level should be avoided at all costs!
19.1.3    Java Central Services
The Java Central Services are depicted in Figure 19.8, in which the Central Services Server (SCS) contains the message server and the enqueue server process of the Java instance. The message server process is used for load balancing and internal communication. The enqueue server process, on the other hand, takes care of the logical lock table, which is stored in memory. Both processes are vital for the functioning of the Java instance.

Figure 19.8    Position of the Java Central Services Instance
19.1.4    Java Parameter Tuning
Depending on the expected scenarios and the number of requests that will be running on the SAP PO system, the system will need to be tuned accordingly to cope with load. There are no golden rules for how to tune a system for that, but there are some parameters within the Java stack that need to be taken into account in the context of sizing and tuning. Some of these parameters will be explored in the next sections.
FCAServerThreadCount
For systems that need to process high volumes of synchronous Simple Object Access Protocol (SOAP) messages or that have a large number of concurrent users, this parameter should be increased. The default value for FCAServerThreadCount is 30, but in high-volume systems, it should be doubled. If this isn't enough, then the parameter should be further increased. However, it's wise to use small incremental steps each time.
The FCAServerThreadCount parameter is part of the HTTP provider service of the Java stack and can be changed via configtool. Bear in mind that when changing FCAServerThreadCount, the number of server threads will be affected, so make sure that the number of Java server threads is changed accordingly.
Internet Communication Manager Timeout Values
The first entry point for client requests to the Java instance is the Internet Communication Manager (ICM). The ICM forwards the request to an available Java server node, where the processing takes place. If the request processing takes longer than defined by the timeout parameter, then the request is automatically terminated. It's therefore important to configure a reasonable timeout value for the ICM parameters.
As its name suggests, the timeout value defines how long it takes before a session times out and the connection is reset. The proctimeout parameter defines the allowed processing time for an HTTP(S) request. This value should not be set very high because it's preferable that the processing of requests takes place in a reasonable amount of time.
Furthermore, the session timeout should not be set too high because sessions are kept open for the duration of the timeout value and therefore hold resources for this same duration. These resources are no longer usable for other processes. If you require a high timeout value, then it might be better to increase the number of sessions or threads on the ICM.
The ICM parameters can be set in the following way:
icm/server_port_0 = PROT=HTTPS, PORT=443, TIMEOUT=60, PROCTIMEOUT=600
The parameters are as follows:


icm/server_port_# Defines the number of the parameter. You can configure multiple ICM server ports, each for its own purpose.
                    

PROT The protocol that is being used for this particular port.
                    

PORT The port number that the defined protocol listens to.
                    

TIMEOUT The timeout value for the connections.
                    

PROCTIMEOUT The timeout value for the actual processing of a request.
                    

The ICM parameters need to be set in the instance profile of the Java instance, which can be found in /sapmnt/<SID>/profile.
After changing the values of these parameters, a restart of the Java system is required to activate them.
Garbage Collection Configuration
In most cases, the default garbage collection (preconfigured with the SAP Java installation) is sufficient to match the workload of the Java server tasks. In special cases, the garbage collection algorithm can be adjusted, but only after consulting SAP.
Database Connection Pool Configuration
A Java server process makes use of threads to process requests. For each request (user request or a system request) that enters the system, the server creates a thread. If data needs to be fetched from or written to the database, then a database connection is established. This database connection is taken from the connection pool. When the activity is finished, the database connection is freed and cleared after the expiration time, and the thread becomes available again for new processes.
You need to make sure that the database connection pool is large enough to cope with the demand. If you need to increase the number of threads while tuning your system, then remember to also accordingly adjust the database connection pool.
The database connection pool can be modified by opening the Configtool and navigating to Cluster Data • Template • Instance • Services • DBpool (see Figure 19.9).

Figure 19.9    Database Connection Pool Settings









19.2    Handling Certificates
Within the AEX, several protocols can make use of certificates, such as HTTPS and SFTP. Certificates are used for encryption, identification, and validation purposes. The next sections will touch on two certificate concepts.
19.2.1    Certificate Key Storage
Within the Java stack, the certificates and keys are stored in key storage. SAP NetWeaver Administrator is used to manage key storage within the Java stack.
Java key storage contains a list of standard views to cater to different operations on certificates. Custom views can also be created if required. For example, customer views can be created for a certain interface or customer, to separate certificates for different scenarios.
Key storage can be accessed by going to http://<hostname>:<port>/nwa and choosing Configuration • Certificates and Keys.
19.2.2    Encryption of Message Content on Database Level
In addition to the option to use encryption while transferring messages, you can also store encrypted payloads and attachments in the database. With this approach, users that have direct access to the database level can't read the message content and payloads.
Encryption on the database level can be set up for interfaces that contain confidential data and will ensure that the entire message is encrypted. Note that it's not possible to only encrypt parts of a message; the entire message must be encrypted. It's important to be aware that encryption of messages generates overhead. The encryption process is CPU bounded. Every time a message is stored to or read from the database, an encryption or decryption of the message takes place.
In addition, note that there are some restrictions and disadvantages when encrypting messages on the database level. Therefore, remember to check the available documentation.









19.3    Housekeeping
The standard housekeeping activities can be executed by using the background processing within the AEX. Background jobs can be accessed via SAP NetWeaver Administrator (navigate to SOA • Monitoring • Background Job Processing Monitor).
The next section will explore each of the background jobs.
19.3.1    Archiving
Message archiving provides the ability to archive messages that have been processed successfully or manually edited to an archiving space.
There are two archive sessions required to archive a message:


                    The first session writes the message to the archive storage.
                

                    The second session removes the archived message from the persistence layer, which is the database of the AEX.
                

19.3.2    Deletion
Within SAP PO, only messages that have fulfilled the following criteria will automatically be deleted from the database by the deletion job:


                    Messages that have successfully been processed
                

                    Messages that have reached their retention period
                

                    Messages that aren't candidates for archiving
                

19.3.3    Restarting
The restarting job can be scheduled to automatically restart messages that are in an error status. This is applicable for all messages for which the number of defined restart attempts has been exceeded. The restart attempts attribute specifies how many times a failing message can be retried before abandoning it. For restarting messages, the following parameters can be used:


MAX-RESTART This parameter defines the maximum number of restart attempts for messages in status error or system error.
                

RESTART-BLACKLISTED This parameter is used for jobs that need to reprocess messages that have been blacklisted and have a nondeliverable (NDLV) state status.
                


Blacklisting
Blacklisting is a mechanism that can be used to prevent situations in which individual messages can cause the server to overload and even fail.
For example, a message with a big payload (in terms of size) can cause the server to crash. Blacklisting is the process of identifying and isolating messages that can potentially harm the system or messages that were being processed when there was a server failure.
If a Java server node fails, and a message can't be processed successfully after two attempts, then the messages will be assigned an NDLV status. When messages are in an NDLV state, an administrator must decide whether to allow the message to be reprocessed or to put the message in a FAIL state.

19.3.4    Recovery
This type of job is used to recover jobs that are lost as a result of a database failure. By default, the recovery job runs once per day, but additional recovery jobs can be scheduled if required.









19.4    Monitoring
Because SAP PO is mostly used for business-critical processes, it's important to monitor and keep track of what is happening to the SAP PO system. Monitoring of your SAP PO system can be achieved in several ways. The different possibilities to monitor both SAP BPM and AEX were outlined in Chapter 15.
As you might recall, it's possible to monitor the message processing between the AEX and SAP BPM by using the following monitors:


Message Monitor Provides an overview of all interfaces and shows (per integration scenario) the number of messages and their statuses. This is found under the Adapter Engine tab.
            

Communication Channel Monitor Provides a high-level overview of the status of all communication channels within the system.
            

Java Proxy Runtime Monitor Provides a high-level overview of the Java proxy runtime.
            

These monitors can be accessed via http://<hostname>:<port>/pimon.
To monitor and manage SAP BPM processes, you have to access SAP NetWeaver Administrator via http://<hostname>:<port>/nwa and then choose Operations • Processes and Tasks. From there, you can perform the following tasks:


Manage processes This application is a central area for monitoring and managing SAP BPM processes. Administrators can view the process details, process instance flow, process definition flow, history, process context, and so on.
            

Manage tasks This application is a central area to monitor and manage process tasks. Administrators can view the task details, deadline details, history, task owners, and so on.
            

The monitoring options summarized previously were explored in more detail in Chapter 15. The remaining sections will explore additional monitoring possibilities that we haven't yet discussed.
19.4.1    Runtime Workbench
The Runtime Workbench (RWB) is a central entry point to access several functions and overviews in the SAP PO system. It can be very useful for quick insight into the high-level status of certain components (see Figure 19.10).

Figure 19.10    Status of Components within the Runtime Workbench
It can also be used to view the status of the System Landscape Directory (SLD) registration or to execute SLD registration for components when required. Because the SLD registration is crucial for the SAP PO instance to function correctly, this is one of the first places to check in case of issues (see Figure 19.11).

Figure 19.11    Runtime Workbench SLD Registration
Because each component of the SAP PO system needs to be registered in the SLD, all items should have a green status. This screen can also be used when something in the host or port configuration has been changed, and the registration needs to be executed again.
You can access the RWB via http://<hostname>:<port>/rwb.
19.4.2    Wily Enterprise Manager
Wily Enterprise Manager (Wiley EM) is delivered as a standard component within the SAP support contract and is free of charge. Within Wily EM, there are many standard dashboards that can help you analyze the current state of the Java stack. It also caters for historical analysis by providing historical data up to 30 days in the past.
It's equipped with a console view that shows the high-level status of the system. For a deep-dive analysis, it provides a tool known as the Investigator. Wily EM also provides detailed insight for every node of the Java instance. The next sections will provide more insight into some of its features.
Performance Analysis Using Wily Enterprise Manager
Wily EM can be used to narrow down performance and stability issues within the Java stack, and it has some standard dashboards to monitor the most important key performance indicators (KPIs) of your Java stack. It also provides insight into the queues of the AEX and communication channels.
Besides being used for troubleshooting issues, Wily EM can (and should) be used to perform regular health checks on the system.
Monitor System and Application Thread Utilization
All activities within the Java stack are performed via threads. When the SAP PO system starts and thereafter on request, an initial and minimum thread count is allocated. Additional threads can be progressively allocated until the maximum usage has been reached. If the maximum number of threads becomes allocated and in use, then no additional processing can take place, and the system will basically come to a standstill.
In many cases, it's sufficient to stick to the default number of system and application threads, but it's important to regularly perform health checks on the system to check if the number of allocated threads remains stable or sufficient.
If you find that the thread utilization on the system is high, then further analysis should be performed to identify the root cause. Several reasons can justify a high number of threads being used by the system. Applications that weren't properly closed, hanging sessions, a bug in the software, and so on can be among the possible reasons.
A system running out of its capacity can also justify such an issue. In that case, one of the possibilities to resolve the issue will be to configure an additional server node or install an additional application server.
Monitor Java Heap Utilization
All processing within the Java server node takes place in the JVM. The heap memory forms an important part of the JVM. When a process is started, it claims memory in the heap space to process requests. The garbage collection process is responsible for checking the heap memory at regular time intervals to verify whether the allocated memory segments (in the heap space) are still allocated to an active process. If that isn't the case, then they will be moved to another space segment within the heap or be cleared.
19.4.3    SAP Management Console
The SAP Management Console (SAP MC) (see Figure 19.12) provides a common framework for centralized system management. SAP MC can be accessed via the following URL, which will launch a Java applet from the browser: http://<hostname>:5<instance_no>13.
SAP MC is responsible for the following tasks:


                    Display the current system status.
                

                    Monitor and control the SAP system (stop and start).
                

                    Display log and trace files, profiles, parameters, and system environment.
                

                    Display ICM statistics.
                

                    Display and control Java instance processes.
                

                    Monitor system alerts.
                

                    List access points to the SAP system.
                

                    Display information about threads, sessions, and caches.
                

                    Display Java Virtual Machine garbage collection and heap information.
                

                    Save the current system status information, which can be provided to SAP if support is required.
                


Figure 19.12    SAP MC
19.4.4    SAP Solution Manager Monitoring
Within SAP Solution Manager 7.1, there is specific monitoring functionality implemented for the monitoring of the SAP PO usage type. The main advantage of using the SAP Solution Manager monitoring tool is its ability to automate monitoring. It requires configuring thresholds on different system parameters in SAP Solution Manager. If those thresholds are reached, then an alert is triggered and sent to the administrator, so there's no need for the system to be continuously or actively monitored by a human. The administrator's interaction is needed when an alert event is received.
If you receive too many alert events on a particular interface or the technical system, then this can be an indication that the monitoring thresholds have been set incorrectly or that the SAP PO system needs tuning. The process of monitoring is a cyclic process, which means that it's never finished. The monitoring configuration needs constant attention and needs to be adjusted according to the system behavior and business requirements.
Technical Monitoring provides a set of metrics on the technical components of your system landscape. This feature provides an overview of the overall system status. The most important items that can be monitored from this overview include the following:


                    Status of the database
                

                    Status of the operating system (file system utilization, memory, page file, etc.)
                

                    Network throughput
                

                    Status of the Java engine
                

                    Number of used application and system threads
                

                    Heap size allocation and number of garbage collections
                

The preceding metrics only represent a subset of all available metrics. These metrics are delivered via standard templates and can easily be adjusted to your own needs. You can add or remove metrics or even define your own metrics and thresholds.
The components that are available within the SAP PO monitoring part of SAP Solution Manager are as follows:


Component Monitoring Component Monitoring shows the availability and performance of some components of your SAP PO landscape, such as the Integration Directory, Integration Repository, SLD availability, and so on.
                

Communication Channel Monitoring Communication Channel Monitoring lets you monitor one or multiple communication channels. You can define which communication channels are considered critical for your business needs and define specific alert rules on them. If one of these communication channels encounters problems, then you can have the system trigger alerts via a ticket, email, or even a text message on your phone.
                

Interface Channel Monitoring Interface Channel Monitoring monitors the interfaces and performance of connections between business-critical systems. This monitoring is executed in real time.
                    The following types of interfaces are supported:
                    

                            Remote Function Calls (RFCs)
                        

                            Web services
                        

                            SAP PI
                        

                            SAP Gateway services
                        

                            Flat files
                        

                            iDocs
                        

                            Queued RFC (qRFC)
                        

                            Transactional RFC (tRFC)
                        

                            Background RFC (bgRFC)
                        



19.4.5    Tracing
Trace information is generally used by developers or system administrators for debugging purposes to diagnose common problems with software. This section will explore some aspects of collecting traces on SAP PO.
Client-Side HTTP Tracing
HTTP and SOAP communication channels can easily be traced without the need for an external tracing tool. It's possible to enable tracing per receiver channel by setting the XISOAPAdapterBean parameter in the Module Configuration screen in the communication channel, as shown in Figure 19.13.

Figure 19.13    Module Configuration for HTTP Tracing
The following parameter values can be used for XISOAPAdapterBean:


headers Implies that only HTTP headers are traced. This is relevant for both HTTP request and response.
                    

plain Implies that the whole HTTP request-response communication is traced (headers and body) in plain text.
                    

hex Implies that a hex dump is traced for the whole HTTP request-response communication in the same format as the ICM implementation.
                    

XPI Inspector
XPI Inspector is a diagnostics tool developed by SAP that can be accessed via a web interface. The tool can collect different types of information from the system, including configuration and traces, and it can perform configuration checks. To be more precise, the following types of information can be collected using XPI Inspector:


                        Debug traces from messaging system
                    

                        Debug traces from the SAP XI module processor
                    

                        HTTP traces
                    

                        Open SQL traces
                    

                        Java Connector (JCo) traces
                    

                        Information about the overall system state
                    

Consult SAP help to find the link to download the XPI Inspector software. After downloading the software, it can be deployed onto the Java stack via SAP Software Deployment Manager (SDM), SAP NetWeaver Developer Studio, Telnet, or Software Update Manager (SUM), depending on the release of your SAP PO system. Once deployed, the XPI Inspector can be accessed via http://<hostname>:<port>/xpi_inspector.
19.4.6    JVMMON
JVMMON is a monitoring tool that's delivered as part of the SAP JVM. The tool provides a wide range of monitoring tasks. The JVMMON application can be found in the JVM directory and is delivered with a command-line tool and a separate tool with a graphical user interface.
The JVMMON application can be attached to a running SAP JVM and provides comprehensive monitoring information or controls various aspects of the JVM configuration. After selecting a running JVM, the following information about its current state is presented:


                    Virtual machine-related information, such as version, platform, build information, and so on
                

                    Stack traces, optionally enriched with additional descriptive information
                

                    Class statistics in detail or short summary
                

                    Information about the VM and the cluster memory consumption
                

                    Heap dump, optionally enriched with additional information
                

                    Information about the shared libraries loaded by the VM
                

                    Garbage collection history information
                

Furthermore, the following actions can be performed on the JVM:


                    Starting and stopping debugging on the fly
                

                    Setting trace flags to enable or disable specific trace output
                

                    Forcing a full garbage collection or a maximum compaction garbage collection
                

When the system is hanging or very poorly performing, and past thread dumps are no longer available in the system, you might need to generate dumps of the current situation. These thread dumps are often required by SAP support to help them troubleshoot customer issues.
When a very high amount of memory is allocated within a server node of the Java stack, the server node might generate a heap dump: the complete contents of the memory will be written to a dump file on the operating system level. In such a case, the server process will generally be restarted automatically by the startup and control framework. Heap dumps can also be performed manually using the JVMMON tool.
To analyze the contents of a heap dump, the memory analyzer tool can be used. The Java heap analyzer can be found within SAP NetWeaver Developer Studio as an Eclipse plugin.









19.5    Summary
This chapter strongly advocates carefully planning the architecture for your future SAP PO landscape. By making the right choices at the start of the implementation, you'll ensure that SAP PO rests on a solid foundation that will provide advantages for the rest of the lifecycle of the system landscape and will facilitate the ongoing maintaining tasks.
Obviously it's not always possible to know all future business needs and requirements of your SAP PO landscape in advance. However, you can set up the system landscape in such a way that it's scalable for future needs without causing too much negative impact to the business.
After reading this chapter, you should now be better equipped and informed about the critical areas to keep an eye on to ensure that your system keeps performing. If you run into any issues, you should also know where to focus when collecting critical information for troubleshooting.








Orchestration OutlookAs we mentioned way back in Chapter 1, SAP Process Orchestration (SAP PO) has a lot of history and has come a long way. SAP is continuously improving the SAP PO product and bringing new and needed features and functionalities. The purpose of this appendix is to update you about other SAP products that are part of the family of on-premise and cloud integration products, or products that can act as a supplement to the functionality provided by SAP PO. Within that context, we'll explore the SAP API Management platform, SAP Cloud Platform Integration, and Integration Advisor in the next sections.
SAP API Management
As a result of SAP's partnership with Apigee, SAP is introducing its SAP API Management solution. SAP API Management will make it easier for developers to expose selected functionalities of your organization as application programming interfaces (APIs) to be consumed by a variety of devices or platforms. These APIs are provisioned in a scalable, governed, and secure manner.
SAP API Management will facilitate exposure of SAP and non-SAP data in a uniform way. It will also provide analytics, management, and monitoring of API usage. SAP API Management 1.0 is planned to be released in two different forms: on-premise and cloud-based versions.
Existing services provided by SAP Gateway, SAP PO, and the Enterprise Services Repository (ES Repository) can be leveraged and exposed as an API. The exposed APIs can be RESTful, OData, and Simple Object Access Protocol (SOAP)-based services.
Going forward, SAP API Management will be even more useful on the cloud. SAP plans to tightly integrate Apigee's API functionality into the SAP Cloud Platform Integration platform. This functionality will also be made available on premise with the help of SAP PO.
Figure A.1 shows the layers involved in exposing an API from a high-level perspective. It also positions the SAP API Management platform in your environment.

Figure A.1    SAP API Management Positioning









SAP Cloud Platform Integration
Since the introduction of cloud computing technology, there has been a shift in the level of investments by organizations in software licenses. Organizations are rapidly moving from the concept of software ownership to software rental. As a consequence, SAP is also currently growing its cloud portfolio with products for human resources (with SAP SuccessFactors), marketing, sales, service, procurement, supply chain management, and finance. We're convinced that this portfolio will continue to grow.
You might now be wondering what SAP's proposition is to integrate this armada of cloud applications. Part of the answer lies in SAP's release and offering of SAP Cloud Platform Integration as its cloud-based integration platform-as-a-service (iPaaS) for enterprise and business-to-business (B2B) integration solutions.
SAP Cloud Platform Integration isn't SAP Process Integration (SAP PI) on the cloud, but it's a platform that supports full integration capabilities and combines certain functionalities of SAP PO and data services. It involves the creation of integration flows (iFlows) from an Eclipse-based development environment for end-to-end messaging and connectivity between on-premise and cloud solutions. It's also possible to perform development activities from the web-based tool known as WebUI as an alternative to Eclipse.
This is an on-demand solution with prepackaged integration content and the possibility of enhancing this delivered content, and it can be integrated with other solutions. The cloud infrastructure is managed by SAP, with fixed pricing for services consumed by each customer.
Note that it's not obligatory to run or use a hybrid scenario (on premise/on demand) in combination with SAP PO. You can decide to choose between SAP PO and SAP Cloud Platform Integration and only use one of them.
As Figure A.2 depicts, a typical organization that has adopted the cloud will have two different zones:


On premise This zone includes the applications residing within the organization's network boundaries. SAP PO can be used as the integration tool of choice for all exchange of messages happening within this zone. Furthermore, traffic through and between the cloud and on-premise applications could transit to your SAP PO system. Depending on circumstances and the scenario at hand, SAP Gateway can also be used.
            


Figure A.2    On-Premise to Cloud Integration with SAP Cloud Platform Integration and SAP PO


Cloud This layer comprises your cloud ecosystem. This extension of your landscape, which resides outside the boundary of your organization, can be integrated using SAP Cloud Platform Integration. Then, you have a situation in which SAP Cloud Platform Integration on the cloud communicates with SAP PO on the on-premise side. SAP Cloud Platform Integration can also be used to enable cloud-to-cloud integration. In this situation, different SAP Cloud applications need to communicate with each other, or an SAP Cloud application needs to exchange messages with a third-party (non-SAP) cloud application.
            

The next sections of this book aren't intended to tell all there is about SAP Cloud Platform Integration but to highlight some of the currently provided features of the SAP Cloud Platform Integration. For a full overview of SAP Cloud Platform Integration, refer to the book Getting Started with SAP HANA Cloud Integration by Bilay, Gutsche, Stiehl (SAP PRESS, 2016, www.sap-press.com/3979).
Features and Facts Overview of SAP Cloud Platform Integration
Security and performance issues are key reasons that people are skeptical of putting information on the cloud. SAP Cloud Platform Integration handles these concerns by supporting signing, encryption, and decryption of data that passes through the modeled flows from an end-to-end perspective.
SAP Cloud Platform Integration can be licensed in different forms and editions. We can distinguish between two main editions: the application and the standalone integration platform. This choice of package creates the flexibility for customers to choose the model that best fits their needs. The two options are as follows:


Application edition This edition can be used by customers using other SAP cloud applications, such as SAP Cloud for Customer, SAP SuccessFactors, and SAP Financial Services Network (SAP FSN). This edition comes equipped with prepackaged content and flows that can directly be used without deep technical knowledge. This content can be found from the web-based application known as the Integration Content Catalog, which can be accessed via https://cloudintegration.hana.ondemand.com.


Standalone integration platform edition This is a version of SAP Cloud Platform Integration that enables you to integrate any application in your landscape (including SAP and third party). Within this context, we can distinguish two different levels: the SAP Cloud Platform Integration Standard and Professional packages. The standard edition is the entry-level package. It has the full integration capabilities but is limited in terms of the total amount of bandwidth that can be used per month. The professional package, on the other hand, caters for more bandwidth. The professional package has many more levels that customers can select from depending on their needs. It's also important to mention the SAP Data Services Agent, which enables SAP's customers to download the integration component.
                

SAP Cloud Platform Integration keeps adding new features on a regular basis, so check the SAP Cloud Platform Integration website to get more up-to-date details.
As it currently stands, the following features and facts apply to SAP Cloud Platform Integration:


                    It has a multitenant architecture (separated firewall rules, separated system configuration, security, etc.).
                

                    Availability of UI access to modify iFlows and prepackaged iFlows can also be downloaded to Eclipse and modified.
                

                    All the functions of graphical mapping (in SAP PO) are supported; Extensible Stylesheet Language Transformations (XSLT) mapping can also be used.
                

                    Existing SAP PO content is supported and can be imported into SAP Cloud Platform Integration (service interface, operation mapping, and message mapping objects).
                

                    Connectivity options include IDoc, SOAP, and Secure FTP (SFTP) between backend systems. Additional connectivity options will become available in future releases.
                

                    Certificates can also be browsed and supported on Eclipse-based environments.
                

                    You can reuse user-defined functions (UDFs) defined in SAP PO.
                

                    Two environments will be provided to SAP Cloud Platform Integration customers: development and production.
                

                    SAP Cloud Platform Integration currently runs on top of Sybase as a database and not on SAP HANA's in-memory database, but the future plan is to make it powered by SAP HANA.
                

                    Software is upgraded every month on the SAP side for maintenance of the cloud infrastructure.
                

                    The created iFlow can be deployed on the IFLMAP tenant node.
                

                    Message monitoring functionalities are available on the server on which they are deployed, and the artifacts also are visible.
                

                    SAP Cloud Platform Integration will run as an alternative to SAP PI, and small companies that don't have the capacity can use it inexpensively.
                

                    Partners and customers can create SAP Cloud Platform Integration solutions (reusable connectors and other integration logic) of their own and deploy them into the cloud. Additional Eclipse Software Development Kits (SDKs) will be provided for this purpose. These custom solutions can then be certified by SAP (this is planned for future releases in the roadmap).
                

                    SAP Cloud Platform Integration provides a new opportunity for small, medium-sized, and large corporations to integrate their enterprise applications and integrate with partners at reduced costs and without investing heavily on software licenses.
                

Development Guide: Getting Started
This section describes the necessary steps for setting up the SAP Cloud Platform Integration environment.
SAP Cloud Platform Integration Workbench and Tools
This section describes the tools required to set up your SAP Cloud Platform Integration environment. The first tool necessary to have in place is Eclipse Kepler (a specific version of Eclipse). SAP Cloud Platform Integration uses Eclipse to contain the integrated development environment (IDE) and necessary perspectives that support SAP Cloud Platform Integration developments.
SAP Cloud Platform Integration Plug-Ins
You'll need to install the appropriate SAP Cloud Platform Integration plugins into Eclipse to have the necessary artifacts for creating, designing, and monitoring iFlows. Follow these steps to add the plugins:


                        From the main menu, choose Help • Install New Software.
                    

                        On the Available Software page of the Install wizard, add the update site URL https://tools.hana.ondemand.com/kepler.


                        Select from the among following three options:
                        

Show only the latest version of available software


Groups items by category


Contact all update sites during install to find required software




                        Select the SAP Cloud Platform Integration Tools category.
                    

                        Click on Next.
                    

                        Check the features selected for installation, and click on Next.
                    

                        Accept the terms of the licensing agreement, and click on Finish.
                    

                        Restart the Eclipse IDE.
                    

The Eclipse plug-in contains the following features:


Designer for SAP Cloud Platform Integration This feature contains plugins to develop and configure iFlows.
                    

Operations for SAP Cloud Platform Integration This feature contains plugins to perform administrative tasks related to SAP Cloud Platform Integration runtime clusters and to monitor iFlows.
                    

Certificates and security artifacts Depending on the type of scenario in mind, designing and deploying iFlows on an SAP Cloud Platform Integration tenant requires you to take security aspects into consideration. Different types of security artifacts might need to be included. This could include Secure Sockets Layer (SSL; certificate authority, private key, and public key) and Secure Shell (SSH; private and public keys). Note that many CAs are currently supported (including SAP Passport CA), and more will be added as time goes by.
                        Because SAP Cloud Platform Integration currently supports the connectivity options (SOAP, IDoc, SAP Success Factors, and SFTP), the security artifacts previously listed can be used in most of them.
                    

Tenant account A tenant account is needed to deploy your SAP Cloud Platform Integration developments. The details of the tenant include the tenant ID and the operations server. These details are needed to configure your Eclipse environment. For more information about how to apply for a tenant account, contact your SAP representative. The tenant will facilitate the execution of different integration operations, including the deployment of iFlows and the runtime monitoring of running flows.
                    

Configuring Eclipse
When configuring Eclipse for your SAP Cloud Platform Integration environment, you'll need to configure two different preference aspects in Eclipse: the operations server and the ES Repository. This section explains how to do so.
The operations server is required for deploying your SAP Cloud Platform Integration iFlows to the server. To set up the operations server, follow these steps:


                        From your Eclipse IDE, navigate to Windows • Perspectives • SAP Cloud Platform Integration.
                    

                        From there, enter the necessary details to connect to the operations server, based on the tenant details (see Figure A.3).
                    

                        You can test the connection by using the Test Connection button. When successful, select the OK button.
                    


Figure A.3    Setting Up the Operations Server in Eclipse
Repository Connection will normally point to the ES Repository. This configuration will enable the importing of SAP PI/SAP PO objects and artifacts, such as message mappings, operation mappings, and Web Service Description Language (WSDL) files. You'll need to input the required details under the Repository Connection section (see Figure A.4).

Figure A.4    Configuring Details of the Repository Connection to Point to SAP PO's ES Repository
Creating an Integration Flow
For simplicity's sake, we'll illustrate the usage of SAP Cloud Platform Integration by giving a high-level explanation of how to implement a simple SOAP-to-SOAP scenario. Follow these steps:


                            Switch to the Integration Designer perspective by going to Window • Open Perspective. Choose Other and then Integration Designer.
                        

                            To create an iFlow, first create an integration project, click on the Project Explorer palette, and select New • Other.
                        

                            Select Integration Project from the SAP Cloud Platform Integration folder (see Figure A.5).
                        

                            Click on Next, and name your iFlow.
                        

                            Proceed with the wizard, and provide some details about the iFlow to be created. Besides giving it a name, you'll also need to specify a pattern to be used to create it. Each of the provided pattern templates contains an explanation of what it can be used for. For the sake of simplicity, choose Point-to-Point Channel (see Figure A.6).
                            
Figure A.5    Creation of an iFlow

Figure A.6    Specifying Details of the iFlow and Its Pattern Template

Note
You can define your own set of iFlow patterns called user-defined templates.



                            Click on the Finish button to complete the initial creation steps.
                        

The resulting iFlow generated from the Point-to-Point Channel template looks like the image shown in Figure A.7.

Figure A.7    iFlow Based on the Point-to-Point Channel Pattern Template
Extend this empty iFlow and further configure it by following these steps:


                            Configure the sender system, receiver system (name of the sender and receiver system; this is optional), and sender authorization (this is the public key pair).
                        

                            Import the WSDL file from SAP PI repository or local file system.
                        

                            Create a parameters file that contains attributes and metadata that can be referenced from the communication channels.
                        

                            Create a mapping between sender and receiver systems, or import existing mapping objects from the SAP PI repository.
                        

                            Create sender and receiver communication channels.
                        

These steps will be explored in the next sections.
Configure Sender and Receiver Systems
To configure the sender and receiver systems, follow these steps:


                            From the iFlow just presented in Figure A.7, click on the sender system (on the left side of the diagram), check the property area, and enter an appropriate name for your sender system without whitespaces.
                        

                            Under Sender Authorization, click on the Browse option to import your public SSL key (see Figure A.8). Adding the SSL key is required in the case of certificate-based authentication.
                            
Figure A.8    Configure Sender System and Maintain Authorization


                            Repeat the previous steps to configure the receiver system name. Note that there is no need to browse for the public key on the receiver side.
                        

Import WSDL Files from SAP PI or Your Local File System
For the sake of simplicity, we'll assume that you'll reuse existing service interfaces from SAP PO for this scenario. You'll then need to import them from your ES Repository. To import the service interfaces, follow these steps:


                            Right-click on the name of the integration project in the explorer, choose the Import PI Content option, and choose the type of artifact to be imported. You'll be asked to choose from among Message Mapping, Operation Mapping, and Interface. For our example, choose the Interface option. It will load the list of service interfaces for you to choose from. After selecting the desired service interface, click on the Finish button.
                        

                            Import the WSDL/service interface for the receiver system as well. These two service interfaces (for the sender and receiver) will be used during mapping. In addition, note that the WSDL file could also be imported from a local file system instead of the ES Repository. It's mandatory to have SAP PI to use SAP Cloud Platform Integration.
                        

Create a Parameters File
The parameters file contains the reference parameters to be used in your iFlow. Parameters can be created for a variety of attributes. A typical example includes the location of the WSDL file and the endpoint to be used during the configuration of the communication channels.
To create the parameters file, follow these steps:


                            Right-click on the integration project, and choose New • Other. From the subsequent screen, select General and then File. Enter "parameters.prop" for the file name.
                        

                            Follow the wizard, and make sure that the newly created file is saved in the src.main.resources directory.
                        

                            Click on the Finish button.
                        

                            Populate the newly created file with different parameters and their corresponding values (see Figure A.9 for an example configuration file).
                        


Figure A.9    Parameters File
To reference these parameters during the configuration of a communication channel, the values on the right-hand side of the = sign are enclosed in double curly brackets—for example, {{SOAP_soapWsdlURL}}.
Mapping between Sender and Receiver System
Two possibilities exist to implement the mapping between the sender and receiver:


                            Reuse an existing mapping. If you have an existing option that meets the requirement for passing data from the source system to the target system, then it can be imported from SAP PO using the same steps as for importing service interfaces.
                        

                            Create a new mapping from within the SAP Cloud Platform Integration Designer.
                        

If you opt to create a new mapping, then follow these steps:


                            Right-click on the integration project, and select New • Other. Under SAP Cloud Platform Integration, choose Message Mapping, and follow the wizard.
                        

                            Specify the name of the message mapping, and click on Finish.
                        

                            The Overview screen of the newly created mapping opens. Choose the Definition tab to select the source and target structures to be used in your mapping.
                        

                            Create a mapping between the source and target structures. The structure needs to be selected from the WSDL file imported earlier (an example is presented in Figure A.10).
                            Here, the mapping capability is similar to the one used in SAP BPM. It's equipped with a number of predefined functions that can be used for defining the mapping logic.
                        

                            Go back to the iFlow, and add a mapping artifact. This can be achieved by using the context menu on the horizontal line between the Start and End icons within the Integration Process box. Select the Add Mapping option. A new mapping artifact will be placed.
                        

                            Use the context menu on the newly added mapping artifact, and select the Assign Mapping option. On the resulting selection screen, select the previously created message mapping.
                        


Figure A.10    Mapping Definition between Source and Target Structures
Sender and Receiver Communication Channels
The communication channels need to be configured to the desired adapter type. To configure a communication channel, follow these steps:


                            Right-click on the channel artifact on the sender side. This is the horizontal line between the sender and the Integration Process box. Choose the Configure Channel option.
                        

                            The iFlow jumps into the Channels tab. From there, provide a name for the communication channel, and choose the desired adapter type. In this case, we'll choose the SOAP adapter.
                        

                            You'll also need to go to the Adapter Specific tab to specify further adapter details. The details to be specified include the endpoint and a link to a WSDL URL. The parameters defined in the parameters.prop file can be used here.
                        

                            You'll need to perform the same configuration steps for the receiver communication channel.
                        

The final configuration of the iFlow looks like the one presented in Figure A.11.

Figure A.11    Final Simple iFlow Configured in SAP Cloud Platform Integration
Deploying the Integration Project
After all the configurations are done, and all the changes saved, it's time to deploy the iFlow to your SAP Cloud Platform Integration tenant. If a red marker appears on the integration project after saving, the configuration isn't complete. Check the problem console to see more details about the error. To deploy the project to the cloud, follow these steps:
Right-click on the project, and choose the Deploy Integration Content option. A pop up is shown, asking for the tenant ID. After this is provided, the deployment will be performed.
Monitoring
After successfully deploying the iFlow to the SAP Cloud Platform Integration server, it's time to monitor all running flows to make sure that they are correctly performing the jobs that they were built for and that they are helping the business achieve its goals.
This section will focus on looking at what's required to properly monitor and track running flows in your tenant. Two main approaches can be used to monitor SAP Cloud Platform Integration flow:


                    Via the Eclipse IDE
                

                    Via the SAP Cloud Platform Integration tenant
                

The next sections will explore these two methods.
Monitor Using Eclipse
To monitor your flows directly from the Eclipse IDE, switch to the Integration Operation perspective. Figure A.12 shows the sample messages received by SAP Cloud Platform Integration. Further details and different search functionalities can be used from the monitoring tool.

Figure A.12    Message Monitoring from the Eclipse IDE
In the Message Monitoring screen, you can search messages based on different filtering criteria. The Message Monitoring screen shows different messages that have been received by the server. You can also see their statuses. Note that this perspective also makes a Deployed Artifacts tab available. As its name states, this tab lists all the artifacts that have been deployed to the SAP Cloud Platform Integration server, including iFlows.
Monitor Using WebUI
Monitoring processed messages is also possible using the SAP Cloud Platform Integration WebUI interface. WebUI can be accessed via http://<operations server url>/itspaces.
From this page, click on the Monitor link from the menu. You'll land on a page that looks like the one shown in Figure A.13. This page presents a high-level overview of messages and artifacts with their statuses. You can click on the number to get more details of the objects in question.

Figure A.13    Runtime Status from WebUI









The Integration Advisor
B2B integration projects are often accused of being overly complex due to the challenges that come into play when crossing organizations' boundaries and the misinterpretation of requirements or specifications. Because the ways of working are different between the two business partners, they don't describe their processes in the same manner, and their message structures differ. It requires a lot of effort for the involved parties to understand each other's message formats and to come up with an appropriate mapping specification. All of these challenges result in a higher cost of ownership.
The Integration Advisor is a cloud-based product that is intended to facilitate the implementation phases, covering the entire end-to-end process of implementing a B2B integration project. These stages include the discovery of the appropriate interfaces or messages to be used in the integration and the creation and testing of mapping programs. The Integration Advisor is included as part of SAP Cloud Platform Integration, but customers using the B2B add-on for SAP PO will also be able to use it.
When it comes to mapping two messages in a B2B structure, it's often very difficult to understand the mapping rules and requirements. A combination of email, PDF, Microsoft Word, and spreadsheet documents are often used to describe the mapping requirements and specification to two structures. You can imagine how messy it can get using these different documents to maintain your requirements and decisions, with a lot of meetings and emails bouncing back and forth. After the requirement or specification has been concluded and well documented, each involved party need stills to develop and separately test its solution.
The Integration Advisor will help dramatically reduce the amount of effort and time involved and simplify the process of developing such a scenario through automation and by providing a cloud-based collaboration tool accessible from a browser. Using the Integration Advisor, you can work and collaborate online together with your business partner from the same tool and describe the solution and all its dependent artifacts. This standardized real-time collaboration will help eliminate all other forms of tooling and provide a centralized knowledge base.
Because the Integration Advisor is well integrated with SAP PO and SAP Cloud Platform Integration, the content created in the Integration Advisor can be used and consumed easily, thus reducing the development effort. Furthermore, the tool provides a platform from which the different steps and stages of the B2B integration process can be followed and managed. You can find information relevant to each integration stage grouped together in a logical manner.
The next sections will provide a high-level description of the stages that are involved when using the Integration Advisor (see Figure A.14).

Figure A.14    Different Stages Enabled by the Integration Advisor
Interface Specifications: Advice from the Advisor
With the Integration Advisor, there's no need to reinvent the wheel. One important aspect of the Integration Advisor is that it can give you advice in terms of the standard and message types to be used for your particular B2B scenario. When you're trying to figure out and negotiate which standard or message is best suited for your scenario, enter some relevant details of the scenario (e.g., business process role, industry classification, country, etc.) to get suggestions from the Integration Advisor for which B2B standard, version, and message templates already exist and match your needs. This step also provides a rating of the most-used message versions, thus allowing the user to choose the most appropriate, most popular, and most-used options. You can also generate technical documentation in different forms, including XSDs and PDFs.
Mapping Guideline
Based on messages and interfaces identified in Section A.3.1, it's now time to create or edit the guidelines for the mapping between the two interfaces. The two trading partners involved in the integration can work together on the mapping in a collaborative manner. Furthermore, documentation (e.g., XSLTs and PDFs) can be exported and generated from the guidelines.
Runtime
The tight integration of the Integration Advisor to SAP PO and SAP Cloud Platform Integration makes the magic possible. Based on the mapping descriptions and specifications created in Section A.3.2, mappings are automatically generated in SAP PO and SAP Cloud Platform Integration. In this step, you can also deploy the generated mappings to SAP PO or SAP Cloud Platform Integration.
Testing
After the different objects have been deployed to the server (SAP PO or SAP Cloud Platform Integration), as a result of Section A.3.3, the Integration Advisor will enable you to automatically generate test data, run the mapping, and inspect the results in collaboration with your business partner.









SAP Cloud Platform Workflow as a Service
In Chapter 9, we introduced business process management (BPM) as a concept and SAP BPM as a key component of SAP PO. We also explained the relevance of business process orchestration as part of the IT landscape. The orchestration of business processes across and beyond the enterprise boundaries is paramount for organizations moving into the digital economy and transforming themselves into agile and innovative leaders in their industry area. SAP understands how critical it is to automate business processes, so it has recently introduced a new cloud service that runs on the SAP Cloud Platform called SAP Cloud Platform Workflow. Similarly, to SAP Cloud Platform Integration this new service is also accessible through an Internet browser. It's also organized in three main areas: workflow orchestration, business rules, and human interaction.
Workflow Service
The SAP Cloud Platform Workflow service comes equipped with a rich set of process automation capabilities and has little to envy from its on-premise "sister" product. As you might expect from a cloud service, it's fast and lightweight and it's able to orchestrate end-to-end processes, consume and provide service calls, and integrate with other SAP and non-SAP Cloud Platform applications. It also orchestrates human-centric interactions using beautiful designed task lists and monitoring dashboards. With SAP Cloud Platform Workflow, it is also possible to extend and integrate cloud application workflows that are part of other SAP cloud applications such as SAP S/4HANA, SAP Hybris Cloud for Customer, SAP SuccessFactors, Concur, SAP Ariba, and Internet of Things (using SAP Leonardo).
Workflow Modeling
Modeling of process workflows in SAP Cloud Platform Workflow is based on the Business Process Model and Notation (BPMN) 2.0 standard. Creating a workflow is similar as in SAP BPM or iFlows in SAP Cloud Platform Integration, that is, visual composition of end-to-end workflows, same type of working area, configuration objects, look and feel, and so on. The workflow editor has a user-friendly, intuitive, and lightweight appearance. Figure A.15 shows a process workflow modeled in the web IDE.

Figure A.15    Workflow Editor in SAP Web IDE
SAP Cloud Platform Business Rules
This new cloud service also offers business rules capabilities (e.g., automation of business decision logic) and complements SAP Cloud Platform Workflow and SAP Cloud Platform Integration service offerings. Chapter 13 extensively covered the arguments and need for business rules automation in the enterprise. The same background and challenges applies for business rules supporting business processes execution on the cloud. Business rules can be managed centrally and applied across multiple SAP Cloud Platforms without a strong involvement of IT or developers (Figure A.16). For more details about this new technology service, go to https://cloudplatform.sap.com/capabilities/integration/business-rules.html.
At time of writing this book, the service is accessible with an SAP Cloud Platform trial account at https://account.hanatrial.ondemand.com/#/home/welcome.

Figure A.16    Service Task to Invoke Rules Service
Workflow Tasks Management
My Inbox is a central workflow tasks inbox based on SAP Fiori user experience (UX) from which you can administer and monitor workflows, manage tasks across devices, execute tasks in one screen, and perform searches in task lists (Figure A.17). My Inbox is available both in SAP S/4HANA and in SAP Fiori Cloud, and it can be extended or customized to support custom workflows and user-specific requirements.

Figure A.17    My Inbox Showing Workflow Human Tasks
Integration
By default, SAP Cloud Platform Workflow supports integration via REST web services and OData services (see Figure A.18). You can integrate directly with the platform, but we recommend as best practice using an integration layer in between such as SAP Cloud Platform Integration or SAP PO as the on-premise services bus. This approach allows you to stay in control of the information flowing in and out of your SAP Cloud Platform Workflow while taking advantage of the multiple integration capabilities of a specialized integration platform, such as message validation, transformation, mapping, and security. It's also possible to interact with the SAP Cloud Platform Workflow using its API, which gives you access to operational functions such as starting workflow instances, as well as reading and modifying tasks data. API documentation can be found here: http://bit.ly/2uoHGEH.

Figure A.18    Integrating with SAP Cloud Platform Workflow








The Authors
John Mutumba Bilay studied computer engineering and finance at the University of Cape Town, South Africa. After completing his studies, he started his career as a software engineer. He currently works as a senior software engineer and enterprise integration consultant at Rojo Consultancy B.V. in the Netherlands. With more than 12 years of international experience in information technology, he has primarily focused on integration technologies for the past eight years. His SAP specialties include SAP integration- and process-related technologies, including SAP Process Orchestration and SAP Cloud Platform Integration. He further specializes in artificial intelligence.In addition to his daily integration work, he provides integration-related trainings for SAP and for Rojo Consultancy B.V.
Roberto Viana Blanco is an experienced enterprise integration architect and the cofounder of Rojo Consultancy B.V. in the Netherlands. He has more than 17 years of SAP integration experience working at different global consultancy firms across a number of industries, including manufacturing, logistics, financial services, and utilities. He pioneered the early versions of SAP NetWeaver Exchange Infrastructure (now called SAP XI) and, since then, has helped several organizations worldwide adopt SAP Process Integration and SAP Process Orchestration as their process and application integration platforms. Besides his role as an integration architect, Roberto is also involved in Internet of Things and machine learning startups. In his spare time, he enjoys teaching children programming as a volunteer of the nonprofit Hour of Code at http://code.org.







Index

↓A  ↓B  ↓C  ↓D  ↓E  ↓F  ↓G  ↓H  ↓I  ↓J  ↓K  ↓L  ↓M  ↓N  ↓O  ↓P  ↓Q  ↓R  ↓S  ↓T  ↓U  ↓V  ↓W  ↓X  
A ⇑
ABAP 
business system [→ Section 3.1]
data supplier [→ Section 3.2]
Abstract 
interface [→ Section 16.2]
service interface [→ Section 16.2]
Acceptance [→ Section 11.1]
Access Control List [→ Section 18.1]
Active Directory [→ Section 2.1]
Activities [→ Section 9.3]
automated activity [→ Section 10.4]
type [→ Section 9.3]
Actor [→ Section 16.1]
Adapter 
file/FTP(S) [→ Section 5.3]
HTTP_AAE [→ Section 5.3]
IDoc_AAE [→ Section 5.3]
JDBC [→ Section 5.3]
JMS [→ Section 5.3]
mail [→ Section 5.3]
marketplace [→ Section 5.3]
RFC [→ Section 5.3]
SOAP [→ Section 5.3]
specific attributes [→ Section 5.2]
type [→ Section 5.3]
types, support header mapping in AEX [→ Section 5.4]
Adapter engine [→ Section 5.2]
Adapter module 
asynchronous processing [→ Section 5.2]
DynamicConfigurationBean [→ Section 5.2]
JNDI [→ Section 5.2]
PayloadSwapBean [→ Section 5.2]
PayloadZipBean [→ Section 5.2]
StrictXml2PlainBean [→ Section 5.2]
TextCodepageConversionBean [→ Section 5.2]
XiHeaderValidationBean [→ Section 5.2]
XMLAnonymizerBean [→ Section 5.2]
Adapter object [→ Section 4.3]
Add complex type [→ Section 10.3]
Add mapping [→ Section 6.3]
Administration [→ Section 15.1]
Administrator via principals [→ Section 10.3]
assign roles [→ Section 10.3]
Adobe offline forms [→ Section 12.3]
SAP BPM integration [→ Section 12.3]
Advanced Adapter Engine (AAE) [→ Section 1.1] [→ Section 1.1] [→ Section 1.4]
Advanced Adapter Engine Extended (AEX) [→ Section 7.1] [→ Section 1.1] [→ Section 9.2] [→ Section 10.1] [→ Section 11.1] [→ Section 10.9]
administrative tools [→ Section 7.1]
diagnose integration scenarios [→ Section 7.1]
expose server proxy service [→ Section 14.3]
integration challenges [→ Section 1.2]
message monitoring [→ Section 7.2]
message monitoring error [→ Section 7.3]
messaging exchange [→ Section 7.1]
monitoring [→ Section 7.2]
SAP PI monitoring with SAP Solution Manager [→ Section 7.2]
Agency identifier [→ Section 5.2]
Alert notification [→ Section 7.2]
Alert rule [→ Section 5.1] [→ Section 5.11]
configuration [→ Section 5.11]
create [→ Section 5.11]
creation via Integration Directory [→ Section 5.11]
creation via SAP NetWeaver Administrator [→ Section 5.11]
default rule [→ Section 5.11]
editing/deleting [→ Section 5.11]
information [→ Section 5.11]
message header rules [→ Section 5.11]
message statuses [→ Section 5.11]
Annotation [→ Section 9.3]
Application and scenario communication [→ Section 5.13] [→ Section 11.1] [→ Section 11.2] [→ Section 18.3]
Application communication [→ Section 11.1] [→ Section 10.9]
Application controllers [→ Section 12.2]
Application programming interface (API) [→ Section 2.1] [→ Section 5.13] [→ Section 5.13] [→ Appendix SAP]
communication channel [→ Section 5.13]
Application service [→ Section 18.3] [→ Section 18.3]
Application Thread Manager [→ Section 1.3]
Application thread utilization [→ Section 19.4]
Applications [→ Section 1.2] [→ Section 1.3]
Archiving data [→ Section 11.10]
Archiving tasks 
required roles [→ Section 15.2]
Arguments [→ Section 11.8]
Artifact [→ Section 9.3] [→ Section 10.4]
annotation [→ Section 9.3] [→ Section 9.3] [→ Section 10.4]
data object [→ Section 9.3] [→ Section 10.3] [→ Section 10.4]
AS Java engine [→ Section 1.3]
ASMA [→ Section 5.2] [→ Section 5.2]
activate on communication channel [→ Section 5.2]
Assign system 
sender and receiver [→ Section 6.3]
Assigned users [→ Section 5.4]
Association connector [→ Section 9.3]
Asynchronous communication [→ Section 4.1]
mapping [→ Section 4.2]
Asynchronous process 
SAP BPM [→ Section 14.1]
Attribute [→ Section 4.4]
___Authorizations 
edit [→ Section 2.1]
Auto assign [→ Section 11.1]
Automapping 
advanced [→ Section 10.6]
options [→ Section 10.6]
select [→ Section 10.6]
simple cases or name based [→ Section 10.6]
Automated activity [→ Section 9.3]
add [→ Section 10.4]
boundary event [→ Section 10.4] [→ Section 10.4]
configure [→ Section 10.4]
input mapping [→ Section 10.4]
interface [→ Section 10.4]
looping [→ Section 10.4]
output mapping [→ Section 10.4]
Automated rule-based decisions [→ Section 13.2]
Automatic mapping [→ Section 10.6]
matcher [→ Section 10.6]
Automation of monitoring [→ Section 19.4]
Availability and Performance monitoring [→ Section 15.1]
Availability and Performance work center [→ Section 2.2]
Axis framework [→ Section 5.9]
verify installation [→ Section 5.9]
AXIS Servlet [→ Section 5.9]
Axis-based channel setup [→ Section 5.9]
B ⇑
B2B 
cloud [→ Section 5.8]
integration [→ Section 5.8] [→ Appendix The]
Integration Cockpit [→ Section 5.8]
mapping functions [→ Section 5.8]
mapping template [→ Section 5.8]
number range object [→ Section 5.8]
on premise [→ Section 5.8]
rapid-deployment solution [→ Section 5.8]
scenarios [→ Section 2.1]
Trading Partner Management [→ Section 5.8]
Backend [→ Section 16.1]
Backend application [→ Section 3.1]
expose functionalities [→ Section 1.3]
BE (Best Effort) [→ Section 4.1]
Best practices [→ Section 11.10]
correlation [→ Section 11.10]
data object [→ Section 11.10]
error handling [→ Section 11.10]
gateway [→ Section 11.10]
housekeeping [→ Section 11.10]
looping [→ Section 11.10]
Boundary event [→ Section 9.3] [→ Section 10.4] [→ Section 10.4] [→ Section 10.4]
configuration [→ Section 10.4]
critical exception [→ Section 10.4]
noncritical exception [→ Section 10.4]
BPEL4WS [→ Section 16.1]
definition [→ Section 16.1]
BPM [→ Section 1.2]
Breakpoint [→ Section 11.8]
BRFplus [→ Section 13.2]
BRM system [→ Section 1.2]
Build directory [→ Section 18.2]
Buildspace, broken DC details [→ Section 18.2]
Business activity monitoring (BAM) [→ Section 9.1] [→ Section 2.1]
Business and IT alignment [→ Section 9.3]
Business application design [→ Section 12.1]
Business component [→ Section 5.1] [→ Section 5.2]
create [→ Section 5.2]
maintain server interface [→ Section 5.2]
maintain service interface [→ Section 5.2]
Business content [→ Section 2.1]
Business decisions [→ Section 1.2]
Business entity [→ Section 18.3]
Business log [→ Section 13.2] [→ Section 11.10]
Business Logs tool [→ Section 15.1] [→ Section 15.1] [→ Section 15.1]
Business object 
application service [→ Section 18.3]
create [→ Section 18.3] [→ Section 18.3]
createMultiple [→ Section 18.3]
delete [→ Section 18.3]
deleteMultiple [→ Section 18.3]
findAll [→ Section 18.3]
findByMultipleParamaters [→ Section 18.3]
implementation [→ Section 18.3]
main structure [→ Section 18.3]
modeler [→ Section 18.3]
modeler operations [→ Section 18.3]
read [→ Section 18.3]
update [→ Section 18.3]
updateMultiple [→ Section 18.3]
Business process 
ccBPM [→ Section 1.4]
conditions and rules [→ Section 13.1]
diagram (BPD) [→ Section 9.3]
engine [→ Section 1.1]
model and document tool [→ Section 9.3]
Business process model 
lifecycle [→ Section 9.1]
suite [→ Section 9.1]
versus workflow [→ Section 9.2]
Business Process Model and Notation (BPMN) [→ Section 9.1] [→ Section 9.3] [→ Section 10.1] [→ Section 16.1] [→ Section 16.1] [→ Section 15.1] [→ Section 11.10] [→ Section 11.10]
add human activity [→ Section 10.2]
artifacts [→ Section 9.3]
create model [→ Section 10.2]
data object [→ Section 9.3]
data types [→ Section 10.2]
diagram [→ Section 10.9]
event triggers [→ Section 10.2]
flow element [→ Section 9.3]
flow objects [→ Section 10.3]
flow objects, properties [→ Section 10.3]
functions [→ Section 10.2]
model [→ Section 11.1] [→ Section 10.9]
model, configuration [→ Section 10.3]
process [→ Section 10.2]
process, create [→ Section 10.2]
reporting data sources [→ Section 10.2]
rule sets [→ Section 10.2]
service interfaces [→ Section 10.2]
tasks [→ Section 10.2]
___BPM process 
control [→ Section 1.2]
flexibility [→ Section 1.2]
visibility [→ Section 1.2]
Business rule [→ Section 13.1]
access control management [→ Section 13.2]
add context [→ Section 13.3]
automated [→ Section 1.2] [→ Section 13.1]
creation approach [→ Section 13.2]
deploy and execute [→ Section 13.2]
embedded [→ Section 13.2]
execution logs [→ Section 13.2]
generate web service [→ Section 13.4]
methods [→ Section 13.1]
model [→ Section 13.3]
modeled as rule flow [→ Section 13.2]
modeling best practices [→ Section 13.5]
standalone service [→ Section 13.2]
test [→ Section 13.4]
types and use [→ Section 13.1]
Business rules engine, lack of [→ Section 1.4]
Business rules management [→ Section 1.2]
Business Rules Management System [→ Section 13.1]
Business system [→ Section 5.1] [→ Section 3.1]
attributes [→ Section 3.1]
create [→ Section 3.1]
export objects from SAP PI SLD [→ Section 8.2]
groups [→ Section 3.1] [→ Section 3.1]
import [→ Section 6.3] [→ Section 6.3]
import from SLD [→ Section 5.2] [→ Section 6.3]
select role [→ Section 3.1]
C ⇑
Cache Manager [→ Section 1.3]
Calculation [→ Section 13.1]
Calculator service [→ Section 14.3]
CallSapAdapter [→ Section 5.2]
CBS [→ Section 18.2] [→ Section 18.2]
buildspace [→ Section 18.2]
central compilation [→ Section 18.2]
Request Receiver [→ Section 18.2]
web UI [→ Section 18.2]
web UI, access [→ Section 18.2]
Central adapter engine 
monitoring [→ Section 7.2]
Central Administration tool [→ Section 7.1]
Central database [→ Section 1.3]
Central repository of rules [→ Section 1.2]
Central SAP PI monitoring [→ Section 7.2]
Central Services Registry [→ Section 18.4]
Central Services Server (SCS) [→ Section 19.1]
Central Technical Configuration (CTC) wizard [→ Section 17.1]
Centralized system management [→ Section 7.1]
Certificate [→ Section 19.2]
key storage [→ Section 19.2]
Channel adapter [→ Section 6.3]
Claim check pattern [→ Section 11.4]
approach [→ Section 11.4]
configure the channel [→ Section 11.4]
create interfaces [→ Section 11.4]
create mappings [→ Section 11.4]
Class Loader Manager [→ Section 1.3]
Client Java proxy [→ Section 14.3]
Client proxy [→ Section 14.5]
generate [→ Section 14.3]
wrapper class [→ Section 14.3]
Cloud integration content [→ Section 17.2]
deployment [→ Section 17.2]
Cloud-to-cloud integration [→ Appendix SAP]
Cluster Manager [→ Section 1.3]
Cluster node [→ Section 11.9]
CM Services [→ Section 18.2] [→ Section 18.2]
CTS system [→ Section 18.2]
deployable export [→ Section 18.5]
integrated with CTS+ [→ Section 18.2]
modes [→ Section 18.5]
source export [→ Section 18.5]
standalone [→ Section 18.2]
synchronize [→ Section 18.2]
Collaboration profile [→ Section 5.1] [→ Section 5.2]
communication component without party [→ Section 5.2]
party [→ Section 5.2]
Collection pattern [→ Section 10.9]
Combining SAP BPM and AEX [→ Section 10.8]
Common Information Model (CIM) [→ Section 3.1]
instances and classes [→ Section 3.1] [→ Section 3.1]
send data to SLD [→ Section 3.2]
Common language [→ Section 9.3]
Communication channel [→ Section 5.2] [→ Section 5.14]
adapter type [→ Section 5.2]
direction [→ Section 5.2]
file name [→ Section 6.3]
link to communication component [→ Section 5.2]
message protocol [→ Section 5.2]
module [→ Section 5.2]
module processor [→ Section 5.2]
Monitor [→ Section 19.4]
monitoring [→ Section 19.4]
parameters [→ Section 5.2]
polling interval [→ Section 5.2]
receiver channel [→ Section 5.2]
sender channel [→ Section 5.2]
setting for WS connectivity with SAP BPM [→ Section 11.1]
source directory [→ Section 6.3]
transport protocol [→ Section 5.2]
Communication component [→ Section 5.2]
business component [→ Section 5.2]
business system [→ Section 5.2]
without party [→ Section 5.2]
Communication profile [→ Section 11.1]
assign [→ Section 11.1]
create [→ Section 11.1]
Communications [→ Section 1.2]
Comparators [→ Section 13.3]
Component Build Service 
see CBS [→ Section 18.2]
Component model [→ Section 18.1]
create software component [→ Section 18.1]
development component [→ Section 18.1]
possible DC types [→ Section 18.1]
product [→ Section 18.1]
software component [→ Section 18.1]
Component monitoring [→ Section 19.4]
Composite application [→ Section 18.3]
Composite Designer perspective [→ Section 10.2]
Composite Explorer [→ Section 10.2] [→ Section 10.2]
Composite service [→ Section 1.3] [→ Section 18.3]
create [→ Section 14.4]
Composition layer [→ Section 1.3]
Condition evaluation [→ Section 10.4]
Conditions [→ Section 13.3]
Config Tool [→ Section 7.1]
Configuration [→ Section 2.2]
Configuration and monitoring [→ Section 2.1]
Configuration management [→ Section 11.2] [→ Section 11.2]
Configuration Manager [→ Section 1.3]
___Configuration object 
migrate [→ Section 8.4]
Configuration scenario [→ Section 5.6]
create from model [→ Section 5.6]
create manually [→ Section 5.6]
remove objects [→ Section 5.6]
Configure the deployed service [→ Section 14.3]
Connecting object [→ Section 9.3]
association [→ Section 9.3]
data flow [→ Section 9.3]
message flow [→ Section 9.3]
sequence flow [→ Section 9.3]
Connectivity adapter [→ Section 1.3]
Consolidated installation [→ Section 1.4]
Consolidated monitoring [→ Section 1.4]
Consumer proxies [→ Section 18.4]
Consumer service groups [→ Section 11.1] [→ Section 11.1]
Core Components Technical Specification (CCTS) [→ Section 4.3]
Correlation condition [→ Section 10.4] [→ Section 10.4]
Cost savings [→ Section 1.3]
CPA cache monitor [→ Section 7.2]
Cross-component Business Process Management (ccBPM) [→ Section 9.2] [→ Section 1.1] [→ Section 1.4] [→ Section 16.1]
abstract interface [→ Section 4.1]
as is analysis [→ Section 16.2]
integration processes, migration strategy [→ Section 16.2]
migration steps [→ Section 16.2]
projects [→ Section 16.3]
translate integration process [→ Section 16.2]
vs. SAP BPM [→ Section 16.2]
CTS server destination [→ Section 18.5]
CTS+ [→ Section 16.2]
configuration [→ Section 18.5]
configure CTS parameters [→ Section 18.5]
create a destination [→ Section 18.5]
export SLD object [→ Section 3.4]
test export functionality [→ Section 3.5]
transports [→ Section 3.5]
Custom EJB function [→ Section 11.3] [→ Section 11.3]
Custom function 
create [→ Section 10.6]
EJB function [→ Section 10.6]
expression and mapping [→ Section 10.6]
Custom Java application [→ Section 1.3]
D ⇑
Data forwarding [→ Section 3.5]
Data object [→ Section 9.3] [→ Section 12.1] [→ Section 10.3]
add to process [→ Section 10.4]
analyze [→ Section 15.1]
binding [→ Section 12.1]
characteristics [→ Section 9.3]
Data structure, create [→ Section 10.3]
Data supplier [→ Section 3.2]
ABAP-based system [→ Section 3.2]
change in Java system [→ Section 3.2]
configuration [→ Section 3.5]
destination [→ Section 3.2]
forward to SLD [→ Section 3.5]
Java-based systems [→ Section 3.2]
send data [→ Section 3.2]
Data transformation [→ Section 10.4]
Data type [→ Section 4.3] [→ Section 4.4]
core/aggregated [→ Section 4.3]
freestyle [→ Section 4.3]
XSD support [→ Section 10.3]
Database [→ Section 1.3]
Database clustering [→ Section 19.1]
Database Manager [→ Section 1.3]
DC 
activate and deactivate [→ Section 11.2]
add software components [→ Section 18.2]
auto-deployment [→ Section 18.2]
create [→ Section 12.1] [→ Section 18.1] [→ Section 11.3]
create dependencies [→ Section 12.1]
create from scratch [→ Section 18.2]
dependency [→ Section 18.1]
dependency, creating [→ Section 18.1]
export and import settings [→ Section 18.2]
import from development configuration file [→ Section 18.2]
import options [→ Section 18.2]
importing from SLD [→ Section 18.2]
management [→ Section 18.2]
name [→ Section 18.2]
public part [→ Section 18.1]
repository and build tool location [→ Section 18.2]
runtime system [→ Section 18.2]
SAP BRM [→ Section 13.3]
settings [→ Section 18.2]
SLD [→ Section 18.2]
software component definition [→ Section 18.2]
source [→ Section 18.1]
synchronize [→ Section 18.2]
transport settings [→ Section 18.2] [→ Section 18.5]
Debug 
add configuration [→ Section 11.8]
breakpoint [→ Section 11.8]
configuration [→ Section 11.8]
exception circumstances [→ Section 11.8]
prerequisites [→ Section 11.8]
start [→ Section 11.8]
Debugging [→ Section 11.8]
Debugging function [→ Section 11.8]
step into [→ Section 11.8]
step out [→ Section 11.8]
step over [→ Section 11.8]
Decentralized adapter engine [→ Section 5.2]
Decision [→ Section 13.1]
___Decision logic 
isolate [→ Section 13.5]
Decision table [→ Section 13.3] [→ Section 13.6]
Decoupling [→ Section 1.4]
Default gate [→ Section 10.4]
Default matcher [→ Section 10.6]
DEFAULT_ALERTRULE [→ Section 5.11]
Defensive checks [→ Section 11.10]
DeltaV [→ Section 18.2]
Dependency [→ Section 3.1]
conditions [→ Section 18.1]
synchronize [→ Section 18.1]
Deploy time dependency [→ Section 18.1]
Deployment descriptor [→ Section 14.3]
Design object [→ Section 4.2] [→ Section 4.3]
add structure [→ Section 4.2]
Design time dependency [→ Section 18.1]
Design Time Repository [→ Section 18.2] [→ Section 18.2] [→ Section 18.2] [→ Section 18.2]
detection of version conflicts [→ Section 18.2]
features [→ Section 18.2]
inactive workspace [→ Section 18.2]
managing multiple versions [→ Section 18.2]
server side [→ Section 18.2]
Design Time Repository Browser [→ Section 18.2]
Developer trace access [→ Section 15.2]
Developer traces [→ Section 7.3]
Development [→ Section 2.1]
Development component [→ Section 3.1] [→ Section 11.1] [→ Section 18.1] [→ Section 12.1]
create [→ Section 14.3]
Development configuration [→ Section 18.2]
Development environment setup [→ Section 10.1]
Development infrastructure [→ Section 14.3] [→ Section 16.3] [→ Section 11.3]
Development objects [→ Section 18.1]
Diagram editor designer [→ Section 18.3]
Dictionary [→ Section 18.3]
Directory API [→ Section 8.4]
Distributed Management Task Force (DMTF) [→ Section 3.1]
DNS round-robin load balancing [→ Section 19.1]
Dual stack [→ Section 16.1]
migration [→ Section 8.1]
migration procedure [→ Section 16.2]
E ⇑
EAR DC [→ Section 11.3]
build and deploy [→ Section 14.3]
build and deploy to server [→ Section 14.3]
create [→ Section 11.3]
Eclipse [→ Section 2.3]
configure [→ Appendix SAP]
EDI message exchange [→ Section 5.8]
EJB [→ Section 11.11]
build [→ Section 11.3]
create [→ Section 11.3]
custom function [→ Section 11.11]
deploy [→ Section 11.3]
function, create [→ Section 11.3] [→ Section 11.3]
module [→ Section 18.3]
EJB DC [→ Section 14.3] [→ Section 11.3]
create [→ Section 14.3] [→ Section 14.3] [→ Section 11.3]
Embedded subprocess activity [→ Section 10.4]
Embedded subprocess, aspects [→ Section 10.4]
Encryption on database [→ Section 19.2]
End event [→ Section 9.3]
event trigger [→ Section 10.4]
input mapping [→ Section 10.4]
intermediary event [→ Section 10.4]
Enqueue replication server [→ Section 19.1]
Enqueue server [→ Section 1.3]
Enqueue server process [→ Section 19.1]
Enterprise application [→ Section 14.3]
Enterprise Application Archive DC [→ Section 14.3]
Enterprise application DC create [→ Section 14.3]
Enterprise integration pattern [→ Section 6.1] [→ Section 6.2]
claim check pattern [→ Section 11.4]
dynamic conditions [→ Section 6.1]
message translator [→ Section 6.1]
point-to-point [→ Section 6.1]
recipient list [→ Section 6.1] [→ Section 6.1]
Enterprise Java Bean (EJB) [→ Section 14.1] [→ Section 14.5] [→ Section 11.3]
Enterprise Service Browser [→ Section 14.3]
import SLD objects [→ Section 6.3]
Enterprise service bus (ESB) [→ Section 7.1] [→ Section 9.2] [→ Section 1.1]
integration challenges [→ Section 1.2]
integration with [→ Section 1.2]
Enterprise Services Registry (ES Registry) [→ Section 4.1] [→ Section 2.1] [→ Section 5.12]
services in SOA landscape [→ Section 4.1]
Enterprise Services Repository [→ Section 9.2] [→ Section 1.3]
Enterprise Services Repository (ES Repository) [→ Section 4.1] [→ Section 4.1] [→ Section 2.1]
exercise [→ Section 4.4]
folder [→ Section 4.2]
functional blocks [→ Section 4.1]
import software component metadata [→ Section 4.1]
namespaces best practices [→ Section 4.2]
namespaces, predefined [→ Section 4.2]
Entity services [→ Section 18.3]
EO (Exactly Once) [→ Section 4.1]
EOIO (Exactly Once in Order) [→ Section 4.1]
Error and exception handling [→ Section 13.1]
Error handling [→ Section 11.6]
possible solutions [→ Section 10.7]
ES Builder [→ Section 4.1] [→ Section 2.1] [→ Section 4.4]
mapping object [→ Section 4.2]
recommended system requirements [→ Section 2.1]
tasks performed from [→ Section 2.1]
ES Registry [→ Section 2.1]
publish [→ Section 5.12]
ES Repository [→ Section 2.1] [→ Section 10.9]
activate objects [→ Section 6.3]
content migration [→ Section 8.3]
export objects [→ Section 8.3]
export or reuse objects [→ Section 16.2]
import Objects [→ Section 8.3]
import the service interface [→ Section 14.3]
import WSDL [→ Section 10.3]
inbound service interface [→ Section 14.3]
Web UI [→ Section 2.1]
ES Repository content [→ Section 2.1]
ES Workplace [→ Section 2.1]
Escalation event [→ Section 9.3]
Events [→ Section 9.3]
end event [→ Section 10.4]
start event [→ Section 10.4]
Exception events 
CompletionDeadlineIsCriticalException [→ Section 10.4]
CompletionDeadlineIsNonCriticalException [→ Section 10.4]
HandleExceptionErrorEvent [→ Section 10.4]
StartDeadlineIsCriticalException [→ Section 10.4]
StartDeadlineIsNonCriticalException [→ Section 10.4]
Exception handling [→ Section 16.2]
Exception type [→ Section 10.4]
Exchange of data [→ Section 1.2] [→ Section 1.2]
Exchange of messages [→ Section 5.2] [→ Section 1.2]
Exclusive gateway [→ Section 10.2]
Exercises [→ Section 4.4] [→ Section 6.6] [→ Section 3.6] [→ Section 5.14] [→ Section 14.5] [→ Section 13.6] [→ Section 18.6] [→ Section 11.11] [→ Section 10.9]
Export Service link [→ Section 18.2]
Extensions [→ Section 11.11]
External definitions [→ Section 4.3]
F ⇑
Facade [→ Section 1.3]
Fault message type [→ Section 4.3]
Filters [→ Section 7.3]
Firing queue [→ Section 13.3]
Fixed value mapping [→ Section 5.7]
Flow object [→ Section 9.3] [→ Section 10.4]
activity [→ Section 9.3]
boundary event [→ Section 9.3]
connect [→ Section 9.3]
end event [→ Section 9.3]
event [→ Section 9.3]
events [→ Section 10.4]
gateway [→ Section 9.3]
intermediate event [→ Section 9.3]
start event [→ Section 9.3]
Flow ruleset [→ Section 13.3]
Format lanes [→ Section 10.3]
Framework API [→ Section 1.3]
Freestyle data type [→ Section 4.3]
FTP integration [→ Section 4.4]
FTP server [→ Section 5.14]
Full automatic synchronization 
bidirectional [→ Section 3.4]
unidirectional [→ Section 3.4]
G ⇑
Galaxy Core Service [→ Section 11.9]
Gateway [→ Section 9.3] [→ Section 13.6] [→ Section 10.4]
abstract or undefined [→ Section 10.4]
event-based choice [→ Section 9.3] [→ Section 10.4]
exclusive choice [→ Section 9.3] [→ Section 10.4]
parallel join [→ Section 9.3] [→ Section 10.4]
parallel split [→ Section 9.3] [→ Section 10.4]
split [→ Section 11.10]
types [→ Section 9.3] [→ Section 10.4]
uncontrolled merge [→ Section 9.3] [→ Section 10.4]
Global configuration [→ Section 5.4]
H ⇑
High availability 
database [→ Section 19.1]
web dispatcher setup [→ Section 19.1] [→ Section 19.1]
with standalone enqueue [→ Section 19.1]
History Service access [→ Section 18.2]
Host [→ Section 11.6]
Housekeeping [→ Section 19.3] [→ Section 11.10]
archiving [→ Section 19.3]
deletion [→ Section 19.3]
recovery [→ Section 19.3]
restarting [→ Section 19.3]
HTML5 [→ Section 12.2]
HTTP error status code [→ Section 11.6]
HTTP methods [→ Section 11.6]
DELETE [→ Section 11.6]
GET [→ Section 11.6]
POST [→ Section 11.6]
PUT [→ Section 11.6]
HTTP protocol [→ Section 11.6]
Human activity [→ Section 9.3]
add boundary event [→ Section 10.4]
boundary event [→ Section 10.4]
general [→ Section 10.4]
input mapping [→ Section 10.4]
looping [→ Section 10.4]
output mapping [→ Section 10.4]
task [→ Section 10.4]
Human-centric [→ Section 16.2]
processes [→ Section 9.2]
I ⇑
IDE [→ Section 13.2]
Identifier [→ Section 5.2]
IDoc [→ Section 8.4]
IDoc monitoring [→ Section 7.2]
iFlow [→ Section 6.1] [→ Section 5.1] [→ Section 2.3] [→ Section 6.6] [→ Section 17.2] [→ Section 14.5]
activate [→ Section 6.2]
add and remove receivers [→ Section 6.2]
add mapping [→ Section 6.2]
apply channel template [→ Section 6.2]
assign a service interface [→ Section 6.2]
assign referenced channel [→ Section 6.2]
assign sender and receiver [→ Section 6.2]
business component [→ Section 6.2]
configure [→ Section 6.2]
configure channel attributes [→ Section 6.2]
configure communication channel [→ Section 6.2]
consistency check [→ Section 6.2]
create [→ Section 6.2] [→ Section 6.6]
deploy [→ Section 6.2]
deployment log [→ Section 6.2]
deployment trace [→ Section 6.2]
iFlow ID [→ Section 6.2]
import business system [→ Section 6.2]
monitor message processing in runtime [→ Section 6.3]
test [→ Section 6.3] [→ Section 6.6]
iFlows [→ Section 2.3] [→ Appendix SAP]
If-then rule [→ Section 13.3] [→ Section 13.3]
Import the Service Interface [→ Section 14.5]
Inbound processing [→ Section 5.4] [→ Section 5.4]
Inbound service interface [→ Section 14.3]
Incident management [→ Section 7.2]
Industry solutions [→ Section 4.1]
Inside-out approach [→ Section 14.2]
Installation options [→ Section 1.4]
Instance memory threshold [→ Section 15.1]
Integrated configuration (ICO) [→ Section 5.1] [→ Section 2.1] [→ Section 5.4] [→ Section 5.4] [→ Section 5.14] [→ Section 16.2]
advanced settings [→ Section 5.4]
configuration troubleshooting [→ Section 5.4]
Integration Advisor [→ Appendix The] [→ Appendix SAP]
interface specifications [→ Appendix The]
mapping guideline [→ Appendix The]
runtime [→ Appendix The]
testing [→ Appendix The]
Integration Builder [→ Section 2.1] [→ Section 4.4]
configuration and monitoring tools [→ Section 7.1]
launch [→ Section 5.1]
Integration Directory [→ Section 5.1] [→ Section 4.2] [→ Section 3.6] [→ Section 5.14] [→ Section 5.15]
automate migration [→ Section 8.4]
component [→ Section 5.1]
content migration [→ Section 8.4]
create business component [→ Section 5.2]
create configuration scenario [→ Section 5.6]
editor area [→ Section 5.1]
manual migration [→ Section 8.4]
menu [→ Section 5.1]
migrate existing content [→ Section 16.2]
migration classic configuration [→ Section 8.4]
migration ICOs [→ Section 8.4]
migration integration process [→ Section 8.4]
object types [→ Section 5.1]
using the Migration tool [→ Section 8.4]
Integration engine [→ Section 1.4]
Integration gateway component [→ Section 17.1]
Integration gateway component monitor [→ Section 17.3]
Integration pattern [→ Section 4.1]
stateful [→ Section 4.1]
stateless [→ Section 4.1]
Tentative Update and Confirm or Compensate [→ Section 4.1]
Integration patterns 
see Enterprise integration patterns [→ Section 6.1]
Integration platform-as-a-service (iPaaS) [→ Appendix SAP]
Integration process [→ Section 5.1]
Integration scenario create [→ Section 4.1]
Integration visibility configuration [→ Section 2.1]
Interface [→ Section 1.3] [→ Section 1.3]
building process [→ Section 5.1]
channel monitoring [→ Section 19.4]
determination [→ Section 5.4]
Interface Directory 
Swing UI tool [→ Section 6.2]
Interface object [→ Section 4.3]
Intermediary event 
automated activity [→ Section 11.1]
configuration [→ Section 11.1]
event trigger [→ Section 10.4]
Intermediate event [→ Section 9.3]
Intermediate message event [→ Section 10.4] [→ Section 10.4]
delivery [→ Section 10.4]
matching [→ Section 10.4]
Intermediate timer event [→ Section 10.4]
expression [→ Section 10.4]
time offset [→ Section 10.4]
Internationalization and localization [→ Section 13.1]
Internet Communication Manager (ICM) [→ Section 1.3] [→ Section 1.3] [→ Section 1.3] [→ Section 1.3] [→ Section 19.1]
Investigator [→ Section 19.4]
J ⇑
JAR files [→ Section 1.3]
Java 
name reservation [→ Section 3.1]
Java Archive (JAR) [→ Section 14.3] [→ Section 14.3]
Java Archiving Cockpit [→ Section 15.2]
access [→ Section 15.2]
Java Central Services [→ Section 19.1]
instance [→ Section 19.1]
Java client proxy [→ Section 14.5]
Java enterprise runtime [→ Section 1.3] [→ Section 1.3] [→ Section 1.3]
Java instance [→ Section 1.3]
Java Message Service (JMS) [→ Section 1.3]
Java Naming and Directory Interface (JNDI) [→ Section 5.2] [→ Section 5.2]
browser [→ Section 5.2]
Java only [→ Section 16.1]
Java parameter 
database connection pool configuration [→ Section 19.1]
FCAServerThreadCount [→ Section 19.1]
garbage collection configuration [→ Section 19.1]
ICM timeout values [→ Section 19.1]
tuning [→ Section 19.1]
Java proxy [→ Section 14.1]
client [→ Section 14.3]
compile [→ Section 14.3]
deploy [→ Section 14.3]
develop [→ Section 14.3]
generate Java Bean skeleton [→ Section 14.3]
generate wrapper [→ Section 14.3]
implementation [→ Section 14.1]
implementation approaches [→ Section 14.2]
orchestration [→ Section 14.4]
orchestration, create [→ Section 14.4]
runtime [→ Section 14.1]
Java Proxy Runtime Monitor [→ Section 19.4]
Java server proxy [→ Section 14.5]
Java system 
architecture [→ Section 19.1]
configuration [→ Section 19.1]
Java Web Start [→ Section 2.1]
Java Web Start application [→ Section 5.1] [→ Section 5.14]
Java-only installation [→ Section 1.1]
Java-only stack [→ Section 1.1]
Java-only system 
setup considerations [→ Section 19.1]
sizing [→ Section 19.1]
JAX-WS [→ Section 14.1]
JNDI 
access [→ Section 11.3]
filter Java Bean [→ Section 11.3]
object name [→ Section 11.3]
jQuery [→ Section 12.2]
JSON [→ Section 12.2]
JVMMON [→ Section 19.4]
K ⇑
Key performance indicators (KPIs) [→ Section 9.2] [→ Section 19.4]
L ⇑
Landscapes 
create [→ Section 3.1]
functionalities [→ Section 3.1]
Lane [→ Section 9.3]
Large message [→ Section 11.4]
Legacy application [→ Section 1.3]
Library [→ Section 1.3] [→ Section 1.3]
Licensing Manager [→ Section 1.3]
Load balancer 
advantages [→ Section 19.1]
Demilitarized Zone (DMZ) [→ Section 19.1]
Load balancing [→ Section 19.1]
Local or central ES Repository [→ Section 2.1]
Local system [→ Section 11.1]
LocalDevelopment [→ Section 14.3]
Lock and cache administration [→ Section 7.1]
Lock collision [→ Section 1.3]
Lock request [→ Section 1.3]
Lock table [→ Section 1.3]
Locking Manager [→ Section 1.3]
Log and traces [→ Section 7.3]
Log ID [→ Section 11.6]
Log level setting [→ Section 11.10]
Log Manager [→ Section 1.3]
Log shipping [→ Section 19.1]
Log Viewer [→ Section 7.3] [→ Section 2.2] [→ Section 15.2] [→ Section 11.6]
access [→ Section 15.2]
show log [→ Section 11.1]
Logging [→ Section 5.4]
Login credentials [→ Section 11.8]
Looping [→ Section 11.10]
configuration [→ Section 10.4]
currentCollectionItem [→ Section 10.4]
numberOfCompletedIterations [→ Section 10.4]
Parallel For Each [→ Section 10.4]
Parallel For Each option [→ Section 10.4]
M ⇑
Manage processes [→ Section 19.4]
Manage tasks [→ Section 19.4]
Mapping [→ Section 4.2] [→ Section 11.10] [→ Section 10.9]
leverage mapping in SAP BPM [→ Section 10.8]
reuse in SAP BPM [→ Section 10.8]
Mapping activity [→ Section 10.4]
general [→ Section 10.4]
looping [→ Section 10.4]
mapping [→ Section 10.4]
mapping function [→ Section 10.4]
mapping line [→ Section 10.4]
Mapping as a service (MaaS) [→ Section 10.8] [→ Section 10.8]
Mapping assignment [→ Section 10.6]
append [→ Section 10.6]
merge [→ Section 10.6]
set [→ Section 10.6]
Mapping complexity [→ Section 11.10]
Mapping object [→ Section 4.2]
MAX-RESTART [→ Section 19.3]
Memory consumption [→ Section 11.10]
Message 
alerting [→ Section 5.11]
alerting, process steps [→ Section 5.11]
from SAP BPM to the AEX [→ Section 10.8]
mapping [→ Section 4.2]
Monitor [→ Section 19.4]
monitoring [→ Section 6.3]
protocol [→ Section 11.1]
protocol, WS [→ Section 11.1]
retention [→ Section 7.2]
server [→ Section 1.3]
trigger [→ Section 10.4] [→ Section 10.4]
type [→ Section 4.3]
Message mapping editor [→ Section 4.4]
Message monitoring [→ Section 17.3]
Message structure [→ Section 10.9]
Message trigger [→ Section 10.9]
Message type [→ Section 4.4] [→ Section 4.4] [→ Section 4.4]
MessageStatusUpdater [→ Section 11.4]
MESSAGE_ID_LIST [→ Section 11.4]
PROCESS_INSTANCE_ID [→ Section 11.4]
MessageStatusUpdaterBean [→ Section 11.4]
Metadata [→ Section 2.1] [→ Section 18.3]
Metering of service calls [→ Section 5.4]
Migration [→ Section 16.1] [→ Section 16.2]
approach [→ Section 16.2]
big bang/phase-based [→ Section 16.2]
reasons [→ Section 16.1]
recommendations [→ Section 16.3]
translate and redesign [→ Section 16.2]
Migration strategy [→ Section 8.1]
in-place upgrade [→ Section 8.1]
side-by-side migration [→ Section 8.1]
Migration tool [→ Section 2.1] [→ Section 16.2]
access [→ Section 8.4]
add new system [→ Section 8.4]
channel migration [→ Section 8.4] [→ Section 8.4]
configuration [→ Section 8.4] [→ Section 8.4]
conflict resolution [→ Section 8.4]
considerations [→ Section 8.4]
create change list [→ Section 8.4]
create rule [→ Section 8.4]
features [→ Section 8.4]
mass migration [→ Section 8.4]
migrate communication channel [→ Section 8.4]
renaming rule [→ Section 8.4]
required roles [→ Section 8.4]
scenario migration [→ Section 8.4] [→ Section 8.4]
scenario selection [→ Section 8.4]
steps overview [→ Section 8.4]
unsupported objects [→ Section 8.4]
Mobile [→ Section 1.3]
Modeling [→ Section 4.3] [→ Section 16.1]
Modeling environment [→ Section 2.1]
Model-view-controller [→ Section 12.2] [→ Section 12.2]
controller [→ Section 12.2]
model [→ Section 12.2]
view [→ Section 12.2]
Monitor Java heap utilization [→ Section 19.4]
Monitor system [→ Section 19.4]
Monitoring [→ Section 2.2] [→ Section 15.1] [→ Section 17.3] [→ Section 19.4]
Monitoring Home screen [→ Section 2.1]
Monitoring tools 
authorizations and roles [→ Section 15.1]
Move-corresponding [→ Section 11.10]
Multiple application servers [→ Section 19.1]
Multithreaded [→ Section 1.3]
N ⇑
Name reservation [→ Section 3.1]
Namespace [→ Section 4.2]
Namespace prefix [→ Section 3.1]
Network communication overhead [→ Section 1.4]
Node [→ Section 19.1]
None intermediary trigger [→ Section 10.4]
Notification activity [→ Section 10.2] [→ Section 10.4]
general [→ Section 10.4]
mail [→ Section 10.4]
specify receiver [→ Section 10.4]
to [→ Section 10.4]
NotificationTask 
configuration [→ Section 12.2]
NotificationTask, configuration [→ Section 12.2]
NWA_READONLY [→ Section 15.1]
NWA_SUPERADMIN [→ Section 15.1]
O ⇑
Object Management Group [→ Section 9.3]
Object, export or import [→ Section 8.2]
Object-oriented modeling [→ Section 3.1]
OData [→ Section 12.2]
API [→ Section 11.6]
wrapper [→ Section 11.6]
OData services [→ Appendix SAP]
for task data [→ Section 11.6] [→ Section 11.6]
for tasks [→ Section 11.6] [→ Section 11.6]
Online rules editing tool [→ Section 13.2]
Openness [→ Section 11.6]
Operation mapping [→ Section 4.2] [→ Section 4.4] [→ Section 4.4]
Operations [→ Section 2.2]
Operations for SAP Cloud Platform Integration [→ Appendix SAP]
Orchestration [→ Section 14.4]
OriginalMessageAccessor [→ Section 11.4]
Outbound processing [→ Section 5.4] [→ Section 5.4] [→ Section 5.14]
Outbound service interface [→ Section 4.4] [→ Section 6.6]
Outside-in approach [→ Section 14.2]
P ⇑
Parallel processing [→ Section 11.10]
Parallel split gateway [→ Section 11.10]
Parallel web dispatcher 
setup [→ Section 19.1]
Parallel web dispatcher, setup [→ Section 19.1]
Parallelism [→ Section 11.10] [→ Section 11.10]
Parameterized subject [→ Section 11.10]
Parameterized text, create [→ Section 10.4]
Parameters file 
create [→ Appendix SAP]
populate [→ Appendix SAP]
Party [→ Section 5.1]
Dun & Bradstreet Corporation [→ Section 5.2]
EAN - International Article Numbering Association [→ Section 5.2]
SCHEME [→ Section 5.2]
path_segment [→ Section 11.6]
Payload [→ Section 11.8]
Performance [→ Section 16.2]
Perspective [→ Section 10.2]
Debug [→ Section 11.8] [→ Section 11.8]
Java EE [→ Section 11.3]
Process Development [→ Section 11.8]
SAP Process Integration Administration [→ Section 6.1]
SAP Process Integration Designer [→ Section 6.1] [→ Section 6.1] [→ Section 6.2]
SAP Process Integration Runtime [→ Section 6.1]
pimon [→ Section 7.1] [→ Section 2.1]
AEX monitoring tools [→ Section 7.2]
SAP NetWeaver Administrator [→ Section 7.2]
Point-to-point channel [→ Section 6.3]
Point-to-point integration [→ Section 1.2]
Polling interval [→ Section 11.9]
Pool 
administrator [→ Section 10.3]
assign administrator [→ Section 10.3]
assign administrator via expression [→ Section 10.3]
characteristics [→ Section 9.3]
configure [→ Section 10.3]
object [→ Section 9.3]
Pool Manager [→ Section 1.3]
Port [→ Section 11.6]
number [→ Section 1.3]
Potential owner [→ Section 10.4]
Presentation layer [→ Section 1.3]
Principal [→ Section 10.3]
Principal expression 
getPrincipal [→ Section 10.3]
getPrincipalByUniqueName [→ Section 10.3]
getPrincipals [→ Section 10.3]
Principal, rules and functions [→ Section 10.3]
Process [→ Section 11.8]
all running processes [→ Section 15.1]
error and failed processes [→ Section 15.1]
instance ID [→ Section 15.1]
perform administrative actions [→ Section 15.1]
see details [→ Section 15.1]
Task Management tool [→ Section 15.1]
view definition flow [→ Section 15.1]
view process history [→ Section 15.1]
Process data 
archiving [→ Section 15.2]
volume [→ Section 11.10]
Process definition [→ Section 15.1]
Process driven organization [→ Section 9.2]
Process flow 
alternative path [→ Section 9.3]
exceptional situations [→ Section 9.3]
execute different rules [→ Section 13.3]
pool [→ Section 9.3]
Process instance context data [→ Section 15.1]
Process instance details access [→ Section 15.1]
Process integration 
action [→ Section 4.2]
scenario [→ Section 4.2]
tools [→ Section 2.1] [→ Section 2.1]
Process Management tool [→ Section 15.1]
access [→ Section 15.1]
tasks [→ Section 15.1]
Process modeling and execution [→ Section 9.3]
Process pool properties [→ Section 10.3]
description [→ Section 10.3]
enable principle propagation [→ Section 10.3]
expression [→ Section 10.3]
Make this pool active [→ Section 10.3]
name [→ Section 10.3]
parameterized texts [→ Section 10.3]
principals [→ Section 10.3] [→ Section 10.3]
variables [→ Section 10.3]
Process Repository [→ Section 15.1] [→ Section 11.2] [→ Section 10.5] [→ Section 10.9]
access [→ Section 15.1] [→ Section 11.2]
list DCs [→ Section 11.2]
overview [→ Section 11.2]
Process task attributes [→ Section 15.1]
Process Troubleshooting tool [→ Section 15.1]
access [→ Section 15.1]
ProcessDefinition [→ Section 11.5] [→ Section 11.5]
ProcessDefinitionManager [→ Section 11.5]
Processes and tasks [→ Section 11.2]
ProcessStartEvent [→ Section 11.5]
Product, create [→ Section 3.1]
Production [→ Section 11.1]
Program sldreg [→ Section 3.2]
Protocols [→ Section 1.3]
Provider system [→ Section 11.1]
Proxy [→ Section 5.3]
generation [→ Section 4.1]
Public part [→ Section 18.1] [→ Section 18.1]
assembly [→ Section 18.1]
compilation [→ Section 18.1]
create [→ Section 18.1]
manage entities [→ Section 18.1]
purposes [→ Section 18.1]
Publishing services [→ Section 5.12]
Q ⇑
Quality of service (QoS) [→ Section 4.1] [→ Section 6.3]
R ⇑
RAR files [→ Section 1.3]
Receiver [→ Section 5.4] [→ Section 5.4]
enhanced receiver determinations [→ Section 5.4]
not operation-specific [→ Section 5.4]
operation-specific [→ Section 5.4]
routing condition [→ Section 5.4]
simple receiver and conditions [→ Section 5.4]
Receiver agreement [→ Section 5.1] [→ Section 5.4]
Receiver channel [→ Section 6.6]
Receiver communication channel 
configuration [→ Section 6.3]
Receiver component [→ Section 4.4]
Receiver determination [→ Section 5.4] [→ Section 5.4]
Receiver interface [→ Section 5.4] [→ Section 5.4] [→ Section 5.14]
Redesigning business processes [→ Section 16.3]
Referenced subprocess activity [→ Section 10.4]
boundary events [→ Section 10.4]
input mapping [→ Section 10.4]
looping [→ Section 10.4]
output mapping [→ Section 10.4]
process [→ Section 10.4]
Referenced subprocess aspects [→ Section 10.4]
Related integration server [→ Section 3.1]
Reliability [→ Section 1.3] [→ Section 1.4]
Remote Function Call (RFC) [→ Section 2.2] [→ Section 11.1]
Renaming rule [→ Section 8.4] [→ Section 16.2]
Report activity [→ Section 10.4] [→ Section 10.4]
REST [→ Section 11.6]
REST adapter [→ Section 5.10]
features [→ Section 5.10]
REST web services [→ Appendix SAP]
REST wrapper [→ Section 11.5]
Restart [→ Section 11.9]
RESTART-BLACKLISTED [→ Section 19.3]
RESTful [→ Appendix SAP]
RESTful web services [→ Section 5.10]
RfcAFBean [→ Section 5.2]
Round-robin [→ Section 19.1]
Routing [→ Section 1.2] [→ Section 13.1]
Rule [→ Section 13.3]
script [→ Section 13.3]
Rule action 
assign [→ Section 13.3]
categories [→ Section 13.3]
decision table [→ Section 13.3]
evaluate decision table [→ Section 13.3]
execute [→ Section 13.3]
reevaluate [→ Section 13.3]
retract [→ Section 13.3]
Rule flow [→ Section 13.3]
configure [→ Section 13.6]
Rules and functions 
Boolean [→ Section 10.6]
Durations, Dates and Times [→ Section 10.6]
Generic [→ Section 10.6]
Numeric [→ Section 10.6]
Principal [→ Section 10.6]
String [→ Section 10.6]
Rules Business Logs tool [→ Section 15.1]
Rules Composer [→ Section 13.2] [→ Section 13.3] [→ Section 13.3] [→ Section 13.6] [→ Section 13.6]
Rules Composer DC 
import existing XSD file [→ Section 13.3]
Rules engine [→ Section 13.1] [→ Section 13.2]
authorization and administration [→ Section 13.2]
reexamine all rules [→ Section 13.3]
Rules Manager [→ Section 13.2] [→ Section 13.3]
editing tool [→ Section 13.2]
Rules repository [→ Section 13.1]
Rules simulation [→ Section 13.1]
Runtime Workbench (RWB) [→ Section 2.1] [→ Section 19.4]
S ⇑
SampleTimer [→ Section 10.4]
SAP API Management [→ Section 18.4] [→ Appendix SAP]
SAP B2B TPM 
functional profile [→ Section 5.8]
trading partner agreement [→ Section 5.8]
trading partner profile [→ Section 5.8]
SAP backend [→ Section 11.1]
application [→ Section 1.3]
SAP BPM Action Monitor [→ Section 15.1]
access [→ Section 15.1]
SAP BPM activities [→ Section 10.4]
activity [→ Section 10.4]
human activity [→ Section 10.4]
SAP BPM API [→ Section 11.5]
BPEM-FACADE [→ Section 11.5]
classes [→ Section 11.5] [→ Section 11.5]
dependencies [→ Section 11.5]
ENGFACADE [→ Section 11.5]
features [→ Section 11.5]
main objects [→ Section 11.5]
package [→ Section 11.5]
prerequisites [→ Section 11.5]
ProcessDefinitionManager [→ Section 11.5]
ProcessInstanceManager [→ Section 11.5]
ProcessModelManager [→ Section 11.5]
ProcessStartManager [→ Section 11.5]
roles [→ Section 11.5]
TaskInstanceManager [→ Section 11.5]
SAP BPM Inbox [→ Section 12.2]
access [→ Section 15.1]
configuration [→ Section 15.1]
process [→ Section 15.1]
required roles [→ Section 15.1]
task activities [→ Section 15.1]
SAP BPM Java API [→ Section 12.2]
SAP BPM Mail Server Connectivity configuration [→ Section 10.4]
SAP BPM OData [→ Section 11.6] [→ Section 11.6]
base URL [→ Section 11.6]
extra options [→ Section 11.6]
principles [→ Section 11.6]
SAP BPM Open Data protocol 
see SAP BPM OData [→ Section 11.6]
SAP BPM process 
advanced mapping [→ Section 10.6]
boundary event [→ Section 10.7]
build [→ Section 10.5]
create mapping [→ Section 10.6]
data mapping [→ Section 10.6]
debugging [→ Section 11.8]
deploy [→ Section 10.5]
download resources [→ Section 11.2]
error end event [→ Section 10.7]
implementing error handling [→ Section 10.7]
input data [→ Section 11.2]
instance, steps to start [→ Section 11.2]
lanes [→ Section 10.2]
name [→ Section 10.2]
new pool [→ Section 10.2]
obtain WSDL [→ Section 11.2]
orientation [→ Section 10.2]
performance parameters [→ Section 11.9]
project [→ Section 10.2]
rules and functions [→ Section 10.6]
running [→ Section 11.2]
start [→ Section 11.2]
start externally [→ Section 11.2]
start internally [→ Section 11.2]
steps [→ Section 10.2]
termination event [→ Section 10.7]
test [→ Section 11.2]
testing [→ Section 11.2]
troubleshooting [→ Section 11.8]
tuning [→ Section 11.9]
SAP BPM queue 
content [→ Section 15.1]
settings [→ Section 15.1]
summary [→ Section 15.1]
SAP BRM [→ Section 13.2]
SAP Business Process Management (SAP BPM) [→ Appendix Introduction] [→ Section 1.1] [→ Section 9.2] [→ Section 9.2] [→ Section 11.1] [→ Section 14.1] [→ Section 15.1]
action [→ Section 11.9] [→ Section 11.9]
Analytics Dashboard [→ Section 15.1] [→ Section 15.1]
API [→ Section 11.5]
application [→ Section 11.10]
business process visibility [→ Section 9.2]
call web service steps [→ Section 10.8]
Composite Designer perspective [→ Section 10.2]
create product [→ Section 10.2]
create software component [→ Section 10.2]
custom functions [→ Section 10.6]
custom UI integration steps [→ Section 12.3]
DC [→ Section 11.8]
developer [→ Section 11.8]
fundamental concepts [→ Section 9.1]
gateway [→ Section 10.4]
human tasks [→ Section 12.3]
implementation steps [→ Section 10.2]
integrate SAPUI5 [→ Section 12.2]
integration of custom UI technologies [→ Section 12.3]
interaction with the AEX [→ Section 10.8]
landscape scope [→ Section 9.2]
main components [→ Section 9.2]
monitor process instances [→ Section 15.1]
object [→ Section 11.5]
OData [→ Section 12.2]
positioning [→ Section 10.1]
process [→ Section 10.1]
Process Development perspective [→ Section 10.2]
process implementation [→ Section 10.2]
Process Modeling perspective [→ Section 10.2]
RFC [→ Section 11.1]
supported scenarios [→ Section 9.2]
system overview [→ Section 15.1]
system overview access [→ Section 15.1]
system overview capacity [→ Section 15.1]
troubleshooting [→ Section 15.2]
vs. ccBPM [→ Section 16.2]
WS [→ Section 11.1]
XI 3.0 [→ Section 11.1]
SAP Business Rules Management (SAP BRM) [→ Appendix Introduction] [→ Section 1.1] [→ Section 1.1] [→ Section 1.1] [→ Section 9.2] [→ Section 13.1] [→ Section 16.2] [→ Section 15.1]
components [→ Section 13.2]
design time [→ Section 13.2]
rule implementation [→ Section 1.2]
SAP Business Workflow [→ Section 9.2] [→ Section 16.1]
versus BPM [→ Section 9.2]
SAP BusinessObjects Business Intelligence (SAP BusinessObjects BI) [→ Section 9.2]
SAP Central Services [→ Section 1.3]
SAP Central Services instance [→ Section 1.3]
components [→ Section 1.3]
SAP Cloud Platform Integration [→ Section 17.1] [→ Appendix SAP] [→ Appendix SAP] [→ Appendix The]
application edition [→ Appendix SAP]
certificates and security artifacts [→ Appendix SAP]
cloud [→ Appendix SAP]
cloud solutions [→ Appendix SAP]
communication channels, configure [→ Appendix SAP]
connectivity options [→ Appendix SAP]
designer [→ Appendix SAP]
development guide [→ Appendix SAP]
features [→ Appendix SAP]
flows [→ Section 17.2]
iFlow, create [→ Appendix SAP]
license [→ Appendix SAP]
mapping, create [→ Appendix SAP]
Message Mapping [→ Appendix SAP]
monitor using Eclipse [→ Appendix SAP]
monitoring [→ Appendix SAP]
monitoring using the WebUI interface [→ Appendix SAP]
multitenant architecture [→ Appendix SAP]
on-premise [→ Appendix SAP] [→ Appendix SAP]
pattern template [→ Appendix SAP]
plugin [→ Appendix SAP]
professional package [→ Appendix SAP]
project, deploy [→ Appendix SAP]
repository connection [→ Appendix SAP]
sender and receiver systems [→ Appendix SAP]
standalone integration platform edition [→ Appendix SAP]
tenant [→ Section 17.1]
tenant account [→ Appendix SAP]
user-defined template [→ Appendix SAP]
WebUI [→ Appendix SAP]
workbench and tools [→ Appendix SAP]
SAP Cloud Platform Workflow [→ Appendix SAP]
SAP Code Exchange [→ Section 11.5]
SAP Composite Application Framework (SAP CAF) [→ Section 1.3] [→ Section 18.1]
business object [→ Section 18.3] [→ Section 18.3]
capabilities [→ Section 18.3]
configuration [→ Section 18.3]
core project [→ Section 18.3]
entity services [→ Section 18.3]
runtime aspects [→ Section 18.3]
SAP Composition Environment [→ Section 1.1] [→ Section 1.1] [→ Section 1.1] [→ Section 2.1]
SAP CR content [→ Section 3.5]
SAP Enterprise Portal [→ Section 1.3]
SAP Exchange Infrastructure (SAP XI) [→ Section 4.1] [→ Section 1.1]
2.0 [→ Section 1.1]
3.0 [→ Section 1.1]
SAP Gateway [→ Appendix SAP]
SAP Industry adapter 
CIDX [→ Section 5.3]
RosettaNet [→ Section 5.3]
SAP industry adapters [→ Section 5.3]
SAP JVM [→ Section 19.1]
SAP landscape [→ Section 1.2]
SAP license [→ Section 1.3]
SAP Management Console (SAP MC) [→ Section 19.4]
features [→ Section 19.4]
SAP NetWeaver 7.3 EHP 1 SP 09 [→ Section 11.6]
SAP NetWeaver Administrator [→ Section 7.1] [→ Section 2.2] [→ Section 2.2] [→ Section 15.1] [→ Section 11.1] [→ Section 18.6] [→ Section 10.9]
configure deployed service [→ Section 14.3]
create alert rule [→ Section 5.11]
Log Viewer [→ Section 7.3]
SAP NetWeaver Administrator (NWA) [→ Section 2.1]
SAP NetWeaver AS [→ Section 16.2]
SAP NetWeaver AS ABAP [→ Section 1.1]
SAP NetWeaver AS Java [→ Section 3.1] [→ Section 7.1] [→ Section 1.1] [→ Section 14.3]
advanced offline configuration [→ Section 7.1]
applications [→ Section 1.3]
cluster [→ Section 1.3]
communication [→ Section 1.3]
configure data suppliers [→ Section 3.5]
console administration [→ Section 7.1]
deploy business rules [→ Section 13.2]
synchronization [→ Section 1.3]
system architecture [→ Section 1.3]
system components [→ Section 1.3] [→ Section 1.3] [→ Section 1.3]
system components or services [→ Section 1.3]
SAP NetWeaver AS Java cluster [→ Section 1.3]
installation [→ Section 1.3]
SAP NetWeaver Developer Studio [→ Section 6.1] [→ Section 2.1] [→ Section 6.1] [→ Section 9.3] [→ Section 2.3] [→ Section 2.3] [→ Section 6.6] [→ Section 13.6] [→ Section 11.11] [→ Section 10.9]
business rules [→ Section 13.2]
configure for Java proxy [→ Section 14.3]
create business object [→ Section 18.3]
create data type [→ Section 6.3]
create Enterprise Service Repository objects [→ Section 6.3]
create message mapping [→ Section 6.3] [→ Section 6.3]
create message type [→ Section 6.3]
create namespace [→ Section 6.3]
create project [→ Section 10.2]
create Rules Composer DC [→ Section 13.3]
create service interface [→ Section 6.3]
create XSD [→ Section 10.3]
development components overview [→ Section 10.2]
download link [→ Section 10.1]
Enterprise Service Browser [→ Section 6.1]
Enterprise Service Repository connection [→ Section 6.1] [→ Section 10.1]
installation [→ Section 6.1]
perspective [→ Section 2.3]
perspective concept [→ Section 10.2]
PI Explorer [→ Section 6.2]
PI Tools [→ Section 6.1]
preferences [→ Section 10.1]
Rules Composer [→ Section 13.2]
SAP NetWeaver AS Java [→ Section 10.1]
settings [→ Section 10.1]
setup [→ Section 6.1]
switch perspective [→ Section 10.2]
versions [→ Section 10.1]
SAP NetWeaver development infrastructure [→ Section 3.1] [→ Section 3.1] [→ Section 18.1] [→ Section 16.2] [→ Section 18.2]
access [→ Section 18.2]
access export service [→ Section 18.2]
activate name server role [→ Section 3.1]
activities [→ Section 18.2]
advantages [→ Section 18.2]
archive file [→ Section 18.2]
CBS [→ Section 18.2]
check in [→ Section 18.2]
check out [→ Section 18.2]
client side [→ Section 18.2]
Export Service [→ Section 18.2]
Export UI [→ Section 18.5]
History Service [→ Section 18.2]
Import Service [→ Section 18.2]
inbox path [→ Section 18.2]
include source/archives [→ Section 18.2]
resolve conflict [→ Section 18.2]
runtime systems [→ Section 18.2]
stop on error [→ Section 18.2]
support package and patch levels [→ Section 18.2]
synchronisation recommendation action [→ Section 18.2]
SAP NetWeaver foundation [→ Section 1.3]
SAP PI [→ Section 9.2]
7.1 [→ Section 1.1]
7.3 [→ Section 1.1]
7.11 [→ Section 1.1]
dual stack [→ Section 1.4]
dual stack migration to SAP PO [→ Section 8.1]
dual to single stack [→ Section 8.1]
local monitoring [→ Section 7.2]
monitoring [→ Section 7.1]
separate installations [→ Section 1.4]
tools [→ Section 6.1]
SAP PI Explorer [→ Section 6.3]
SAP PI Tools Configuration [→ Section 6.1]
SAP PO [→ Section 1.1]
application server [→ Section 8.1]
business process support [→ Section 8.1]
calling services [→ Section 17.2]
capabilities [→ Section 1.3]
components info [→ Section 10.1]
custom table [→ Section 8.1]
data and value mapping [→ Section 8.1]
determine version [→ Section 10.1]
development tools and IDE [→ Section 8.1]
foundation [→ Section 1.3]
history [→ Section 1.1]
home page [→ Section 2.1]
integration content [→ Section 2.3]
interface configuration [→ Section 8.1]
mapping [→ Section 8.1]
migration option [→ Section 8.1]
positioning [→ Section 1.3]
server [→ Section 11.8]
single-stack architecture [→ Section 9.2]
___SAP Process 
retrieve large message [→ Section 11.4]
SAP Process Integration → see [SAP PI]
SAP Process Orchestration → see [SAP PO]
SAP Quick Sizer tool [→ Section 19.1]
SAP Service Marketplace [→ Section 2.1]
___SAP Solution Manager 
central SAP PI monitoring [→ Section 7.2]
___SAP Solution Manager monitoring [→ Section 19.4]
SAP SuccessFactors [→ Appendix SAP]
SAP Web Dispatcher [→ Section 19.1]
SAP_BPM_Navigation [→ Section 15.1]
SAP_BPM_ODATA [→ Section 11.6]
SAP_BPM_ODATA_INBOX [→ Section 11.6]
SAP_BPM_SuperAdmin [→ Section 15.1]
SAP_BPM_SuperDisplay [→ Section 15.1]
SAP_BPM_TRIGGER_EVENT [→ Section 11.5]
SAPUI5 
application [→ Section 12.2]
complete task [→ Section 12.2]
component [→ Section 12.2]
component file [→ Section 12.2]
component structure [→ Section 12.2]
composite control [→ Section 12.2]
Eclipse plugin [→ Section 12.2]
faceless component [→ Section 12.2]
generate a DC [→ Section 12.2]
integrate into SAP BPM [→ Section 12.2]
integrate with SAP BPM [→ Section 12.2]
libraries [→ Section 12.2]
notepad control [→ Section 12.2]
SAP BPM Inbox [→ Section 15.1]
steps to generate UI [→ Section 12.2]
UI component [→ Section 12.2]
UI generation [→ Section 12.1]
UI library [→ Section 12.2]
Scalability [→ Section 1.3]
SCPMappingBean [→ Section 11.4]
mappingid [→ Section 11.4]
persistuntil [→ Section 11.4]
xpath [→ Section 11.4]
Security [→ Section 1.2]
Security artifacts [→ Section 17.2]
Sender agreement [→ Section 5.1] [→ Section 5.4]
Sender authorization [→ Appendix SAP]
Sender communication component [→ Section 11.1]
Sender component [→ Section 4.4]
configure in SAP NetWeaver Administrator [→ Section 11.1]
___Server Java proxy 
develop [→ Section 14.3]
Server process [→ Section 1.3] [→ Section 1.3]
Server proxy [→ Section 14.3]
expose service [→ Section 14.3]
generate [→ Section 14.3]
generation wizard [→ Section 14.3]
test [→ Section 14.3]
Service [→ Section 1.3]
Service composition [→ Section 1.3]
Service group [→ Section 2.2]
configure [→ Section 11.1]
create [→ Section 11.1] [→ Section 10.8]
Service group and reference, configuration [→ Section 11.1]
Service interface [→ Section 4.1] [→ Section 4.4]
add [→ Section 5.2]
import [→ Section 14.3]
integration pattern [→ Section 4.1]
message type and data type [→ Section 4.3]
Service orchestration workflow [→ Section 16.1]
Service reference [→ Section 11.1]
configuration [→ Section 11.1]
configuration steps [→ Section 11.1]
WS [→ Section 11.1]
Service Registry [→ Section 18.1]
access [→ Section 18.4]
activate [→ Section 18.4]
capacities [→ Section 18.4]
Service_name [→ Section 11.6]
Service-oriented architecture (SOA) [→ Appendix Introduction] [→ Section 4.1] [→ Section 2.1] [→ Section 1.1] [→ Section 1.2]
configuration [→ Section 10.9]
maturity level [→ Section 4.1]
strategy [→ Section 1.2]
Services [→ Section 1.3] [→ Section 11.9]
bundling [→ Section 1.3]
Session Manager [→ Section 1.3]
Shipment unit [→ Section 4.2]
Simple Object Access Protocol (SOAP) [→ Section 1.3] [→ Section 19.1]
Simplify communications [→ Section 1.2]
Single point of failure (SPOF) [→ Section 19.1]
Single Service Administration [→ Section 11.2]
SLD software component model [→ Section 3.1]
one software component model [→ Section 3.1]
three software component model [→ Section 3.1]
two software component model [→ Section 3.1]
SMTP [→ Section 1.3]
SOA configuration [→ Section 11.1]
intermediary event [→ Section 11.1]
RFC [→ Section 11.1]
start event [→ Section 11.1]
WS [→ Section 11.1]
XI 3.0 [→ Section 11.1]
SOA work center [→ Section 2.2]
SOAP client [→ Section 5.14]
SOAP UI client tool [→ Section 6.6]
SoapUI [→ Section 12.1]
Social media platform [→ Section 4.1]
Software catalog [→ Section 3.1] [→ Section 2.1]
product [→ Section 3.1]
software component [→ Section 3.1]
Software component [→ Section 3.1] [→ Section 3.5] [→ Section 3.6]
export content [→ Section 18.2]
specify release [→ Section 10.2]
specify support package [→ Section 10.2]
Software component version 
see SWCV [→ Section 4.2]
Software unit [→ Section 2.1]
Source 
namespace and rank [→ Section 3.4]
SSL certificate [→ Section 19.1]
Staging [→ Section 5.4]
Standalone EJB module [→ Section 1.3]
Standalone proxy [→ Section 14.2]
Standalone resource adapter module [→ Section 1.3]
Standalone web module [→ Section 1.3]
Standard services [→ Section 1.3]
Standards [→ Section 1.3]
Standby database [→ Section 19.1]
Start event [→ Section 9.3]
configuration [→ Section 11.1]
event trigger [→ Section 10.4]
output mapping [→ Section 10.4]
start condition [→ Section 10.4]
Start process [→ Section 11.2]
Stateful message processing [→ Section 16.1]
Stateless [→ Section 4.1]
Step over [→ Section 11.8]
Subprocess [→ Section 9.3]
Swap space [→ Section 19.1]
SWCV [→ Section 2.1] [→ Section 4.4]
create [→ Section 6.3]
main types [→ Section 4.1]
namespaces [→ Section 4.2]
Swimlanes [→ Section 9.3]
Swing client [→ Section 6.1]
SXMB_ADM [→ Section 2.1]
SXMB_MONI [→ Section 2.1]
Synchronize Service [→ Section 18.2] [→ Section 18.2]
Synchronous communication [→ Section 4.1]
mapping [→ Section 4.2]
System connections [→ Section 11.1]
System landscape 
setup [→ Section 19.1]
System Landscape Directory 
product [→ Section 18.1]
registration [→ Section 19.4]
System Landscape Directory (SLD) [→ Section 3.1] [→ Section 3.1] [→ Section 4.1] [→ Section 2.1] [→ Section 16.2]
add data or content to [→ Section 3.3]
administration [→ Section 3.3]
automatic bridge forwarding [→ Section 3.4]
bridge [→ Section 3.2]
catalogs [→ Section 3.5]
clear data cache [→ Section 2.1]
connect to CTS+ [→ Section 3.5]
create business system [→ Section 6.3]
create product [→ Section 6.3]
create software component versions [→ Section 6.3]
create technical system [→ Section 6.3]
data supplier [→ Section 3.2]
data supplier configuration [→ Section 3.2]
export business systems [→ Section 8.2]
export data to target [→ Section 3.5]
export products from SAP PI [→ Section 8.2]
export software components [→ Section 8.2]
export technical systems [→ Section 8.2]
full automatic synchronization [→ Section 3.4]
full sync (active) [→ Section 3.4]
functional areas [→ Section 2.1]
group [→ Section 3.1]
import and export [→ Section 3.3]
import business systems [→ Section 8.2]
import objects into ES Repository [→ Section 6.3]
import products into SAP PO [→ Section 8.2]
import software components [→ Section 8.2]
import technical systems [→ Section 8.2]
information categories [→ Section 3.1]
landscape [→ Section 2.1]
manual export and import [→ Section 3.4]
migrate content [→ Section 8.2]
naming convention [→ Section 3.5]
product repository [→ Section 3.1]
registering systems [→ Section 3.2]
self-registration [→ Section 3.5]
server information [→ Section 3.3]
server logs [→ Section 3.3]
status [→ Section 3.3]
stop and start [→ Section 3.3]
strategies [→ Section 3.4]
synchronization [→ Section 3.3]
System-centric process [→ Section 9.2] [→ Section 16.2]
Systems [→ Section 1.2]
group logically [→ Section 3.1]
logical name [→ Section 3.1]
T ⇑
Task [→ Section 10.4]
assign UI [→ Section 12.1]
best practices [→ Section 11.10]
claim [→ Section 15.1]
complete [→ Section 11.6]
create [→ Section 10.4]
filter [→ Section 15.1]
forward [→ Section 15.1]
mapping with process context [→ Section 12.1]
open [→ Section 15.1]
operations [→ Section 11.6]
potential owners [→ Section 12.1]
read data [→ Section 11.6]
release [→ Section 15.1]
Task attributes [→ Section 10.4]
activation time [→ Section 10.4]
administrators [→ Section 10.4]
completion deadline [→ Section 10.4]
component [→ Section 10.4]
custom actions [→ Section 10.4]
custom attributes [→ Section 10.4]
documentation [→ Section 10.4]
excluded owners [→ Section 10.4]
expiration time [→ Section 10.4]
name [→ Section 10.4]
notification [→ Section 10.4]
parameterized texts [→ Section 10.4]
priority [→ Section 10.4]
sharing [→ Section 10.4]
start deadline [→ Section 10.4]
variables [→ Section 10.4]
Task Management tool 
access [→ Section 15.1]
features [→ Section 15.1]
TaskInput [→ Section 10.4]
Tasks service 
URIs list [→ Section 11.6]
Technical monitoring 
overview [→ Section 19.4]
Technical system [→ Section 5.2] [→ Section 3.6]
business system [→ Section 3.1]
maintenance [→ Section 3.1]
manually create [→ Section 3.1]
Telnet [→ Section 7.1]
Test [→ Section 11.1]
Third party developed adapter 
Seeburger [→ Section 5.3]
Third-party applications [→ Section 11.6]
Third-party developed adapter [→ Section 5.3]
Informatica [→ Section 5.3]
iWay [→ Section 5.3]
Thread [→ Section 19.4]
utilization [→ Section 19.4]
Tightly coupled applications [→ Section 1.2]
Toggle breakpoint [→ Section 11.8]
Total cost of ownership (TCO) [→ Section 1.1]
TPZ [→ Section 16.2]
Tracing [→ Section 19.4]
HTTP and SOAP communication channels [→ Section 19.4]
XPI Inspector [→ Section 19.4]
Transaction 
RZ70 [→ Section 3.2]
Transformation [→ Section 1.2]
Transport [→ Section 3.5]
activity [→ Section 18.5]
approach [→ Section 18.5]
mechanism [→ Section 8.2]
non-SAP PI Java objects [→ Section 18.5]
path [→ Section 18.5]
SAP PI-related [→ Section 18.5]
Troubleshoot [→ Section 11.8]
Troubleshooting [→ Section 7.3] [→ Section 2.2]
Tuning [→ Section 11.9]
Two-phase commit protocol [→ Section 4.1]
U ⇑
UDDI [→ Section 18.4]
UI technology 
choose [→ Section 10.2]
Composite Application Framework (CAF) [→ Section 10.2]
dictionary [→ Section 10.2]
JSP/Servlet [→ Section 10.2]
process modeling [→ Section 10.2]
Rules Composer [→ Section 10.2]
service composition [→ Section 10.2]
Visual Composer [→ Section 10.2]
Web Dynpro [→ Section 10.2]
UME [→ Section 10.3]
user [→ Section 10.4]
UME actions [→ Section 11.6]
Unique identifier [→ Section 11.5]
Universal Discovery, Description, and Integration (UDDI) [→ Section 2.1]
Universal worklist 
alternative [→ Section 15.1]
URI [→ Section 11.5]
URI concept [→ Section 11.5]
Usage dependency [→ Section 3.1]
User interface (UI) [→ Section 12.1]
generation [→ Section 12.1]
User Management [→ Section 7.1]
User roles [→ Section 17.1]
User-defined function (UDF) [→ Section 5.2]
User-defined message search [→ Section 7.1]
User-friendly interface [→ Section 1.2]
V ⇑
Validation [→ Section 13.1]
Value mapping [→ Section 5.7] [→ Section 5.7]
fixed values [→ Section 5.7]
group [→ Section 5.1]
manual approach [→ Section 5.7]
replication from an external source [→ Section 5.7]
Virtual business system 
label [→ Section 5.2]
Virtual logical container [→ Section 4.2]
Virus scan [→ Section 5.4]
Virus scanning 
by adapter [→ Section 5.4]
Visual Composer [→ Section 9.2] [→ Section 12.3]
Visual containers [→ Section 9.3]
Vulnerable security connection [→ Section 1.2]
W ⇑
WAR files [→ Section 1.3]
Web Dynpro 
ABAP [→ Section 12.1]
application [→ Section 13.2]
assign task principals [→ Section 12.1]
generate UI [→ Section 12.1]
Java [→ Section 12.1]
post-configuration steps [→ Section 12.1]
UI generation steps [→ Section 12.1] [→ Section 12.1]
Web service 
authentication [→ Section 14.3]
import external WSDL [→ Section 14.3]
message security [→ Section 14.3]
settings [→ Section 14.3]
transport protocol [→ Section 14.3]
Web Service Description Language (WSDL) [→ Section 6.6] [→ Section 5.13] [→ Section 13.2] [→ Section 10.9]
details [→ Section 5.14]
generate client proxy from [→ Section 14.3]
import steps [→ Section 10.3]
Web Services Navigator [→ Section 7.1] [→ Section 11.2] [→ Section 10.9]
WebDAV [→ Section 18.2]
WebserviceX [→ Section 6.6]
WebUI [→ Section 2.1] [→ Appendix SAP]
Wily Enterprise Manager [→ Section 19.4] [→ Section 19.4]
performance analysis [→ Section 19.4]
Work center [→ Section 2.2]
Workflow engine [→ Section 9.2]
WS connection, assign communication profile [→ Section 11.1]
WS-Security [→ Section 5.9]
X ⇑
XI 3.0 [→ Section 11.1]
XI 3.0 message protocol [→ Section 10.8]
scenarios [→ Section 11.1]
XI message protocol [→ Section 5.2] [→ Section 5.5]
differences from SOAP standard [→ Section 5.5]
XIMailAdapterBean [→ Section 5.2]
XISOAPAdapterBean [→ Section 5.2]
XML [→ Section 11.8]
XML DAS [→ Section 15.2]
XML Data Package (XDP) [→ Section 12.3]
XML file [→ Section 13.6]
XML Schema Definition (XSD) [→ Section 10.3]
create [→ Section 10.3]
import [→ Section 10.3]
XPI Inspector [→ Section 19.4]










Service Pages
The following sections contain notes on how you can contact us. In addition, you are
            provided with further recommendations on the customization of the screen layout for
            your e-book.
         
Praise and Criticism
We hope that you enjoyed reading this book. If it met your expectations, please do
            recommend it. If you think there is room for improvement, please get in touch with
            the editor of the book: Meagan White. We welcome every suggestion for improvement but, of course, also any praise! You
            can also share your reading experience via Twitter, Facebook, or email.
         
Supplements
If there are supplements available (sample code, exercise materials, lists, and so
            on), they will be provided in your online library and on the web catalog page for
            this book. You can directly navigate to this page using the following link: https://www.sap-press.com/4431. Should we learn about typos that alter the meaning or content errors, we will provide
            a list with corrections there, too.
         
Technical Issues
If you experience technical issues with your e-book or e-book account at SAP PRESS,
            please feel free to contact our reader service: support@rheinwerk-publishing.com.
         
Please note, however, that issues regarding the screen presentation of the book content
            are usually not caused by errors in the e-book document. Because nearly every reading
            device (computer, tablet, smartphone, e-book reader) interprets the EPUB or Mobi file
            format differently, it is unfortunately impossible to set up the e-book document in
            such a way that meets the requirements of all use cases.
         
In addition, not all reading devices provide the same text presentation functions
            and not all functions work properly. Finally, you as the user also define with your
            settings how the book content is displayed on the screen.
         
The EPUB format, as currently provided and handled by the device manufacturers, is
            actually primarily suitable for the display of mere text documents, such as novels.
            Difficulties arise as soon as technical text contains figures, tables, footnotes,
            marginal notes, or programming code. For more information, please refer to the section
            Notes on the Screen Presentation and the following section.
         
Should none of the recommended settings satisfy your layout requirements, we recommend
            that you use the PDF version of the book, which is available for download in your
            online library.
         
Recommendations for Screen Presentation and Navigation
We recommend using a sans-serif font, such as Arial or Seravek, and a low font size of approx. 30-40% in portrait format
            and 20-30% in landscape format. The background shouldn't be too bright.
         
Make use of the hyphenation option. If it doesn't work properly, align the text to the left margin. Otherwise,
            justify the text.
         
To perform searches in the e-book, the index of the book will reliably guide you to the really relevant
            pages of the book. If the index doesn't help, you can use the search function of your
            reading device.
         
Since it is available as a double-page spread in landscape format, the table of contents we've included probably gives a better overview of the content and the structure
            of the book than the corresponding function of your reading device. To enable you
            to easily open the table of contents anytime, it has been included as a separate entry
            in the device-generated table of contents.
         
If you want to zoom in on a figure, tap the respective figure once. By tapping once again, you return to the previous screen. If you tap twice (on the
            iPad), the figure is displayed in the original size and then has to be zoomed in to
            the desired size. If you tap once, the figure is directly zoomed in and displayed
            with a higher resolution.
         
For books that contain programming code, please note that the code lines may be wrapped incorrectly or displayed incompletely
            as of a certain font size. In case of doubt, please reduce the font size.
         
About Us and Our Program
The website http://www.sap-press.com provides detailed and first-hand information on our current publishing program. Here,
            you can also easily order all of our books and e-books. Information on Rheinwerk Publishing
            Inc. and additional contact options can also be found at http://www.sap-press.com.
         










Legal Notes
This section contains the detailed and legally binding usage conditions for this e-book.
Copyright Note
This publication is protected by copyright in its entirety. All usage and exploitation
            rights are reserved by the author and Rheinwerk Publishing; in particular the right
            of reproduction and the right of distribution, be it in printed or electronic form.
            © 2017 by Rheinwerk Publishing Inc., Boston (MA)

Your Rights as a User
You are entitled to use this e-book for personal purposes only. In particular, you
            may print the e-book for personal use or copy it as long as you store this copy on
            a device that is solely and personally used by yourself. You are not entitled to any
            other usage or exploitation.
         
In particular, it is not permitted to forward electronic or printed copies to third
            parties. Furthermore, it is not permitted to distribute the e-book on the Internet,
            in intranets, or in any other way or make it available to third parties. Any public
            exhibition, other publication, or any reproduction of the e-book beyond personal use
            are expressly prohibited. The aforementioned does not only apply to the e-book in
            its entirety but also to parts thereof (e.g., charts, pictures, tables, sections of
            text).
         
Copyright notes, brands, and other legal reservations as well as the digital watermark
            may not be removed from the e-book.
         
Digital Watermark
This e-book copy contains a digital watermark, a signature that indicates which person may use this copy.
         
If you, dear reader, are not this person, you are violating the copyright. So please
            refrain from using this e-book and inform us about this violation. A brief email to
            info@rheinwerk-publishing.com is sufficient. Thank you!
         
Trademarks
The common names, trade names, descriptions of goods, and so on used in this publication
            may be trademarks without special identification and subject to legal regulations
            as such.
         
All of the screenshots and graphics reproduced in this book are subject to copyright
            © SAP SE, Dietmar-Hopp-Allee 16, 69190 Walldorf, Germany. SAP, the SAP logo, ABAP,
            Ariba, ASAP, Concur, Concur ExpenseIt, Concur TripIt, Duet, SAP Adaptive Server Enterprise,
            SAP Advantage Database Server, SAP Afaria, SAP ArchiveLink, SAP Ariba, SAP Business
            ByDesign, SAP Business Explorer, SAP BusinessObjects, SAP BusinessObjects Explorer,
            SAP BusinessObjects Lumira, SAP BusinessObjects Roambi, SAP BusinessObjects Web Intelligence,
            SAP Business One, SAP Business Workflow, SAP Crystal Reports, SAP EarlyWatch, SAP
            Exchange Media (SAP XM), SAP Fieldglass, SAP Fiori, SAP Global Trade Services (SAP
            GTS), SAP GoingLive, SAP HANA, SAP HANA Vora, SAP Hybris, SAP Jam, SAP MaxAttention,
            SAP MaxDB, SAP NetWeaver, SAP PartnerEdge, SAPPHIRE NOW, SAP PowerBuilder, SAP PowerDesigner,
            SAP R/2, SAP R/3, SAP Replication Server, SAP S/4HANA, SAP SQL Anywhere, SAP Strategic
            Enterprise Management (SAP SEM), SAP SuccessFactors, The Best-Run Businesses Run SAP,
            TwoGo are registered or unregistered trademarks of SAP SE, Walldorf, Germany.
         
Limitation of Liability
Regardless of the care that has been taken in creating texts, figures, and programs,
            neither the publisher nor the author, editor, or translator assume any legal responsibility
            or any liability for possible errors and their consequences.
         










The Document Archive
The Document Archive contains all figures, tables, and footnotes, if any, for your
            convenience.
         











Figure 1.1    SAP Process Integration Evolution and History
         











Figure 1.2    SAP Composition Environment Evolution and History
         











Figure 1.3    SAP Process Orchestration Evolution and History
         











Figure 1.4    Point-to-Point Integration: Systems Directly Connected to Each Other
         











Figure 1.5    Integration Using an ESB: AEX at the Center of All Message Exchanges
         











Figure 1.6    Process to Order a Computer Using SAP BPM
         











Figure 1.7    Business Rule Flow Based on the Rules Modeling Tool of SAP BRM
         











Figure 1.8    Positioning of SAP PO (SAP Composition Environment and SAP PI)
         











Figure 1.9    Composition of a Simple SAP NetWeaver AS Java Cluster Installation
         











Figure 1.10    Message Server Enabling the Communication and Exchange of Messages between the Different
            Java Server Processes in the Cluster
         











Figure 1.11    Main Layers and Components of the SAP NetWeaver AS Java System
         











Figure 1.12    SAP PI Installation Option, Dual Stack of SAP NetWeaver AS Java and SAP NetWeaver
            AS ABAP (Not SAP PO)
         











Figure 1.13    SAP PI Dual Stack Installed Separately from SAP Composition Environment: Provides
            the Same Features as SAP PO
         











Figure 1.14    SAP PI with Java Only (AEX) and SAP Composition Environment in Separate Installations
         











Figure 1.15    SAP Process Orchestration: AEX, SAP BPM, and SAP BRM in a Single Installation
         











Figure 2.1    Process Integration Tools Landing Page
         











Figure 2.2    ES Repository Architecture
         











Figure 2.3    Enterprise Services Builder: ES Repository
         











Figure 2.4    Downloading ES Builder's Required Java Client Libraries
         











Figure 2.5    Windows Java Runtime Environment
         











Figure 2.6    ES Builder: Available Profiles
         











Figure 2.7    Configuring Personal Settings from ES Builder
         











Figure 2.8    Enterprise Services Registry
         











Figure 2.9    ES Repository Web UI
         











Figure 2.10    Integration Builder
         











Figure 2.11    Configuration Scenario: Graphical Representation
         











Figure 2.12    Cloud Integration Content Management Cockpit
         











Figure 2.13    System Landscape Directory
         











Figure 2.14    System Landscape Directory: Technical Systems
         











Figure 2.15    System Landscape Directory: Products and Software Components
         











Figure 2.16    Monitoring Home Screen for Your Local AEX (pimon)
         











Figure 2.17    SAP NetWeaver Administrator
         











Figure 2.18    SAP NetWeaver Administrator Search Area
         











Figure 2.19    SAP NetWeaver Administrator: System Overview
         











Figure 2.20    SAP NetWeaver Administration: Operations Work Center
         











Figure 2.21    SAP NetWeaver Administrator: Configuration Work Center
         











Figure 2.22    SAP NetWeaver Administrator: Troubleshooting Work Center
         











Figure 2.23    SAP NetWeaver Administrator: Log Viewer
         











Figure 2.24    SAP NetWeaver Administrator: SOA Work Center
         











Figure 2.25    SAP NetWeaver Development Studio: Welcome Page
         











Figure 2.26    Configuration of SAP NetWeaver AS Java in SAP NetWeaver Developer Studio
         











Figure 2.27    SAP PO Perspectives in SAP NetWeaver Developer Studio
         











Figure 3.1    System Landscape Directory Landing Page
         











Figure 3.2    A Technical System in the SLD and Various Tabs Containing Its Data
         











Figure 3.3    Adding Different Systems to a Landscape
         











Figure 3.4    Relationship among Business Systems, Technical Systems, and Software Components
         











Figure 3.5    Specifying a Business System's Role While Creating a New Business System
         











Figure 3.6    Business System: Integration Details
         











Figure 3.7    Relationships among Products and Software Components
         











Figure 3.8    Adding Software Component Dependencies in the SLD
         











Figure 3.9    Adding a New Name Prefix in the SLD Name Reservation
         











Figure 3.10    Adding a Name in the SLD Name Server
         











Figure 3.11    Connecting an ABAP System to the SLD
         











Figure 3.12    Connecting an SAP NetWeaver AS Java System to the SLD
         











Figure 3.13    Forcing an SAP NetWeaver AS Java System to Push Data to the SLD
         











Figure 3.14    SLD Administration Screen
         











Figure 3.15    SLD Administration Details Page and Available Information
         











Figure 3.16    Steps to Manually Export an SLD to a Business System
         











Figure 3.17    Steps to Set Up an SLD Automatic Bridge Forwarding
         











Figure 3.18    Bidirectional Full Automatic Synchronization Example
         











Figure 3.19    Steps to Configure the SLD Full Automatic Synchronization
         











Figure 3.20    Configuring the SLD Full Automatic Synchronization: Defining Ranks
         











Figure 3.21    Import a New SLD CIM or Data
         











Figure 3.22    Steps to Self-Register a Java-Based System with the SLD
         











Figure 3.23    Steps to Set Up a Destination from SAP PO to CTS+
         











Figure 3.24    Exporting SLD Objects with CTS+ Enabled
         











Figure 3.25    Scenario to be Built for Purchase Order Transfer
         











Figure 3.26    The SLD Artifacts and Their Relationships
         











Figure 3.27    First Steps for Creating a Product in the SLD
         











Figure 3.28    Creating a Product in the SLD
         











Figure 3.29    Creating a Software Component in the SLD
         











Figure 3.30    Creating Software Component Dependency to Other Software Components
         











Figure 3.31    Creation of a Technical System
         











Figure 3.32    Adding Software Components to a Technical System
         











Figure 4.1    ES Repository: Components Interaction
         











Figure 4.2    ES Repository: Service Provisioning and Discovery
         











Figure 4.3    Outbound vs. Inbound Service Interfaces
         











Figure 4.4    Examples of Asynchronous and Synchronous Communication
         











Figure 4.5    Operation Mapping
         











Figure 4.6    Process Integration Scenario in ES Builder
         











Figure 4.7    SAP PO Landing Page
         











Figure 4.8    Create Object Screen from the ES Builder
         











Figure 4.9    Import of SWCVs
         











Figure 4.10    Creating the SWCV from SLD
         











Figure 4.11    Configuring and Saving SWCVs
         











Figure 4.12    Create the New Repository Namespace
         











Figure 4.13    Save the New Repository Namespace
         











Figure 4.14    SWCV with New Repository Namespace
         











Figure 4.15    Repository Change Lists
         











Figure 4.16    Creating the Data Type for DT_OrderItem
         











Figure 4.17    Creating the Data Type for DT_Order
         











Figure 4.18    Creating the Message Type for MT_PurchaseOrder
         











Figure 4.19    Creating the Service Interface for SIOA_PurchaseOrder
         











Figure 4.20    Creating Data Type DT_Item
         











Figure 4.21    Creating Message Type MT_CustomerOrder
         











Figure 4.22    Creating Service Interface SIIA_CustomerOrder
         











Figure 4.23    Selecting Source and Target Message
         











Figure 4.24    MT_PurchaseOrder_to_MTCustomerOrder Message Mapping
         











Figure 4.25    Concat Function in Message Mapping
         











Figure 4.26    Delimiter String Parameter in the concat Function
         











Figure 4.27    Creating Operation Mapping for Service Interfaces
         











Figure 5.1    Launching the Integration Directory from the SAP PO Landing Page
         











Figure 5.2    Overview of the Integration Directory: Object Types and Categories
         











Figure 5.3    Alternative Identifier Options for a Party in the Integration Directory
         











Figure 5.4    Added Service Interfaces (Inbound and Outbound) in the Business Component
         











Figure 5.5    Collaboration Profile Tree
         











Figure 5.6    Choosing an Identifier in the Communication Channel
         











Figure 5.7    Adapter Module Processor for an Asynchronous Sender and Receiver Channel
         











Figure 5.8    Adapter Module Processor and Appropriate Position of Modules for Synchronous Sender
            and Receiver Channel
         











Figure 5.9    Example of XMLAnonymizerBean Configuration
         











Figure 5.10    JNDI Browser: Overview Screen
         











Figure 5.11    The Adapter-Specific Message Attributes Enabled in the Communication Channel
         











Figure 5.12    Impact of Activating the ASMA on the Dynamic Configuration
         











Figure 5.13    Example Inbound Processing Configuration in the ICO
         











Figure 5.14    Receiver Determination Routing Conditions in the ICO
         











Figure 5.15    Extended Receiver Determination Configured in the ICO
         











Figure 5.16    Example of Receiver Interface Configuration in the ICO
         











Figure 5.17    Outbound Processing Configuration in the ICO
         











Figure 5.18    Advanced Settings of the ICO: Staging and Logging
         











Figure 5.19    Summary of the Runtime Pipeline Steps Resulting from an ICO
         











Figure 5.20    Composition of the XI Message Protocol
         











Figure 5.21    Configuration Scenario Screen in the Integration Directory
         











Figure 5.22    Cumbersome Way to Achieve Value Translation with If/Else Logic
         











Figure 5.23    Fixed Values Table Example in the ES Repository
         











Figure 5.24    Example of a Value Mapping That Converts One Value (Color) to Another Value (Number)
         











Figure 5.25    The New B2B Integration Cockpit
         











Figure 5.26    Axis Framework Installation Status Page
         











Figure 5.27    Example of a Sender Communication Channel Configured with the Servlet Axis
         











Figure 5.28    Example of a Sender Channel Configuration Using the Axis Framework to Support WS Security
            and WS Addressing
         











Figure 5.29    Example of a REST Sender Communication Channel
         











Figure 5.30    Example of a REST Receiver Communication Channel
         











Figure 5.31    Process Flow and Components of Rule Alerts
         











Figure 5.32    Process Flow of Alert Rules and Their Components
         











Figure 5.33    Alert Rule View from the Integration Directory
         











Figure 5.34    Location of Service Interface API in the ES Repository and Included Operations
         











Figure 5.35    Search Result of the Inbound Service Interface API for the Communication Channel
         











Figure 5.36    Response Containing a List of Communication Channels as a Result of the API
         











Figure 5.37    Import Business Systems into the Integration Directory from the SLD
         











Figure 5.38    Setup of the SOAP Sender Communication Channel for the Business System BS_READERSPARADISE
         











Figure 5.39    Setup of the FTP (File) Receiver Communication Channel for the Business System BS_BOOKFOUNTAIN
         











Figure 5.40    Inbound Processing Setup
         











Figure 5.41    Receiver Setup
         











Figure 5.42    Receiver Interfaces Setup
         











Figure 5.43    Outbound Processing Setup
         











Figure 5.44    Downloading the WSDL or Getting the URL of a Particular ICO
         











Figure 6.1    Settings for PI Tools Configuration with Connection to the SAP NetWeaver AS Java
         











Figure 6.2    Connection Settings for the ES Repository
         











Figure 6.3    Enterprise Integration Patterns for iFlow Supported by SAP NetWeaver Developer Studio
         











Figure 6.4    Steps in Creating an iFlow
         











Figure 6.5    Details for Creating an iFlow
         











Figure 6.6    Sample Generated iFlow
         











Figure 6.7    Creating a New Business Component
         











Figure 6.8    Assigning a Sender or Receiver System to the iFlow
         











Figure 6.9    Assigning a Service Interface to the iFlow
         











Figure 6.10    Configuring the Communication Channel
         











Figure 6.11    Configure Routing and Conditions
         











Figure 6.12    Adding a Mapping to the iFlow
         











Figure 6.13    Check Consistency of, Activate, and Deploy an iFlow
         











Figure 6.14    Deployment Log View
         











Figure 6.15    Red Markers on Compulsory Components to be Configured
         











Figure 6.16    An iFlow in the Integration Directory
         











Figure 6.17    Products Created in the SLD
         











Figure 6.18    Software Components Created in the SLD
         











Figure 6.19    Technical Systems Created in the SLD
         











Figure 6.20    Business Systems Created in the SLD
         











Figure 6.21    Steps to Import Software Components from the SLD
         











Figure 6.22    Creating Namespaces to Hold ES Repository Objects
         











Figure 6.23    Creating a Data Type for the Message Structure
         











Figure 6.24    Data Structure for System A
         











Figure 6.25    Data Structure for System B
         











Figure 6.26    Creating ES Repository Objects from SAP NetWeaver Developer Studio
         











Figure 6.27    Service Interface Definition for the Sender System
         











Figure 6.28    Message Mapping with Source and Target Messages
         











Figure 6.29    Message Mapping with Concatenated Fields
         











Figure 6.30    Operation Mapping with Outbound and Inbound Service Interfaces
         











Figure 6.31    Activating Change Lists for Repository Objects
         











Figure 6.32    Importing Business Systems from the SLD
         











Figure 6.33    End-to-End File Scenario with the Point-to-Point Enterprise Integration Pattern
         











Figure 6.34    Configuring Settings for the Sender Channel
         











Figure 6.35    Source and Target Directories in the File System
         











Figure 6.36    Completely Configured iFlow with Different Components
         











Figure 6.37    Activating the Configured iFlow
         











Figure 6.38    Deploying iFlows and Viewing the Deployment Log
         











Figure 6.39    Sample XML Message Being Sent from the Source File System
         











Figure 6.40    Opening Message Monitoring from the SAP PI Runtime Perspective
         











Figure 6.41    Options in the Export Assistant
         











Figure 6.42    Enabling the Automatic Deployment via XPI Service
         











Figure 6.43    Enabling an Automatic Deployment after Activation
         











Figure 6.44    Selecting the Version History Option
         











Figure 6.45    Version History of an Object
         











Figure 6.46    On Overview of the Latest Activated Version and Deployed Version
         











Figure 6.47    Recipient List (Multiple Senders)
         











Figure 6.48    Sender System Made Generic with a Wildcard Type
         











Figure 6.49    Adding a Sender Agreement in the Senders Tab
         











Figure 6.50    Creating a Sender Agreement
         











Figure 6.51    List of All Sender Agreements That Match an iFlow
         











Figure 6.52    iFlow Scenario for Conversion between USD and Local Currencies on the Reader's Paradise
            Portal
         











Figure 6.53    Creating a Namespace within a Software Component
         











Figure 6.54    Importing External Definitions into the Enterprise Services Repository
         











Figure 6.55    Service Interface Object Creation
         











Figure 6.56    Outbound Service Interface Properties
         











Figure 6.57    Inbound Service Interface Properties
         











Figure 6.58    Importing the Business Systems from the SLD
         











Figure 6.59    iFlow Properties Options to be Selected
         











Figure 6.60    The iFlow's Sender Communication Channel Configuration
         











Figure 6.61    The iFlow's Receiver Communication Channel Configuration
         











Figure 6.62    Overview of the Created and Configured iFlow
         











Figure 6.63    Displaying the iFlow WSDL
         











Figure 6.64    SOAP UI Client Request and Response Messages
         











Figure 7.1    AEX Administration Tools
         











Figure 7.2    Central Administration Tool
         











Figure 7.3    SAP NetWeaver Administrator: Monitoring Home
         











Figure 7.4    SAP PI Local Monitoring: pimon
         











Figure 7.5    pimon Message Monitor: Overview
         











Figure 7.6    pimon Message Monitor: Message List
         











Figure 7.7    pimon Message Monitor: Message Details
         











Figure 7.8    SAP PI Central Monitoring in SAP Solution Manager
         











Figure 7.9    SAP PI Monitoring: Aggregated Error Monitoring in SAP Solution Manager
         











Figure 7.10    User-Defined Message Search
         











Figure 7.11    User-Defined Message Search Filter
         











Figure 7.12    User-Defined Message Search Criteria
         











Figure 7.13    User-Defined Message Search Namespace Prefix
         











Figure 7.14    User-Defined Message Search Indexing
         











Figure 7.15    User-Defined Message Search Advanced Options View
         











Figure 7.16    User-Defined Message Search Select Predefined Filter
         











Figure 7.17    User-Defined Message Search Value
         











Figure 7.18    Troubleshooting: Log Configuration
         











Figure 7.19    Troubleshooting: Log Viewer
         











Figure 7.20    Troubleshooting: Log Viewer, Open View
         











Figure 7.21    Troubleshooting: Log Viewer, Developer Traces
         











Figure 7.22    Troubleshooting: Log Viewer, Error Details Expanded
         











Figure 8.1    Side-by-Side Migration: SAP PI Dual Stack to SAP PO
         











Figure 8.2    Landing Page of the Integration Directory Migration Tool
         











Figure 8.3    System Selection Screen of the Integration Directory Migration Tool
         











Figure 8.4    Selecting Classic Scenarios from the Source System to be Migrated to an SAP PO Target
            System
         











Figure 8.5    Example of a Scenario That Passed the Matcher Check
         











Figure 8.6    Overview of the ICO to be Created in the Target System
         











Figure 8.7    Screen Enabling the Creation of a Change List in the Target System to Include the
            ICO-Related Objects
         











Figure 8.8    Example of the Channel Selection Step When Changing Adapter Properties
         











Figure 8.9    Maintaining Integration Directory Systems in the Migration Tool
         











Figure 8.10    Renaming Rule Creation Example
         











Figure 9.1    BPM Lifecycle
         











Figure 9.2    Coffee Ordering Process
         











Figure 9.3    Scope of SAP Business Workflow
         











Figure 9.4    Scope of SAP Business Process Management across the Landscape
         











Figure 9.5    SAP BPM Positioned inside SAP PO
         











Figure 9.6    Approval Decision Step Modeled as a Gateway
         











Figure 9.7    BPMN 2.0 Palette in SAP BPM via SAP NetWeaver Developer Studio
         











Figure 9.8    BPMN 2.0 Swimlanes: Pool
         











Figure 9.9    White-Box Pool (Top) and Black-Box Pool (Bottom)
         











Figure 9.10    BPMN 2.0 Swimlanes HR and Employee Lanes
         











Figure 9.11    SAP BPM Artifacts: Annotation
         











Figure 9.12    SAP BPM Artifacts Example
         











Figure 9.13    SAP BPM Flow Objects: Events, Activities, and Gateways
         











Figure 9.14    SAP BPM Events
         











Figure 9.15    Escalation Event Triggered from Human Task in SAP BPM
         











Figure 9.16    SAP BPM Activities
         











Figure 9.17    SAP BPM Gateways
         











Figure 9.18    Exclusive Choice Gateway Example
         











Figure 9.19    Event-Based Choice Gateway Example
         











Figure 9.20    Parallel Split and Parallel Join Gateway Example
         











Figure 9.21    Connection Elements in SAP BPM
         











Figure 10.1    Positioning of the AEX and SAP BPM
         











Figure 10.2    Finding your SAP PO Version from the System Information and Components Info Page
         











Figure 10.3    Configuration of SAP NetWeaver AS Java in the SAP NetWeaver Developer Studio
         











Figure 10.4    Connection Settings to the Enterprise Services Repository
         











Figure 10.5    Flow Diagram to Represent the Hiring Process
         











Figure 10.6    BPMN Representation of the Employee Scenario
         











Figure 10.7    How to Select a Different Perspective in SAP NetWeaver Developer Studio
         











Figure 10.8    Creating a Product for the Composite Application
         











Figure 10.9    First Two Steps of the Software Component Creation
         











Figure 10.10    Software Dependencies Selection and Software Component Version Specification
         











Figure 10.11    Selection of Technology Types to be Supported by the Product
         











Figure 10.12    Composite Designer Perspective after the Creation of a Product and Its Different Technologies
         











Figure 10.13    Creating a New SAP BPM Process and Maintaining Its Attributes
         











Figure 10.14    New Process Event and Overview of the Product after the Creation of a Process
         











Figure 10.15    Removing the Connection Line between the Start and End Event Activities
         











Figure 10.16    BPMN Element Added from the Speed Buttons or Palette
         











Figure 10.17    Using the Properties of the Human Activity to Name It
         











Figure 10.18    Completed BPMN Representation of the Process, as Drawn in SAP NetWeaver Developer
            Studio
         











Figure 10.19    Finding the Details of the Errors for the SAP BPM Process
         











Figure 10.20    Structure of the SAP BPM Process Project Tree
         











Figure 10.21    Adding a Type in the Data Type Editor in SAP NetWeaver Developer Studio
         











Figure 10.22    Available Core Data Types
         











Figure 10.23    Pool Properties Displayed in the Properties Tab
         











Figure 10.24    Steps Involved in Configuring UME Principals as Administrators for the Pool
         











Figure 10.25    Defining the Pool Administrator
         











Figure 10.26    Selecting Principal Expressions from the Rules and Functions
         











Figure 10.27    Finding the Unique ID for a Principal in the UME
         











Figure 10.28    Flow Object Details in the General Tab
         











Figure 10.29    Formatting a BPMN Model to Rearrange Its Layout and Increase Readability
         











Figure 10.30    Default Trigger Configuration of a Process
         











Figure 10.31    Trigger Types of an Intermediary Message Event Step
         











Figure 10.32    Example of Timer Configuration Using a Time Offset of Five Minutes
         











Figure 10.33    Rules and Functions for Use when Configuring a Timer Event Using an Expression
         











Figure 10.34    Example Configuration of a Boundary Event Attached to an Automated Activity
         











Figure 10.35    First Steps of Creating a Message Trigger
         











Figure 10.36    Steps to Create a New Message Trigger
         











Figure 10.37    First Steps of Creating a New SAP BPM Task
         











Figure 10.38    Selecting the Process and UI Technology to be Used for the SAP BPM Task
         











Figure 10.39    Details of the New UI Component SAP BPM Task
         











Figure 10.40    Final Look at the Task Object after Linking It to a Web Dynpro Java DC
         











Figure 10.41    Creation of a Variable and Assigning It a Value via Functions and Data Objects
         











Figure 10.42    Example of a Subject Using a Variable to Make Text Dynamic
         











Figure 10.43    Example of a Human Activity Configured with Looping
         











Figure 10.44    Task Properties' Options
         











Figure 10.45    Example of Input Mapping of a Human Activity Used to Populate the Data to be Displayed
            in a Task
         











Figure 10.46    Sample Outbound Mapping of a Human Activity to Populate the Process Context with Data
            Filled by the Process Owner
         











Figure 10.47    Raising an Exception When a Deadline Occurs
         











Figure 10.48    Steps Involved in Setting Up Boundary Events in a Human Activity
         











Figure 10.49    Automated Activity: Configuration of the Interface Tab
         











Figure 10.50    Sample Embedded Subprocess Activity
         











Figure 10.51    Sample SAP BPM Mapping Using Predefined Functions
         











Figure 10.52    Configure a Report Activity
         











Figure 10.53    Creation of a Reporting Data Source
         











Figure 10.54    Following Steps to Configure a Report Activity
         











Figure 10.55    Notification Sample Configuration
         











Figure 10.56    Exclusive Gateway Sample Configuration with Three Gates
         











Figure 10.57    Driving Process Representation with a Parallel Split and Parallel Join
         











Figure 10.58    Configuring the Data Type for a Data Object
         











Figure 10.59    A Process Using an Annotation to Give More Information about a Flow Object
         











Figure 10.60    Example of a Process with Errors
         











Figure 10.61    Steps Involved in Building an SAP BPM Process
         











Figure 10.62    Mapping Data Objects in the Mapping Activity
         











Figure 10.63    Default Rules and Functions Delivered with SAP BPM
         











Figure 10.64    Example of Enforcing the Execution of a Matcher
         











Figure 10.65    Changing the Default Automapping Matcher and Tuning the Algorithm of the Advanced
            Automapping
         











Figure 10.66    Steps Involved in Creating the Custom Functions in an SAP BPM Project
         











Figure 10.67    Expression Used for the Custom Expression Function
         











Figure 10.68    Exception Handling in a Process Using a Boundary Event and an Error End Event
         











Figure 10.69    Choice of Type or Message Protocol to be Used When Calling a Service Interface from
            SAP BPM
         











Figure 10.70    Importing an Operation Mapping in the SAP BPM Process
         











Figure 10.71    Create a New Service Reference for a Service Called from an Automated Activity
         











Figure 10.72    Sample Details for Creating a New Service Reference
         











Figure 10.73    Configuring the Imported Service Interface Properties in the Interface Tab
         











Figure 10.74    Configuration of SAP NetWeaver AS Java in SAP NetWeaver Developer Studio
         











Figure 10.75    Connection Settings for the ES Repository
         











Figure 10.76    Create a New DC in Your Software Component
         











Figure 10.77    Selecting the Process Composer DC Type
         











Figure 10.78    Last Step in the Creation of a New DC
         











Figure 10.79    Empty Generated Process
         











Figure 10.80    BPMN of the Process of Collecting Acknowledgements
         











Figure 10.81    Importing the WSDL from the ES Repository
         











Figure 10.82    Choosing the Appropriate Service Interface from the ES Repository
         











Figure 10.83    Assigning a Data Type for the Data Object
         











Figure 10.84    Creating a New Message Trigger for the Start Event
         











Figure 10.85    Details of the Message Trigger to be Used for the Start Event
         











Figure 10.86    Mapping the Process Context Data
         











Figure 10.87    Append Newly Received Acknowledgment to Existing One
         











Figure 10.88    Increasing the DO_Counter
         











Figure 10.89    Configuration of the Exclusive Choice
         











Figure 10.90    Time Offset on the Intermediate Timer
         











Figure 10.91    Configuration of the Interface Tab of the Automated Activity
         











Figure 10.92    Mapping the Automatic Activity
         











Figure 10.93    Configuration of an End Event
         











Figure 10.94    Building and Deploying the DC
         











Figure 10.95    Selecting the DCs to be Built
         











Figure 10.96    Deployment Logs in the Deploy View Console
         











Figure 10.97    Configuration of the Application Communication
         











Figure 10.98    Provider System Creation
         











Figure 10.99    Web Services Connectivity Details for Creating an SOA Provider System
         











Figure 10.100    Saved Consumed Service Groups Processing State
         











Figure 10.101    Manually Starting the SAP BPM Process
         











Figure 10.102    Monitoring All Running Processes in SAP PO
         











Figure 11.1    Communication Options between SAP BPM and Other Systems
         











Figure 11.2    Setting the SAP BPM Service Reference to Call the Appropriate Service as WS
         











Figure 11.3    Sender Communication Channel Settings When SAP BPM Communicates with the AEX via WS
         











Figure 11.4    Application and Scenario Communication in the SOA Tab of SAP NetWeaver Administrator
         











Figure 11.5    Status of Nonconfigured Service Group for Process DC
         











Figure 11.6    Editing the Service Group and Choosing to Create a New Provider System
         











Figure 11.7    First Steps of Creating a New Provider System
         











Figure 11.8    Pointing the Service Group to the Newly Created Provider System
         











Figure 11.9    Sender Communication Channel with XI 3.0 Message Protocol Sender
         











Figure 11.10    ICO Using the Sender Communication Channel with an XI 3.0 Protocol
         











Figure 11.11    Configuration of the Service Reference
         











Figure 11.12    Configuration of a Service Reference for an XI-Based Communication in SAP NetWeaver
            Administrator
         











Figure 11.13    Setting of the SAP BPM Service Reference to Call an RFC Function Module
         











Figure 11.14    Creating a Provider System for the RFC Service Group
         











Figure 11.15    Steps to Configure the RFC Provider System
         











Figure 11.16    Process Repository Overview with the List of Components
         











Figure 11.17    Start an SAP BPM Process from SAP NetWeaver Administrator
         











Figure 11.18    Provide Input Data for the Process
         











Figure 11.19    Endpoint of the SAP BPM Process as Seen in the Message Event Trigger
         











Figure 11.20    Steps in Creating an EJB Module DC
         











Figure 11.21    Steps in Creating an EAR Module DC
         











Figure 11.22    Adding Dependencies to a DC
         











Figure 11.23    Creating a New Session Bean
         











Figure 11.24    JNDI Lookup of the EJB
         











Figure 11.25    Creating a Custom EJB Function
         











Figure 11.26    Adding the JNDI Reference to the EJB Function
         











Figure 11.27    Using the Newly Created Custom EJB Function
         











Figure 11.28    Enterprise Integration Patterns: Claim Check
         











Figure 11.29    Receiver Communication Channel Configured for the Claim Check Pattern
         











Figure 11.30    Setup of Services to Publish SAP BPM Events
         











Figure 11.31    Placing a Breakpoint on an Activity before Debugging the Process
         











Figure 11.32    Creating a Debug Configuration in SAP NetWeaver Developer Studio
         











Figure 11.33    SAP NetWeaver Developer Studio Debug Perspective
         











Figure 11.34    Tuning and Modifying the SAP BPM Action Parameters
         











Figure 11.35    Selecting the DC Type
         











Figure 11.36    Adding Dependencies to the EJB DC
         











Figure 11.37    Adding the tc/bpem/mapping/facade Dependency
         











Figure 11.38    Adding the tc/je/sdo21/api Dependency
         











Figure 11.39    Dependencies Details Options for the Enterprise Application DC
         











Figure 11.40    Creating an EJB Session Bean
         











Figure 11.41    Details of the Session Bean to be Created
         











Figure 11.42    Extends Interface with Function, SdoInvoker
         











Figure 11.43    Build and Deploy the EAR DC
         











Figure 11.44    Looking Up the JNDI Name of the EJB Function
         











Figure 11.45    Using the New EJB Function Option
         











Figure 11.46    Creating an EJB Function
         











Figure 11.47    Maintaining the JNDI Name of the Custom EJB Function
         











Figure 11.48    Newly Created EJB Custom Function Available to Use
         











Figure 12.1    Overview of SAP BPM Process for Generating the Web Dynpro UI
         











Figure 12.2    Definition Structure of the Data Object to be Used to Generate a Web Dynpro UI
         











Figure 12.3    Creating a New Web Dynpro UI for the Human Task
         











Figure 12.4    Details of the Web Dynpro Task to be Created
         











Figure 12.5    Selecting the Web Dynpro UI Technology with a New Development Component
         











Figure 12.6    Selecting the Software Component for the New Development Component
         











Figure 12.7    Details of the New Web Dynpro DC
         











Figure 12.8    Component Details for the Web Dynpro UI
         











Figure 12.9    Process Context for the Web Dynpro UI Generation
         











Figure 12.10    Created and Assigned Web Dynpro UI to Task
         











Figure 12.11    Web Dynpro UI Components and Views
         











Figure 12.12    Web Dynpro UI Component View Details
         











Figure 12.13    Task Folder Displaying the Web Dynpro UI for Task Execution
         











Figure 12.14    Assigning Users for Web Dynpro UI Task Execution
         











Figure 12.15    Searching for Users from the UME to Assign to the Task
         











Figure 12.16    Mapping for Data Input and Output from and to the Web Dynpro UI
         











Figure 12.17    The MVC Paradigm Architecture
         











Figure 12.18    Sample SAP BPM Process with Human Activity to a Consumer SAPUI5 Application
         











Figure 12.19    Creating a New SAPUI5 Application from SAP BPM
         











Figure 12.20    Naming the SAPUI5 Task
         











Figure 12.21    Selecting the SAPUI5 Technology
         











Figure 12.22    Process Context Details for Generating the SAPUI5 Application
         











Figure 12.23    Custom SAPUI5 Data Types Generated
         











Figure 12.24    Assigning a Task's Potential Owner to SAPUI5 for Task Execution
         











Figure 12.25    JavaScript Code Generated for the SAPUI5 Controller
         











Figure 12.26    Creating Dependency of the EAR DC to the SAPUI5 DC
         











Figure 12.27    SAP NetWeaver Administrator Settings for notificationTask from uwl to bpm_inbox
         











Figure 12.28    SAP BPM Inbox Tasks for SAPUI5
         











Figure 12.29    Completing a Task from the SAPUI5 Application via the Web Browser
         











Figure 12.30    Creating a Task to Support a Custom UI Technology
         











Figure 12.31    Steps in Integrating a Custom UI Technology with SAP BPM
         











Figure 13.1    Basic Architecture of a BRMS Platform
         











Figure 13.2    Positioning SAP BRM within SAP PO
         











Figure 13.3    Rules Composer with Flow Ruleset in SAP NetWeaver Developer Studio
         











Figure 13.4    Embedded Rule as Gateway Condition in Process Flow
         











Figure 13.5    Rules Manager
         











Figure 13.6    Business Rules Access Control Management
         











Figure 13.7    Rules Manager Editing Tool
         











Figure 13.8    Business Rules Execution Logs
         











Figure 13.9    Business Rules Execution Logs Advanced Search in SAP NetWeaver Administrator
         











Figure 13.10    Business Rules Execution Logs Results in SAP NetWeaver Administrator
         











Figure 13.11    Rules Engine in the SAP NetWeaver Administrator Functional Units Screen
         











Figure 13.12    Importing Development Configuration
         











Figure 13.13    Creating New Rules Composer DC: Wizard 1
         











Figure 13.14    Creating New Rules Composer DC: Wizard 2
         











Figure 13.15    Adding XSD to Rules Composer DC
         











Figure 13.16    Import XML Schema in Rules Composer DC
         











Figure 13.17    Rule Definition in Rule Editor
         











Figure 13.18    Decision Table with Double Vertical Condition
         











Figure 13.19    Decision Table with Multiple Values Condition
         











Figure 13.20    Rule Elements Palette in the Rule Flow Editor
         











Figure 13.21    Flow Ruleset
         











Figure 13.22    Ruleset as Web Service
         











Figure 13.23    Selecting a Workspace in SAP NetWeaver Developer Studio
         











Figure 13.24    SAP NetWeaver Developer Studio Welcome Page
         











Figure 13.25    Creating a New Project in SAP NetWeaver Developer Studio
         











Figure 13.26    New Rules Composer DC Wizard
         











Figure 13.27    Local Software Component Wizard
         











Figure 13.28    Local DC
         











Figure 13.29    Rules Composer DC in SAP NetWeaver Developer Studio
         











Figure 13.30    Importing the XML Schema in SAP BRM DC
         











Figure 13.31    Create New XML Schema Wizard
         











Figure 13.32    POValidationRules.xsd
         











Figure 13.33    SAP BRM Project Resources
         











Figure 13.34    Aliases Wizard: Project Resources
         











Figure 13.35    Aliases Wizard: Creating a New Alias from the XSD Element
         











Figure 13.36    Aliases Wizard: Selecting the XSD Element
         











Figure 13.37    Aliases Wizard: Selecting Aliases from the OrderApproval
         











Figure 13.38    Creating the New Flow Ruleset
         











Figure 13.39    Rule Flow: MainFlow
         











Figure 13.40    New Decision Table
         











Figure 13.41    Decision Table Creation Wizard
         











Figure 13.42    Select Conditions for Decision Table
         











Figure 13.43    Select Actions for Decision Table
         











Figure 13.44    Decision Table with Default Values
         











Figure 13.45    Decision Table with Condition and Output Values
         











Figure 13.46    Rule Flow with Rules Composer Palette
         











Figure 13.47    Rule Flow with Warning
         











Figure 13.48    Decision Table Configuration in Rule Flow
         











Figure 13.49    Rule Flow with Configured Decision Table
         











Figure 13.50    Gateway Activity for Input Validation
         











Figure 13.51    Test Scenario Tab: Create XML
         











Figure 13.52    Test Scenario: Select XSD
         











Figure 13.53    Test Scenario: Create XML
         











Figure 13.54    Test Scenario: Select Root Element
         











Figure 13.55    Test Scenario: Add XML
         











Figure 13.56    Test Scenario: Select XML to Test
         











Figure 13.57    Test Scenario: XML Input for Test Business Rule
         











Figure 13.58    Test Scenario: POValidationRules.xml
         











Figure 13.59    Test Scenario: Run Test Scenario
         











Figure 13.60    Test Scenario: Rules Testing Console
         











Figure 14.1    The Java Server Proxy Providing a Web Service
         











Figure 14.2    The Java Client Proxy Consuming a Web Service
         











Figure 14.3    Structure of the EJB Development Component Project
         











Figure 14.4    Structure of the EAR Development Component Project
         











Figure 14.5    Inbound Service Interface to be Used for the Generation of the Server Proxy
         











Figure 14.6    Last Steps to Create an EJB DC
         











Figure 14.7    Naming the EAR DC and Setting Up Its Dependencies
         











Figure 14.8    Option to Switch to the Java EE Perspective
         











Figure 14.9    First Steps of Importing a Service Interface from the ES Repository
         











Figure 14.10    Selecting the Inbound Service Interface from the ES Repository
         











Figure 14.11    The Imported Inbound Service Interface in the Project
         











Figure 14.12    Seting the Configuration of the Web Service to Assemble Service
         











Figure 14.13    Global Customizations Options
         











Figure 14.14    Screen to Resolve Collisions
         











Figure 14.15    Java Classes Generated for the Server Proxy
         











Figure 14.16    CalculatorSyncInboundImplBean Class Generated with Empty Method Implementation
         











Figure 14.17    Building Both EJB and EAR DCs
         











Figure 14.18    Selecting Both EJB and EAR DCs
         











Figure 14.19    Selecting the Inbound Service Interface from the Single Service Administration in
            SAP NetWeaver Administrator
         











Figure 14.20    Configuration Tab of the Single Service Administration Application
         











Figure 14.21    Security Step during the Configuration of the New Server Proxy
         











Figure 14.22    Completed Web Service Configuration
         











Figure 14.23    Testing the Web Service Created Using the Java Server Proxy
         











Figure 14.24    Consuming the Server Proxy via the ICO or iFlow
         











Figure 14.25    Client Proxy Calling the External Service via the ICO or iFlow
         











Figure 14.26    Importing the WSDL of an External Web Service as an External Definition in the ES
            Repository
         











Figure 14.27    Importing the Currency Convertor Outbound Service Interface in the EJB DC
         











Figure 14.28    Menu Option to Generate the Client Proxy Based on a WSDL
         











Figure 14.29    Set the Configuration of the Web Service to Assemble Client
         











Figure 14.30    Java Classes Generated for the Client Proxy
         











Figure 14.31    Creating a Session Bean to Host the Wrapper Code
         











Figure 14.32    Filling in Details of the Session Bean to Wrap the Client Proxy
         











Figure 14.33    Consumer Proxies Configuration in the Single Service Administration Application
         











Figure 14.34    Maintaining the Sender Component Value for an XI 3.0 Connectivity to the AEX
         











Figure 14.35    New Client Proxy Configuration Using SOAP as Transport Binding
         











Figure 14.36    Orchestrating Different Client Proxies from the Server Proxy
         











Figure 14.37    Creating a DC of Type EJB
         











Figure 14.38    Details of the Client Java Proxy DC
         











Figure 14.39    Importing the Outbound Service Interface
         











Figure 14.40    Picking the Outbound Service Interface from the ES Repository
         











Figure 14.41    Generation of the Java Client Proxy from the Imported WSDL
         











Figure 14.42    Creating a Package or Session Bean to Host the Wrapper Code
         











Figure 14.43    Details of the Session Bean to Wrap the Client Proxy
         











Figure 14.44    Managing the Reference of Entities
         











Figure 14.45    Selecting the Package to be Exposed with the Public Part
         











Figure 14.46    Details of the Server Proxy to Host Implementation
         











Figure 14.47    Adding Dependencies on the Server DC to the Client DC
         











Figure 14.48    Select the Type of Object to be Imported
         











Figure 14.49    Selecting the Appropriate Inbound Service Interface
         











Figure 14.50    Set the Configuration of the Web Service to the Assemble Client Level
         











Figure 14.51    Global Customizations Options
         











Figure 14.52    Generated Java Classes for the Server Proxy
         











Figure 14.53    Inbound Service Interface Used for the Java Server Proxy Generation
         











Figure 14.54    Details of the EAR DC
         











Figure 14.55    Build and Deploy the EAR Development Component
         











Figure 14.56    Consumer Proxies Configuration in the Single Service Administration Application
         











Figure 14.57    New Client Proxy Configuration Using SOAP Transport Binding
         











Figure 14.58    Select the Inbound Service Interface from the Single Service Administration in SAP
            NetWeaver Administrator
         











Figure 14.59    Downloading the WSDL or Testing the Service
         











Figure 15.1    SAP BPM System Overview Monitoring Tool
         











Figure 15.2    Process Repository Overview with List of Components
         











Figure 15.3    The Main Page for Managing Processes
         











Figure 15.4    Advanced Filtering: Filtering Processes Based on Attributes
         











Figure 15.5    Details of a Process Instance
         











Figure 15.6    Getting the Definition of a Process and Displaying Its Definition Flow
         











Figure 15.7    History of Process Instance Activities
         











Figure 15.8    Inspection of the Context Data of a Process Instance
         











Figure 15.9    Actions to be Performed on a Process Instance
         











Figure 15.10    Managing All SAP BPM Tasks from Task Management
         











Figure 15.11    Configuring the SAP BPM Inbox in SAP PO
         











Figure 15.12    SAP BPM Inbox Application
         











Figure 15.13    SAP BPM Process Business Lifecycle Logs
         











Figure 15.14    SAP BPM Action Monitor
         











Figure 15.15    Rules Business Logs Application
         











Figure 15.16    Monitoring Processes and Tasks with the SAP BPM Analytics Dashboard
         











Figure 15.17    Java Archiving Cockpit Prefilled with the SAP BPM Process Instance ID
         











Figure 15.18    Log Viewer Application to Retrieve Traces and Logs
         











Figure 16.1    Process Steps Migration Procedure
         











Figure 16.2    Translating ccBPM into BPMN 2.0
         











Figure 16.3    Exporting ES Repository Objects
         











Figure 16.4    Selecting Individual ES Repository Objects
         











Figure 16.5    Abstract Service Category in SAP PO
         











Figure 16.6    Migration Tool in SAP NetWeaver Administrator
         











Figure 16.7    Integration Directory Migration Tool Main Page
         











Figure 16.8    Scenario Migration
         











Figure 16.9    Selecting the Scenario Migration Criteria
         











Figure 16.10    Migration Tool Renaming Rules
         











Figure 17.1    Executing the CTC Wizard for PI Cloud Integration Content
         











Figure 17.2    Copying the Content to the Design Space
         











Figure 17.3    Selecting the Product Profile to Match Your SAP PO Installation
         











Figure 17.4    Export the Content to Your Local Computer as a ZIP File
         











Figure 17.5    Cloud Integration Content Management Cockpit
         











Figure 17.6    Deploying Integration Content from a ZIP File
         











Figure 17.7    Monitoring the Availability of the Integration Gateway
         











Figure 17.8    Impression of the Cloud Integration Content
         











Figure 18.1    Structure of Component Model, Including Products, Software, and DCs
         











Figure 18.2    Creating a New Software Component from SAP NetWeaver Developer Studio
         











Figure 18.3    Details of the SC
         











Figure 18.4    Possible DC Types within SAP NetWeaver Developer Studio
         











Figure 18.5    Creating a New DC in Your SC
         











Figure 18.6    DC Dependencies
         











Figure 18.7    Selecting a DC as a Dependency
         











Figure 18.8    Selecting the Dependency Type
         











Figure 18.9    Enabling Visibility and Dependencies Using Public Parts between Different DCs
         











Figure 18.10    Adding Different Entities or Development Objects to a Public Part
         











Figure 18.11    Public Part Populated with Entities That Are Able to be Accessed by the Outside World
         











Figure 18.12    SAP NetWeaver Development Infrastructure Landing Page
         











Figure 18.13    SAP NetWeaver Development Infrastructure and Its Components
         











Figure 18.14    Main Page of Development Configuration Management
         











Figure 18.15    Specifying the Name and Caption of the New Development Configuration
         











Figure 18.16    The Software Component Definition Tab of a Development Configuration
         











Figure 18.17    Adding a New SC to the Development Configuration from the SLD
         











Figure 18.18    Saving the Development Configuration after Adding SCs
         











Figure 18.19    Adding a New Development Configuration in SAP NetWeaver Developer Studio
         











Figure 18.20    Options Available to Create a Development Configuration
         











Figure 18.21    Renaming the Development Configuration While Importing It to SAP NetWeaver Developer
            Studio
         











Figure 18.22    SAP NetWeaver Development Infrastructure with Two Development Configurations for Two
            SAP PO Runtime Systems
         











Figure 18.23    Launching the Synchronize Service Option from the Related Links Menu
         











Figure 18.24    Updating the Dependencies of a Development Configuration Using the Synchronization
            Service
         











Figure 18.25    Recommended Action to Synchronize SCs
         











Figure 18.26    Accessing the Export Service from the Development Configuration Management Page
         











Figure 18.27    Select the Development Configuration with the Desired SC
         











Figure 18.28    Specifying Export Options for the SCs
         











Figure 18.29    History Service Main Page
         











Figure 18.30    Checking In an Open Activity to the DTR via SAP NetWeaver Developer Studio
         











Figure 18.31    Options to Resolve Conflicts from SAP NetWeaver Developer Studio
         











Figure 18.32    Legend of the Icons Used in the DTR
         











Figure 18.33    Architecture of the CBS and Its Relation to Other SAP NetWeaver Development Infrastructure
            Components
         











Figure 18.34    CBS Overview of the Buildspaces
         











Figure 18.35    DCs Created as Part of an SAP CAF Development
         











Figure 18.36    Default Structure of a Newly Created Business Object and Its Fields
         











Figure 18.37    Populating the Business Object Fields Using the Structure Editor
         











Figure 18.38    List of Standard Operations in a Business Object
         











Figure 18.39    Application Service Diagram
         











Figure 18.40    Example EJB with Implementation Open for Custom Logic
         











Figure 18.41    SAP CAF Service Browser with a List of All Available Operations
         











Figure 18.42    Service Registry Landing Page
         











Figure 18.43    Services Registry Configuration
         











Figure 18.44    Typical Transport Path for SAP PO
         











Figure 18.45    CTS Server Destination Settings
         











Figure 18.46    Configuring CTS Parameters in SAP NetWeaver Administrator
         











Figure 18.47    Transport Settings Options in CM Services
         











Figure 18.48    SAP NetWeaver Administrator: Configuration
         











Figure 18.49    Configuration Wizard
         











Figure 18.50    Configuration Wizard: Execute Configuration Task
         











Figure 18.51    Configuration Wizard: SLD Configuration
         











Figure 18.52    Configuration Wizard: Define Software Component Version
         











Figure 18.53    Configuration Wizard: Select Application Template
         











Figure 18.54    Configuration Wizard: Registering the New SWCV in the SLD
         











Figure 18.55    Configuration Wizard: Finish Screen
         











Figure 18.56    Configuration Wizard: View Log
         











Figure 18.57    Development Infrastructure
         











Figure 18.58    Development Infrastructure: Edit Development Configuration
         











Figure 18.59    Development Infrastructure: Add SC
         











Figure 18.60    Development Infrastructure: Add Software Components
         











Figure 18.61    Development Infrastructure: Save Development Configuration
         











Figure 18.62    Development Infrastructure: Development Configuration
         











Figure 19.1    Single Points of Failure
         











Figure 19.2    High Availability Web Dispatcher Setup
         











Figure 19.3    Parallel Web Dispatcher Setup
         











Figure 19.4    High Availability with Standalone Enqueue
         











Figure 19.5    Web Dispatcher Placed in DMZ
         











Figure 19.6    High Availability Database
         











Figure 19.7    Java System Architecture
         











Figure 19.8    Position of the Java Central Services Instance
         











Figure 19.9    Database Connection Pool Settings
         











Figure 19.10    Status of Components within the Runtime Workbench
         











Figure 19.11    Runtime Workbench SLD Registration
         











Figure 19.12    SAP MC
         











Figure 19.13    Module Configuration for HTTP Tracing
         











Figure A.1    SAP API Management Positioning
         











Figure A.2    On-Premise to Cloud Integration with SAP Cloud Platform Integration and SAP PO
         











Figure A.3    Setting Up the Operations Server in Eclipse
         











Figure A.4    Configuring Details of the Repository Connection to Point to SAP PO's ES Repository
         











Figure A.5    Creation of an iFlow
         











Figure A.6    Specifying Details of the iFlow and Its Pattern Template
         











Figure A.7    iFlow Based on the Point-to-Point Channel Pattern Template
         











Figure A.8    Configure Sender System and Maintain Authorization
         











Figure A.9    Parameters File
         











Figure A.10    Mapping Definition between Source and Target Structures
         











Figure A.11    Final Simple iFlow Configured in SAP Cloud Platform Integration
         











Figure A.12    Message Monitoring from the Eclipse IDE
         











Figure A.13    Runtime Status from WebUI
         











Figure A.14    Different Stages Enabled by the Integration Advisor
         











Figure A.15    Workflow Editor in SAP Web IDE
         











Figure A.16    Service Task to Invoke Rules Service
         











Figure A.17    My Inbox Showing Workflow Human Tasks
         











Figure A.18    Integrating with SAP Cloud Platform Workflow
         


























